/*! For license information please see build.js.LICENSE.txt */
!(function (t) {
  var e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var r = (e[i] = { i: i, l: !1, exports: {} });
    return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, i) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var r in t)
          n.d(
            i,
            r,
            function (e) {
              return t[e];
            }.bind(null, r)
          );
      return i;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = "/"),
    n((n.s = 4));
})([
  function (t, e, n) {
    "use strict";
    function i(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function r(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = void 0);
    var o = (function () {
      function t(e) {
        var n =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        i(this, t),
          (this.$el = e),
          (this.componentName = ""),
          (this.parent = null),
          (this.root = this),
          (this.definitions = []),
          (this.refs = {}),
          (this._componentInstances = []),
          n && this.init(n);
      }
      var e, n, o;
      return (
        (e = t),
        (n = [
          {
            key: "$one",
            value: function (t) {
              return this.$el.querySelector(t);
            },
          },
          {
            key: "$all",
            value: function (t) {
              return [].slice.call(this.$el.querySelectorAll(t));
            },
          },
          {
            key: "init",
            value: function (t) {
              (this.definitions = t),
                this.parse(),
                this.root === this && this.onAppReady();
            },
          },
          {
            key: "onAppReady",
            value: function () {
              this._componentInstances.forEach(function (t) {
                return t.onAppReady();
              });
            },
          },
          {
            key: "dispose",
            value: function () {
              this.disposeChildren(), this.destroy();
            },
          },
          {
            key: "disposeChildren",
            value: function () {
              this._componentInstances.forEach(function (t) {
                t.dispose();
              }),
                (this._componentInstances = []),
                (this.refs = {});
            },
          },
          {
            key: "replaceContent",
            value: function (t) {
              this.disposeChildren(), (this.$el.innerHTML = t), this.parse();
            },
          },
          {
            key: "destroy",
            value: function () {
              this.parent &&
                this.$el.parentNode &&
                this.$el.parentNode === this.parent.$el &&
                this.parent.$el.removeChild(this.$el),
                (this.parent = null),
                (this.$el = null);
            },
          },
          {
            key: "findInstance",
            value: function (t) {
              var e = this._componentInstances.filter(function (e) {
                return e.componentName === t;
              });
              if (e && e.length) return e[0];
              for (var n = 0, i = this._componentInstances.length; n < i; n++)
                if (
                  void 0 !== (e = this._componentInstances[n].findInstance(t))
                )
                  return e;
            },
          },
          {
            key: "findAllInstances",
            value: function (t) {
              for (
                var e = this._componentInstances.filter(function (e) {
                    return e.componentName === t;
                  }),
                  n = 0,
                  i = this._componentInstances.length;
                n < i;
                n++
              )
                e = e.concat(this._componentInstances[n].findAllInstances(t));
              return e;
            },
          },
          {
            key: "parse",
            value: function () {
              var t = this;
              !(function t(e, n) {
                var i, r;
                (e = null == (r = e) ? [] : Array.isArray(r) ? r : [r]),
                  (e = [].slice.call(e));
                for (var o = 0, s = e.length; o < s; o++)
                  (i = e[o]) &&
                  i.hasAttribute &&
                  i.hasAttribute("data-component")
                    ? n(i)
                    : i.childNodes &&
                      i.childNodes.length &&
                      t([].slice.call(i.childNodes), n);
              })(this.$el, function (e) {
                var n,
                  i,
                  r =
                    e && e.getAttribute ? e.getAttribute("data-component") : "";
                1 === e.nodeType &&
                  r &&
                  ("FORM" === e.tagName &&
                    console.warn(
                      "FORM tag does not support data-component. You should encapsulate the <form> with a <div> in component ".concat(
                        r
                      )
                    ),
                  t.definitions instanceof Function
                    ? (n = t.definitions(r))
                    : t.definitions instanceof Object && (n = t.definitions[r]),
                  n
                    ? (e.removeAttribute("data-component"),
                      ((i = new n(e)).componentName = r),
                      (i.parent = t),
                      (i.root = t.root),
                      i.init(t.definitions),
                      t._componentInstances.push(i),
                      e.getAttribute("data-ref") &&
                        (t.refs[e.getAttribute("data-ref")] = i))
                    : console.warn("Can't find component '".concat(r, "'")));
              }),
                this.ready();
            },
          },
          { key: "ready", value: function () {} },
        ]) && r(e.prototype, n),
        o && r(e, o),
        t
      );
    })();
    e.default = o;
  },
  function (t, e, n) {
    var i,
      r = function (t) {
        var e = {
          addEvent: function (t, e, n, i) {
            t.addEventListener
              ? t.addEventListener(e, n, !1)
              : t.attachEvent &&
                ((t["e" + e + n] = n),
                (t[e + n] = function () {
                  t["e" + e + n](window.event, i);
                }),
                t.attachEvent("on" + e, t[e + n]));
          },
          removeEvent: function (t, e, n) {
            t.removeEventListener
              ? t.removeEventListener(e, n)
              : t.attachEvent && t.detachEvent(e);
          },
          input: "",
          pattern: "38384040373937396665",
          keydownHandler: function (t, n) {
            if (
              (n && (e = n),
              (e.input += t ? t.keyCode : event.keyCode),
              e.input.length > e.pattern.length &&
                (e.input = e.input.substr(e.input.length - e.pattern.length)),
              e.input === e.pattern)
            )
              return (
                e.code(e._currentLink), (e.input = ""), t.preventDefault(), !1
              );
          },
          load: function (t) {
            (this._currentLink = t),
              this.addEvent(document, "keydown", this.keydownHandler, this),
              this.iphone.load(t);
          },
          unload: function () {
            this.removeEvent(document, "keydown", this.keydownHandler),
              this.iphone.unload();
          },
          code: function (t) {
            window.location = t;
          },
          iphone: {
            start_x: 0,
            start_y: 0,
            stop_x: 0,
            stop_y: 0,
            tap: !1,
            capture: !1,
            orig_keys: "",
            keys: [
              "UP",
              "UP",
              "DOWN",
              "DOWN",
              "LEFT",
              "RIGHT",
              "LEFT",
              "RIGHT",
              "TAP",
              "TAP",
            ],
            input: [],
            code: function (t) {
              e.code(t);
            },
            touchmoveHandler: function (t) {
              if (1 === t.touches.length && !0 === e.iphone.capture) {
                var n = t.touches[0];
                (e.iphone.stop_x = n.pageX),
                  (e.iphone.stop_y = n.pageY),
                  (e.iphone.tap = !1),
                  (e.iphone.capture = !1),
                  e.iphone.check_direction();
              }
            },
            touchendHandler: function () {
              if (
                (e.iphone.input.push(e.iphone.check_direction()),
                e.iphone.input.length > e.iphone.keys.length &&
                  e.iphone.input.shift(),
                e.iphone.input.length === e.iphone.keys.length)
              ) {
                for (var t = !0, n = 0; n < e.iphone.keys.length; n++)
                  e.iphone.input[n] !== e.iphone.keys[n] && (t = !1);
                t && e.iphone.code(e._currentLink);
              }
            },
            touchstartHandler: function (t) {
              (e.iphone.start_x = t.changedTouches[0].pageX),
                (e.iphone.start_y = t.changedTouches[0].pageY),
                (e.iphone.tap = !0),
                (e.iphone.capture = !0);
            },
            load: function (t) {
              (this.orig_keys = this.keys),
                e.addEvent(document, "touchmove", this.touchmoveHandler),
                e.addEvent(document, "touchend", this.touchendHandler, !1),
                e.addEvent(document, "touchstart", this.touchstartHandler);
            },
            unload: function () {
              e.removeEvent(document, "touchmove", this.touchmoveHandler),
                e.removeEvent(document, "touchend", this.touchendHandler),
                e.removeEvent(document, "touchstart", this.touchstartHandler);
            },
            check_direction: function () {
              return (
                (x_magnitude = Math.abs(this.start_x - this.stop_x)),
                (y_magnitude = Math.abs(this.start_y - this.stop_y)),
                (x = this.start_x - this.stop_x < 0 ? "RIGHT" : "LEFT"),
                (y = this.start_y - this.stop_y < 0 ? "DOWN" : "UP"),
                (result = x_magnitude > y_magnitude ? x : y),
                (result = !0 === this.tap ? "TAP" : result),
                result
              );
            },
          },
        };
        return (
          "string" == typeof t && e.load(t),
          "function" == typeof t && ((e.code = t), e.load()),
          e
        );
      };
    void 0 !== t.exports
      ? (t.exports = r)
      : void 0 ===
          (i = function () {
            return r;
          }.apply(e, [])) || (t.exports = i);
  },
  function (t, e, n) {},
  ,
  function (t, e, n) {
    "use strict";
    n.r(e);
    var i = {};
    n.r(i),
      n.d(i, "Socials", function () {
        return Uh;
      }),
      n.d(i, "Arrow", function () {
        return Vh;
      }),
      n.d(i, "WorkItem", function () {
        return $h;
      }),
      n.d(i, "Title", function () {
        return rp;
      }),
      n.d(i, "Loader", function () {
        return pp;
      }),
      n.d(i, "Footer", function () {
        return yp;
      }),
      n.d(i, "Menu", function () {
        return Ep;
      }),
      n.d(i, "Home", function () {
        return Dp;
      }),
      n.d(i, "About", function () {
        return Gp;
      }),
      n.d(i, "Work", function () {
        return $p;
      });
    var r = n(0),
      o = n.n(r);
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
      void 0 === Number.isInteger &&
        (Number.isInteger = function (t) {
          return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
        }),
      void 0 === Math.sign &&
        (Math.sign = function (t) {
          return t < 0 ? -1 : t > 0 ? 1 : +t;
        }),
      "name" in Function.prototype == !1 &&
        Object.defineProperty(Function.prototype, "name", {
          get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
          },
        }),
      void 0 === Object.assign &&
        (Object.assign = function (t) {
          if (null == t)
            throw new TypeError("Cannot convert undefined or null to object");
          const e = Object(t);
          for (let t = 1; t < arguments.length; t++) {
            const n = arguments[t];
            if (null != n)
              for (const t in n)
                Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
          }
          return e;
        });
    function s() {}
    Object.assign(s.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[t];
        if (void 0 !== n) {
          const t = n.indexOf(e);
          -1 !== t && n.splice(t, 1);
        }
      },
      dispatchEvent: function (t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const n = e.slice(0);
          for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
        }
      },
    });
    const a = [];
    for (let t = 0; t < 256; t++) a[t] = (t < 16 ? "0" : "") + t.toString(16);
    const c = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function () {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          a[255 & t] +
          a[(t >> 8) & 255] +
          a[(t >> 16) & 255] +
          a[(t >> 24) & 255] +
          "-" +
          a[255 & e] +
          a[(e >> 8) & 255] +
          "-" +
          a[((e >> 16) & 15) | 64] +
          a[(e >> 24) & 255] +
          "-" +
          a[(63 & n) | 128] +
          a[(n >> 8) & 255] +
          "-" +
          a[(n >> 16) & 255] +
          a[(n >> 24) & 255] +
          a[255 & i] +
          a[(i >> 8) & 255] +
          a[(i >> 16) & 255] +
          a[(i >> 24) & 255]
        ).toUpperCase();
      },
      clamp: function (t, e, n) {
        return Math.max(e, Math.min(n, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, n, i, r) {
        return i + ((t - e) * (r - i)) / (n - e);
      },
      lerp: function (t, e, n) {
        return (1 - n) * t + n * e;
      },
      smoothstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * c.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * c.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      },
      setQuaternionFromProperEuler: function (t, e, n, i, r) {
        const o = Math.cos,
          s = Math.sin,
          a = o(n / 2),
          c = s(n / 2),
          l = o((e + i) / 2),
          u = s((e + i) / 2),
          h = o((e - i) / 2),
          p = s((e - i) / 2),
          d = o((i - e) / 2),
          f = s((i - e) / 2);
        switch (r) {
          case "XYX":
            t.set(a * u, c * h, c * p, a * l);
            break;
          case "YZY":
            t.set(c * p, a * u, c * h, a * l);
            break;
          case "ZXZ":
            t.set(c * h, c * p, a * u, a * l);
            break;
          case "XZX":
            t.set(a * u, c * f, c * d, a * l);
            break;
          case "YXY":
            t.set(c * d, a * u, c * f, a * l);
            break;
          case "ZYZ":
            t.set(c * f, c * d, a * u, a * l);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                r
            );
        }
      },
    };
    function l(t = 0, e = 0) {
      (this.x = t), (this.y = e);
    }
    function u() {
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    let h;
    Object.defineProperties(l.prototype, {
      width: {
        get: function () {
          return this.x;
        },
        set: function (t) {
          this.x = t;
        },
      },
      height: {
        get: function () {
          return this.y;
        },
        set: function (t) {
          this.y = t;
        },
      },
    }),
      Object.assign(l.prototype, {
        isVector2: !0,
        set: function (t, e) {
          return (this.x = t), (this.y = e), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y);
        },
        copy: function (t) {
          return (this.x = t.x), (this.y = t.y), this;
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        },
        addScalar: function (t) {
          return (this.x += t), (this.y += t), this;
        },
        addVectors: function (t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        },
        addScaledVector: function (t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        },
        subScalar: function (t) {
          return (this.x -= t), (this.y -= t), this;
        },
        subVectors: function (t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        },
        multiply: function (t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        },
        multiplyScalar: function (t) {
          return (this.x *= t), (this.y *= t), this;
        },
        divide: function (t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        applyMatrix3: function (t) {
          const e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        },
        clampLength: function (t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        },
        negate: function () {
          return (this.x = -this.x), (this.y = -this.y), this;
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y;
        },
        cross: function (t) {
          return this.x * t.y - this.y * t.x;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        angle: function () {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        },
        distanceTo: function (t) {
          return Math.sqrt(this.distanceToSquared(t));
        },
        distanceToSquared: function (t) {
          const e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        },
        manhattanDistanceTo: function (t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        },
        lerpVectors: function (t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          );
        },
        equals: function (t) {
          return t.x === this.x && t.y === this.y;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        },
        rotateAround: function (t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            o = this.y - t.y;
          return (
            (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this
          );
        },
        random: function () {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        },
      }),
      Object.assign(u.prototype, {
        isMatrix3: !0,
        set: function (t, e, n, i, r, o, s, a, c) {
          const l = this.elements;
          return (
            (l[0] = t),
            (l[1] = i),
            (l[2] = s),
            (l[3] = e),
            (l[4] = r),
            (l[5] = a),
            (l[6] = n),
            (l[7] = o),
            (l[8] = c),
            this
          );
        },
        identity: function () {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function () {
          return new this.constructor().fromArray(this.elements);
        },
        copy: function (t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        },
        extractBasis: function (t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        },
        setFromMatrix4: function (t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        },
        multiply: function (t) {
          return this.multiplyMatrices(this, t);
        },
        premultiply: function (t) {
          return this.multiplyMatrices(t, this);
        },
        multiplyMatrices: function (t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            o = n[0],
            s = n[3],
            a = n[6],
            c = n[1],
            l = n[4],
            u = n[7],
            h = n[2],
            p = n[5],
            d = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            x = i[7],
            b = i[2],
            w = i[5],
            _ = i[8];
          return (
            (r[0] = o * f + s * v + a * b),
            (r[3] = o * m + s * y + a * w),
            (r[6] = o * g + s * x + a * _),
            (r[1] = c * f + l * v + u * b),
            (r[4] = c * m + l * y + u * w),
            (r[7] = c * g + l * x + u * _),
            (r[2] = h * f + p * v + d * b),
            (r[5] = h * m + p * y + d * w),
            (r[8] = h * g + p * x + d * _),
            this
          );
        },
        multiplyScalar: function (t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        },
        determinant: function () {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            o = t[4],
            s = t[5],
            a = t[6],
            c = t[7],
            l = t[8];
          return (
            e * o * l -
            e * s * c -
            n * r * l +
            n * s * a +
            i * r * c -
            i * o * a
          );
        },
        getInverse: function (t, e) {
          void 0 !== e &&
            console.warn(
              "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
            );
          const n = t.elements,
            i = this.elements,
            r = n[0],
            o = n[1],
            s = n[2],
            a = n[3],
            c = n[4],
            l = n[5],
            u = n[6],
            h = n[7],
            p = n[8],
            d = p * c - l * h,
            f = l * u - p * a,
            m = h * a - c * u,
            g = r * d + o * f + s * m;
          if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const v = 1 / g;
          return (
            (i[0] = d * v),
            (i[1] = (s * h - p * o) * v),
            (i[2] = (l * o - s * c) * v),
            (i[3] = f * v),
            (i[4] = (p * r - s * u) * v),
            (i[5] = (s * a - l * r) * v),
            (i[6] = m * v),
            (i[7] = (o * u - h * r) * v),
            (i[8] = (c * r - o * a) * v),
            this
          );
        },
        transpose: function () {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        },
        getNormalMatrix: function (t) {
          return this.setFromMatrix4(t).getInverse(this).transpose();
        },
        transposeIntoArray: function (t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        },
        setUvTransform: function (t, e, n, i, r, o, s) {
          const a = Math.cos(r),
            c = Math.sin(r);
          this.set(
            n * a,
            n * c,
            -n * (a * o + c * s) + o + t,
            -i * c,
            i * a,
            -i * (-c * o + a * s) + s + e,
            0,
            0,
            1
          );
        },
        scale: function (t, e) {
          const n = this.elements;
          return (
            (n[0] *= t),
            (n[3] *= t),
            (n[6] *= t),
            (n[1] *= e),
            (n[4] *= e),
            (n[7] *= e),
            this
          );
        },
        rotate: function (t) {
          const e = Math.cos(t),
            n = Math.sin(t),
            i = this.elements,
            r = i[0],
            o = i[3],
            s = i[6],
            a = i[1],
            c = i[4],
            l = i[7];
          return (
            (i[0] = e * r + n * a),
            (i[3] = e * o + n * c),
            (i[6] = e * s + n * l),
            (i[1] = -n * r + e * a),
            (i[4] = -n * o + e * c),
            (i[7] = -n * s + e * l),
            this
          );
        },
        translate: function (t, e) {
          const n = this.elements;
          return (
            (n[0] += t * n[2]),
            (n[3] += t * n[5]),
            (n[6] += t * n[8]),
            (n[1] += e * n[2]),
            (n[4] += e * n[5]),
            (n[7] += e * n[8]),
            this
          );
        },
        equals: function (t) {
          const e = this.elements,
            n = t.elements;
          for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
          return !0;
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        },
      });
    const p = {
      getDataURL: function (t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          void 0 === h &&
            (h = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "canvas"
            )),
            (h.width = t.width),
            (h.height = t.height);
          const n = h.getContext("2d");
          t instanceof ImageData
            ? n.putImageData(t, 0, 0)
            : n.drawImage(t, 0, 0, t.width, t.height),
            (e = h);
        }
        return e.width > 2048 || e.height > 2048
          ? e.toDataURL("image/jpeg", 0.6)
          : e.toDataURL("image/png");
      },
    };
    let d = 0;
    function f(t, e, n, i, r, o, s, a, h, p) {
      Object.defineProperty(this, "id", { value: d++ }),
        (this.uuid = c.generateUUID()),
        (this.name = ""),
        (this.image = void 0 !== t ? t : f.DEFAULT_IMAGE),
        (this.mipmaps = []),
        (this.mapping = void 0 !== e ? e : f.DEFAULT_MAPPING),
        (this.wrapS = void 0 !== n ? n : 1001),
        (this.wrapT = void 0 !== i ? i : 1001),
        (this.magFilter = void 0 !== r ? r : 1006),
        (this.minFilter = void 0 !== o ? o : 1008),
        (this.anisotropy = void 0 !== h ? h : 1),
        (this.format = void 0 !== s ? s : 1023),
        (this.internalFormat = null),
        (this.type = void 0 !== a ? a : 1009),
        (this.offset = new l(0, 0)),
        (this.repeat = new l(1, 1)),
        (this.center = new l(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new u()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = void 0 !== p ? p : 3e3),
        (this.version = 0),
        (this.onUpdate = null);
    }
    function m(t = 0, e = 0, n = 0, i = 1) {
      (this.x = t), (this.y = e), (this.z = n), (this.w = i);
    }
    function g(t, e, n) {
      (this.width = t),
        (this.height = e),
        (this.scissor = new m(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new m(0, 0, t, e)),
        (n = n || {}),
        (this.texture = new f(
          void 0,
          n.mapping,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.encoding
        )),
        (this.texture.image = {}),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.generateMipmaps =
          void 0 !== n.generateMipmaps && n.generateMipmaps),
        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
    }
    function v(t, e, n) {
      g.call(this, t, e, n), (this.samples = 4);
    }
    function y(t = 0, e = 0, n = 0, i = 1) {
      (this._x = t), (this._y = e), (this._z = n), (this._w = i);
    }
    (f.DEFAULT_IMAGE = void 0),
      (f.DEFAULT_MAPPING = 300),
      (f.prototype = Object.assign(Object.create(s.prototype), {
        constructor: f,
        isTexture: !0,
        updateMatrix: function () {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        },
        toJSON: function (t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            const i = this.image;
            if (
              (void 0 === i.uuid && (i.uuid = c.generateUUID()),
              !e && void 0 === t.images[i.uuid])
            ) {
              let e;
              if (Array.isArray(i)) {
                e = [];
                for (let t = 0, n = i.length; t < n; t++)
                  e.push(p.getDataURL(i[t]));
              } else e = p.getDataURL(i);
              t.images[i.uuid] = { uuid: i.uuid, url: e };
            }
            n.image = i.uuid;
          }
          return e || (t.textures[this.uuid] = n), n;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (t) {
          if (300 !== this.mapping) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case 1e3:
                t.x = t.x - Math.floor(t.x);
                break;
              case 1001:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case 1002:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case 1e3:
                t.y = t.y - Math.floor(t.y);
                break;
              case 1001:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case 1002:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        },
      })),
      Object.defineProperty(f.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.defineProperties(m.prototype, {
        width: {
          get: function () {
            return this.z;
          },
          set: function (t) {
            this.z = t;
          },
        },
        height: {
          get: function () {
            return this.w;
          },
          set: function (t) {
            this.w = t;
          },
        },
      }),
      Object.assign(m.prototype, {
        isVector4: !0,
        set: function (t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setZ: function (t) {
          return (this.z = t), this;
        },
        setW: function (t) {
          return (this.w = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        },
        addScalar: function (t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        },
        addVectors: function (t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        },
        addScaledVector: function (t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        },
        subScalar: function (t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        },
        subVectors: function (t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        },
        multiplyScalar: function (t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        },
        applyMatrix4: function (t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = t.elements;
          return (
            (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        setAxisAngleFromQuaternion: function (t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        },
        setAxisAngleFromRotationMatrix: function (t) {
          let e, n, i, r;
          const o = t.elements,
            s = o[0],
            a = o[4],
            c = o[8],
            l = o[1],
            u = o[5],
            h = o[9],
            p = o[2],
            d = o[6],
            f = o[10];
          if (
            Math.abs(a - l) < 0.01 &&
            Math.abs(c - p) < 0.01 &&
            Math.abs(h - d) < 0.01
          ) {
            if (
              Math.abs(a + l) < 0.1 &&
              Math.abs(c + p) < 0.1 &&
              Math.abs(h + d) < 0.1 &&
              Math.abs(s + u + f - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (s + 1) / 2,
              o = (u + 1) / 2,
              m = (f + 1) / 2,
              g = (a + l) / 4,
              v = (c + p) / 4,
              y = (h + d) / 4;
            return (
              t > o && t > m
                ? t < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(t)), (i = g / n), (r = v / n))
                : o > m
                ? o < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(o)), (n = g / i), (r = y / i))
                : m < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(m)), (n = v / r), (i = y / r)),
              this.set(n, i, r, e),
              this
            );
          }
          let m = Math.sqrt(
            (d - h) * (d - h) + (c - p) * (c - p) + (l - a) * (l - a)
          );
          return (
            Math.abs(m) < 0.001 && (m = 1),
            (this.x = (d - h) / m),
            (this.y = (c - p) / m),
            (this.z = (l - a) / m),
            (this.w = Math.acos((s + u + f - 1) / 2)),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        },
        clampLength: function (t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        },
        lengthSq: function () {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        },
        length: function () {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        },
        manhattanLength: function () {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        },
        lerpVectors: function (t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          );
        },
        equals: function (t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        },
        random: function () {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        },
      }),
      (g.prototype = Object.assign(Object.create(s.prototype), {
        constructor: g,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
          (this.width === t && this.height === e) ||
            ((this.width = t),
            (this.height = e),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
      (v.prototype = Object.assign(Object.create(g.prototype), {
        constructor: v,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (t) {
          return (
            g.prototype.copy.call(this, t), (this.samples = t.samples), this
          );
        },
      })),
      Object.assign(y, {
        slerp: function (t, e, n, i) {
          return n.copy(t).slerp(e, i);
        },
        slerpFlat: function (t, e, n, i, r, o, s) {
          let a = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            u = n[i + 3];
          const h = r[o + 0],
            p = r[o + 1],
            d = r[o + 2],
            f = r[o + 3];
          if (u !== f || a !== h || c !== p || l !== d) {
            let t = 1 - s,
              e = a * h + c * p + l * d + u * f,
              n = e >= 0 ? 1 : -1,
              i = 1 - e * e;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                o = Math.atan2(r, e * n);
              (t = Math.sin(t * o) / r), (s = Math.sin(s * o) / r);
            }
            const r = s * n;
            if (
              ((a = a * t + h * r),
              (c = c * t + p * r),
              (l = l * t + d * r),
              (u = u * t + f * r),
              t === 1 - s)
            ) {
              const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
              (a *= t), (c *= t), (l *= t), (u *= t);
            }
          }
          (t[e] = a), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = u);
        },
        multiplyQuaternionsFlat: function (t, e, n, i, r, o) {
          const s = n[i],
            a = n[i + 1],
            c = n[i + 2],
            l = n[i + 3],
            u = r[o],
            h = r[o + 1],
            p = r[o + 2],
            d = r[o + 3];
          return (
            (t[e] = s * d + l * u + a * p - c * h),
            (t[e + 1] = a * d + l * h + c * u - s * p),
            (t[e + 2] = c * d + l * p + s * h - a * u),
            (t[e + 3] = l * d - s * u - a * h - c * p),
            t
          );
        },
      }),
      Object.defineProperties(y.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          },
        },
        w: {
          get: function () {
            return this._w;
          },
          set: function (t) {
            (this._w = t), this._onChangeCallback();
          },
        },
      }),
      Object.assign(y.prototype, {
        isQuaternion: !0,
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        },
        setFromEuler: function (t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = t._x,
            i = t._y,
            r = t._z,
            o = t.order,
            s = Math.cos,
            a = Math.sin,
            c = s(n / 2),
            l = s(i / 2),
            u = s(r / 2),
            h = a(n / 2),
            p = a(i / 2),
            d = a(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = h * l * u + c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u - h * p * d);
              break;
            case "YXZ":
              (this._x = h * l * u + c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u + h * p * d);
              break;
            case "ZXY":
              (this._x = h * l * u - c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u - h * p * d);
              break;
            case "ZYX":
              (this._x = h * l * u - c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u + h * p * d);
              break;
            case "YZX":
              (this._x = h * l * u + c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u - h * p * d);
              break;
            case "XZY":
              (this._x = h * l * u - c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u + h * p * d);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return !1 !== e && this._onChangeCallback(), this;
        },
        setFromAxisAngle: function (t, e) {
          const n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t) {
          const e = t.elements,
            n = e[0],
            i = e[4],
            r = e[8],
            o = e[1],
            s = e[5],
            a = e[9],
            c = e[2],
            l = e[6],
            u = e[10],
            h = n + s + u;
          if (h > 0) {
            const t = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / t),
              (this._x = (l - a) * t),
              (this._y = (r - c) * t),
              (this._z = (o - i) * t);
          } else if (n > s && n > u) {
            const t = 2 * Math.sqrt(1 + n - s - u);
            (this._w = (l - a) / t),
              (this._x = 0.25 * t),
              (this._y = (i + o) / t),
              (this._z = (r + c) / t);
          } else if (s > u) {
            const t = 2 * Math.sqrt(1 + s - n - u);
            (this._w = (r - c) / t),
              (this._x = (i + o) / t),
              (this._y = 0.25 * t),
              (this._z = (a + l) / t);
          } else {
            const t = 2 * Math.sqrt(1 + u - n - s);
            (this._w = (o - i) / t),
              (this._x = (r + c) / t),
              (this._y = (a + l) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        },
        setFromUnitVectors: function (t, e) {
          let n = t.dot(e) + 1;
          return (
            n < 1e-6
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        },
        angleTo: function (t) {
          return 2 * Math.acos(Math.abs(c.clamp(this.dot(t), -1, 1)));
        },
        rotateTowards: function (t, e) {
          const n = this.angleTo(t);
          if (0 === n) return this;
          const i = Math.min(1, e / n);
          return this.slerp(t, i), this;
        },
        inverse: function () {
          return this.conjugate();
        },
        conjugate: function () {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        },
        dot: function (t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        },
        lengthSq: function () {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        },
        length: function () {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        },
        normalize: function () {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        },
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        },
        premultiply: function (t) {
          return this.multiplyQuaternions(t, this);
        },
        multiplyQuaternions: function (t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            o = t._w,
            s = e._x,
            a = e._y,
            c = e._z,
            l = e._w;
          return (
            (this._x = n * l + o * s + i * c - r * a),
            (this._y = i * l + o * a + r * s - n * c),
            (this._z = r * l + o * c + n * a - i * s),
            (this._w = o * l - n * s - i * a - r * c),
            this._onChangeCallback(),
            this
          );
        },
        slerp: function (t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let s = o * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (s < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (s = -s))
              : this.copy(t),
            s >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const a = 1 - s * s;
          if (a <= Number.EPSILON) {
            const t = 1 - e;
            return (
              (this._w = t * o + e * this._w),
              (this._x = t * n + e * this._x),
              (this._y = t * i + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(a),
            l = Math.atan2(c, s),
            u = Math.sin((1 - e) * l) / c,
            h = Math.sin(e * l) / c;
          return (
            (this._w = o * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        },
        fromBufferAttribute: function (t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          );
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {},
      });
    const x = new w(),
      b = new y();
    function w(t = 0, e = 0, n = 0) {
      (this.x = t), (this.y = e), (this.z = n);
    }
    Object.assign(w.prototype, {
      isVector3: !0,
      set: function (t, e, n) {
        return (this.x = t), (this.y = e), (this.z = n), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      },
      addVectors: function (t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      },
      addScaledVector: function (t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      },
      subVectors: function (t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      },
      multiplyVectors: function (t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      },
      applyEuler: function (t) {
        return (
          (t && t.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(b.setFromEuler(t))
        );
      },
      applyAxisAngle: function (t, e) {
        return this.applyQuaternion(b.setFromAxisAngle(t, e));
      },
      applyMatrix3: function (t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * n + r[6] * i),
          (this.y = r[1] * e + r[4] * n + r[7] * i),
          (this.z = r[2] * e + r[5] * n + r[8] * i),
          this
        );
      },
      applyNormalMatrix: function (t) {
        return this.applyMatrix3(t).normalize();
      },
      applyMatrix4: function (t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
          (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
          (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
          this
        );
      },
      applyQuaternion: function (t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          o = t.y,
          s = t.z,
          a = t.w,
          c = a * e + o * i - s * n,
          l = a * n + s * e - r * i,
          u = a * i + r * n - o * e,
          h = -r * e - o * n - s * i;
        return (
          (this.x = c * a + h * -r + l * -s - u * -o),
          (this.y = l * a + h * -o + u * -r - c * -s),
          (this.z = u * a + h * -s + c * -o - l * -r),
          this
        );
      },
      project: function (t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix
        );
      },
      unproject: function (t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld
        );
      },
      transformDirection: function (t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * n + r[8] * i),
          (this.y = r[1] * e + r[5] * n + r[9] * i),
          (this.z = r[2] * e + r[6] * n + r[10] * i),
          this.normalize()
        );
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      },
      clampLength: function (t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      },
      lerpVectors: function (t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          (this.z = t.z + (e.z - t.z) * n),
          this
        );
      },
      cross: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      },
      crossVectors: function (t, e) {
        const n = t.x,
          i = t.y,
          r = t.z,
          o = e.x,
          s = e.y,
          a = e.z;
        return (
          (this.x = i * a - r * s),
          (this.y = r * o - n * a),
          (this.z = n * s - i * o),
          this
        );
      },
      projectOnVector: function (t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n);
      },
      projectOnPlane: function (t) {
        return x.copy(this).projectOnVector(t), this.sub(x);
      },
      reflect: function (t) {
        return this.sub(x.copy(t).multiplyScalar(2 * this.dot(t)));
      },
      angleTo: function (t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(c.clamp(n, -1, 1));
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        const e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
        return e * e + n * n + i * i;
      },
      manhattanDistanceTo: function (t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      },
      setFromSpherical: function (t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      },
      setFromSphericalCoords: function (t, e, n) {
        const i = Math.sin(e) * t;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(e) * t),
          (this.z = i * Math.cos(n)),
          this
        );
      },
      setFromCylindrical: function (t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      },
      setFromCylindricalCoords: function (t, e, n) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = n),
          (this.z = t * Math.cos(e)),
          this
        );
      },
      setFromMatrixPosition: function (t) {
        const e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      },
      setFromMatrixScale: function (t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = n), (this.z = i), this;
      },
      setFromMatrixColumn: function (t, e) {
        return this.fromArray(t.elements, 4 * e);
      },
      setFromMatrix3Column: function (t, e) {
        return this.fromArray(t.elements, 3 * e);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          t
        );
      },
      fromBufferAttribute: function (t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      },
      random: function () {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      },
    });
    const _ = new w(),
      M = new R(),
      S = new w(0, 0, 0),
      T = new w(1, 1, 1),
      E = new w(),
      A = new w(),
      L = new w();
    function R() {
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    Object.assign(R.prototype, {
      isMatrix4: !0,
      set: function (t, e, n, i, r, o, s, a, c, l, u, h, p, d, f, m) {
        const g = this.elements;
        return (
          (g[0] = t),
          (g[4] = e),
          (g[8] = n),
          (g[12] = i),
          (g[1] = r),
          (g[5] = o),
          (g[9] = s),
          (g[13] = a),
          (g[2] = c),
          (g[6] = l),
          (g[10] = u),
          (g[14] = h),
          (g[3] = p),
          (g[7] = d),
          (g[11] = f),
          (g[15] = m),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new R().fromArray(this.elements);
      },
      copy: function (t) {
        const e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          (e[9] = n[9]),
          (e[10] = n[10]),
          (e[11] = n[11]),
          (e[12] = n[12]),
          (e[13] = n[13]),
          (e[14] = n[14]),
          (e[15] = n[15]),
          this
        );
      },
      copyPosition: function (t) {
        const e = this.elements,
          n = t.elements;
        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
      },
      extractBasis: function (t, e, n) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      },
      makeBasis: function (t, e, n) {
        return (
          this.set(
            t.x,
            e.x,
            n.x,
            0,
            t.y,
            e.y,
            n.y,
            0,
            t.z,
            e.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      extractRotation: function (t) {
        const e = this.elements,
          n = t.elements,
          i = 1 / _.setFromMatrixColumn(t, 0).length(),
          r = 1 / _.setFromMatrixColumn(t, 1).length(),
          o = 1 / _.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = n[0] * i),
          (e[1] = n[1] * i),
          (e[2] = n[2] * i),
          (e[3] = 0),
          (e[4] = n[4] * r),
          (e[5] = n[5] * r),
          (e[6] = n[6] * r),
          (e[7] = 0),
          (e[8] = n[8] * o),
          (e[9] = n[9] * o),
          (e[10] = n[10] * o),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromEuler: function (t) {
        (t && t.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          o = Math.cos(n),
          s = Math.sin(n),
          a = Math.cos(i),
          c = Math.sin(i),
          l = Math.cos(r),
          u = Math.sin(r);
        if ("XYZ" === t.order) {
          const t = o * l,
            n = o * u,
            i = s * l,
            r = s * u;
          (e[0] = a * l),
            (e[4] = -a * u),
            (e[8] = c),
            (e[1] = n + i * c),
            (e[5] = t - r * c),
            (e[9] = -s * a),
            (e[2] = r - t * c),
            (e[6] = i + n * c),
            (e[10] = o * a);
        } else if ("YXZ" === t.order) {
          const t = a * l,
            n = a * u,
            i = c * l,
            r = c * u;
          (e[0] = t + r * s),
            (e[4] = i * s - n),
            (e[8] = o * c),
            (e[1] = o * u),
            (e[5] = o * l),
            (e[9] = -s),
            (e[2] = n * s - i),
            (e[6] = r + t * s),
            (e[10] = o * a);
        } else if ("ZXY" === t.order) {
          const t = a * l,
            n = a * u,
            i = c * l,
            r = c * u;
          (e[0] = t - r * s),
            (e[4] = -o * u),
            (e[8] = i + n * s),
            (e[1] = n + i * s),
            (e[5] = o * l),
            (e[9] = r - t * s),
            (e[2] = -o * c),
            (e[6] = s),
            (e[10] = o * a);
        } else if ("ZYX" === t.order) {
          const t = o * l,
            n = o * u,
            i = s * l,
            r = s * u;
          (e[0] = a * l),
            (e[4] = i * c - n),
            (e[8] = t * c + r),
            (e[1] = a * u),
            (e[5] = r * c + t),
            (e[9] = n * c - i),
            (e[2] = -c),
            (e[6] = s * a),
            (e[10] = o * a);
        } else if ("YZX" === t.order) {
          const t = o * a,
            n = o * c,
            i = s * a,
            r = s * c;
          (e[0] = a * l),
            (e[4] = r - t * u),
            (e[8] = i * u + n),
            (e[1] = u),
            (e[5] = o * l),
            (e[9] = -s * l),
            (e[2] = -c * l),
            (e[6] = n * u + i),
            (e[10] = t - r * u);
        } else if ("XZY" === t.order) {
          const t = o * a,
            n = o * c,
            i = s * a,
            r = s * c;
          (e[0] = a * l),
            (e[4] = -u),
            (e[8] = c * l),
            (e[1] = t * u + r),
            (e[5] = o * l),
            (e[9] = n * u - i),
            (e[2] = i * u - n),
            (e[6] = s * l),
            (e[10] = r * u + t);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromQuaternion: function (t) {
        return this.compose(S, t, T);
      },
      lookAt: function (t, e, n) {
        const i = this.elements;
        return (
          L.subVectors(t, e),
          0 === L.lengthSq() && (L.z = 1),
          L.normalize(),
          E.crossVectors(n, L),
          0 === E.lengthSq() &&
            (1 === Math.abs(n.z) ? (L.x += 1e-4) : (L.z += 1e-4),
            L.normalize(),
            E.crossVectors(n, L)),
          E.normalize(),
          A.crossVectors(L, E),
          (i[0] = E.x),
          (i[4] = A.x),
          (i[8] = L.x),
          (i[1] = E.y),
          (i[5] = A.y),
          (i[9] = L.y),
          (i[2] = E.z),
          (i[6] = A.z),
          (i[10] = L.z),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        const n = t.elements,
          i = e.elements,
          r = this.elements,
          o = n[0],
          s = n[4],
          a = n[8],
          c = n[12],
          l = n[1],
          u = n[5],
          h = n[9],
          p = n[13],
          d = n[2],
          f = n[6],
          m = n[10],
          g = n[14],
          v = n[3],
          y = n[7],
          x = n[11],
          b = n[15],
          w = i[0],
          _ = i[4],
          M = i[8],
          S = i[12],
          T = i[1],
          E = i[5],
          A = i[9],
          L = i[13],
          R = i[2],
          P = i[6],
          C = i[10],
          O = i[14],
          I = i[3],
          D = i[7],
          N = i[11],
          k = i[15];
        return (
          (r[0] = o * w + s * T + a * R + c * I),
          (r[4] = o * _ + s * E + a * P + c * D),
          (r[8] = o * M + s * A + a * C + c * N),
          (r[12] = o * S + s * L + a * O + c * k),
          (r[1] = l * w + u * T + h * R + p * I),
          (r[5] = l * _ + u * E + h * P + p * D),
          (r[9] = l * M + u * A + h * C + p * N),
          (r[13] = l * S + u * L + h * O + p * k),
          (r[2] = d * w + f * T + m * R + g * I),
          (r[6] = d * _ + f * E + m * P + g * D),
          (r[10] = d * M + f * A + m * C + g * N),
          (r[14] = d * S + f * L + m * O + g * k),
          (r[3] = v * w + y * T + x * R + b * I),
          (r[7] = v * _ + y * E + x * P + b * D),
          (r[11] = v * M + y * A + x * C + b * N),
          (r[15] = v * S + y * L + x * O + b * k),
          this
        );
      },
      multiplyScalar: function (t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      },
      determinant: function () {
        const t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          o = t[1],
          s = t[5],
          a = t[9],
          c = t[13],
          l = t[2],
          u = t[6],
          h = t[10],
          p = t[14];
        return (
          t[3] *
            (+r * a * u -
              i * c * u -
              r * s * h +
              n * c * h +
              i * s * p -
              n * a * p) +
          t[7] *
            (+e * a * p -
              e * c * h +
              r * o * h -
              i * o * p +
              i * c * l -
              r * a * l) +
          t[11] *
            (+e * c * u -
              e * s * p -
              r * o * u +
              n * o * p +
              r * s * l -
              n * c * l) +
          t[15] *
            (-i * s * l -
              e * a * u +
              e * s * h +
              i * o * u -
              n * o * h +
              n * a * l)
        );
      },
      transpose: function () {
        const t = this.elements;
        let e;
        return (
          (e = t[1]),
          (t[1] = t[4]),
          (t[4] = e),
          (e = t[2]),
          (t[2] = t[8]),
          (t[8] = e),
          (e = t[6]),
          (t[6] = t[9]),
          (t[9] = e),
          (e = t[3]),
          (t[3] = t[12]),
          (t[12] = e),
          (e = t[7]),
          (t[7] = t[13]),
          (t[13] = e),
          (e = t[11]),
          (t[11] = t[14]),
          (t[14] = e),
          this
        );
      },
      setPosition: function (t, e, n) {
        const i = this.elements;
        return (
          t.isVector3
            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
            : ((i[12] = t), (i[13] = e), (i[14] = n)),
          this
        );
      },
      getInverse: function (t, e) {
        void 0 !== e &&
          console.warn(
            "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
          );
        const n = this.elements,
          i = t.elements,
          r = i[0],
          o = i[1],
          s = i[2],
          a = i[3],
          c = i[4],
          l = i[5],
          u = i[6],
          h = i[7],
          p = i[8],
          d = i[9],
          f = i[10],
          m = i[11],
          g = i[12],
          v = i[13],
          y = i[14],
          x = i[15],
          b =
            d * y * h -
            v * f * h +
            v * u * m -
            l * y * m -
            d * u * x +
            l * f * x,
          w =
            g * f * h -
            p * y * h -
            g * u * m +
            c * y * m +
            p * u * x -
            c * f * x,
          _ =
            p * v * h -
            g * d * h +
            g * l * m -
            c * v * m -
            p * l * x +
            c * d * x,
          M =
            g * d * u -
            p * v * u -
            g * l * f +
            c * v * f +
            p * l * y -
            c * d * y,
          S = r * b + o * w + s * _ + a * M;
        if (0 === S)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / S;
        return (
          (n[0] = b * T),
          (n[1] =
            (v * f * a -
              d * y * a -
              v * s * m +
              o * y * m +
              d * s * x -
              o * f * x) *
            T),
          (n[2] =
            (l * y * a -
              v * u * a +
              v * s * h -
              o * y * h -
              l * s * x +
              o * u * x) *
            T),
          (n[3] =
            (d * u * a -
              l * f * a -
              d * s * h +
              o * f * h +
              l * s * m -
              o * u * m) *
            T),
          (n[4] = w * T),
          (n[5] =
            (p * y * a -
              g * f * a +
              g * s * m -
              r * y * m -
              p * s * x +
              r * f * x) *
            T),
          (n[6] =
            (g * u * a -
              c * y * a -
              g * s * h +
              r * y * h +
              c * s * x -
              r * u * x) *
            T),
          (n[7] =
            (c * f * a -
              p * u * a +
              p * s * h -
              r * f * h -
              c * s * m +
              r * u * m) *
            T),
          (n[8] = _ * T),
          (n[9] =
            (g * d * a -
              p * v * a -
              g * o * m +
              r * v * m +
              p * o * x -
              r * d * x) *
            T),
          (n[10] =
            (c * v * a -
              g * l * a +
              g * o * h -
              r * v * h -
              c * o * x +
              r * l * x) *
            T),
          (n[11] =
            (p * l * a -
              c * d * a -
              p * o * h +
              r * d * h +
              c * o * m -
              r * l * m) *
            T),
          (n[12] = M * T),
          (n[13] =
            (p * v * s -
              g * d * s +
              g * o * f -
              r * v * f -
              p * o * y +
              r * d * y) *
            T),
          (n[14] =
            (g * l * s -
              c * v * s -
              g * o * u +
              r * v * u +
              c * o * y -
              r * l * y) *
            T),
          (n[15] =
            (c * d * s -
              p * l * s +
              p * o * u -
              r * d * u -
              c * o * f +
              r * l * f) *
            T),
          this
        );
      },
      scale: function (t) {
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
        return (
          (e[0] *= n),
          (e[4] *= i),
          (e[8] *= r),
          (e[1] *= n),
          (e[5] *= i),
          (e[9] *= r),
          (e[2] *= n),
          (e[6] *= i),
          (e[10] *= r),
          (e[3] *= n),
          (e[7] *= i),
          (e[11] *= r),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i));
      },
      makeTranslation: function (t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
      },
      makeRotationX: function (t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationY: function (t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationZ: function (t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      makeRotationAxis: function (t, e) {
        const n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          o = t.x,
          s = t.y,
          a = t.z,
          c = r * o,
          l = r * s;
        return (
          this.set(
            c * o + n,
            c * s - i * a,
            c * a + i * s,
            0,
            c * s + i * a,
            l * s + n,
            l * a - i * o,
            0,
            c * a - i * s,
            l * a + i * o,
            r * a * a + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      makeScale: function (t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      },
      makeShear: function (t, e, n) {
        return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
      },
      compose: function (t, e, n) {
        const i = this.elements,
          r = e._x,
          o = e._y,
          s = e._z,
          a = e._w,
          c = r + r,
          l = o + o,
          u = s + s,
          h = r * c,
          p = r * l,
          d = r * u,
          f = o * l,
          m = o * u,
          g = s * u,
          v = a * c,
          y = a * l,
          x = a * u,
          b = n.x,
          w = n.y,
          _ = n.z;
        return (
          (i[0] = (1 - (f + g)) * b),
          (i[1] = (p + x) * b),
          (i[2] = (d - y) * b),
          (i[3] = 0),
          (i[4] = (p - x) * w),
          (i[5] = (1 - (h + g)) * w),
          (i[6] = (m + v) * w),
          (i[7] = 0),
          (i[8] = (d + y) * _),
          (i[9] = (m - v) * _),
          (i[10] = (1 - (h + f)) * _),
          (i[11] = 0),
          (i[12] = t.x),
          (i[13] = t.y),
          (i[14] = t.z),
          (i[15] = 1),
          this
        );
      },
      decompose: function (t, e, n) {
        const i = this.elements;
        let r = _.set(i[0], i[1], i[2]).length(),
          o = _.set(i[4], i[5], i[6]).length(),
          s = _.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (t.x = i[12]),
          (t.y = i[13]),
          (t.z = i[14]),
          M.copy(this);
        const a = 1 / r,
          c = 1 / o,
          l = 1 / s;
        return (
          (M.elements[0] *= a),
          (M.elements[1] *= a),
          (M.elements[2] *= a),
          (M.elements[4] *= c),
          (M.elements[5] *= c),
          (M.elements[6] *= c),
          (M.elements[8] *= l),
          (M.elements[9] *= l),
          (M.elements[10] *= l),
          e.setFromRotationMatrix(M),
          (n.x = r),
          (n.y = o),
          (n.z = s),
          this
        );
      },
      makePerspective: function (t, e, n, i, r, o) {
        void 0 === o &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        const s = this.elements,
          a = (2 * r) / (e - t),
          c = (2 * r) / (n - i),
          l = (e + t) / (e - t),
          u = (n + i) / (n - i),
          h = -(o + r) / (o - r),
          p = (-2 * o * r) / (o - r);
        return (
          (s[0] = a),
          (s[4] = 0),
          (s[8] = l),
          (s[12] = 0),
          (s[1] = 0),
          (s[5] = c),
          (s[9] = u),
          (s[13] = 0),
          (s[2] = 0),
          (s[6] = 0),
          (s[10] = h),
          (s[14] = p),
          (s[3] = 0),
          (s[7] = 0),
          (s[11] = -1),
          (s[15] = 0),
          this
        );
      },
      makeOrthographic: function (t, e, n, i, r, o) {
        const s = this.elements,
          a = 1 / (e - t),
          c = 1 / (n - i),
          l = 1 / (o - r),
          u = (e + t) * a,
          h = (n + i) * c,
          p = (o + r) * l;
        return (
          (s[0] = 2 * a),
          (s[4] = 0),
          (s[8] = 0),
          (s[12] = -u),
          (s[1] = 0),
          (s[5] = 2 * c),
          (s[9] = 0),
          (s[13] = -h),
          (s[2] = 0),
          (s[6] = 0),
          (s[10] = -2 * l),
          (s[14] = -p),
          (s[3] = 0),
          (s[7] = 0),
          (s[11] = 0),
          (s[15] = 1),
          this
        );
      },
      equals: function (t) {
        const e = this.elements,
          n = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        const n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          (t[e + 9] = n[9]),
          (t[e + 10] = n[10]),
          (t[e + 11] = n[11]),
          (t[e + 12] = n[12]),
          (t[e + 13] = n[13]),
          (t[e + 14] = n[14]),
          (t[e + 15] = n[15]),
          t
        );
      },
    });
    const P = new R(),
      C = new y();
    function O(t = 0, e = 0, n = 0, i = O.DefaultOrder) {
      (this._x = t), (this._y = e), (this._z = n), (this._order = i);
    }
    function I() {
      this.mask = 1;
    }
    (O.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
      (O.DefaultOrder = "XYZ"),
      Object.defineProperties(O.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          },
        },
        order: {
          get: function () {
            return this._order;
          },
          set: function (t) {
            (this._order = t), this._onChangeCallback();
          },
        },
      }),
      Object.assign(O.prototype, {
        isEuler: !0,
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t, e, n) {
          const i = c.clamp,
            r = t.elements,
            o = r[0],
            s = r[4],
            a = r[8],
            l = r[1],
            u = r[5],
            h = r[9],
            p = r[2],
            d = r[6],
            f = r[10];
          switch ((e = e || this._order)) {
            case "XYZ":
              (this._y = Math.asin(i(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-s, o)))
                  : ((this._x = Math.atan2(d, u)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-i(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, u)))
                  : ((this._y = Math.atan2(-p, o)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(i(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-p, f)),
                    (this._z = Math.atan2(-s, u)))
                  : ((this._y = 0), (this._z = Math.atan2(l, o)));
              break;
            case "ZYX":
              (this._y = Math.asin(-i(p, -1, 1))),
                Math.abs(p) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, o)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, u)));
              break;
            case "YZX":
              (this._z = Math.asin(i(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, u)),
                    (this._y = Math.atan2(-p, o)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-i(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(d, u)), (this._y = Math.atan2(a, o)))
                  : ((this._x = Math.atan2(-h, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !1 !== n && this._onChangeCallback(), this;
        },
        setFromQuaternion: function (t, e, n) {
          return (
            P.makeRotationFromQuaternion(t), this.setFromRotationMatrix(P, e, n)
          );
        },
        setFromVector3: function (t, e) {
          return this.set(t.x, t.y, t.z, e || this._order);
        },
        reorder: function (t) {
          return C.setFromEuler(this), this.setFromQuaternion(C, t);
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        },
        fromArray: function (t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        },
        toVector3: function (t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new w(this._x, this._y, this._z);
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {},
      }),
      Object.assign(I.prototype, {
        set: function (t) {
          this.mask = (1 << t) | 0;
        },
        enable: function (t) {
          this.mask |= (1 << t) | 0;
        },
        enableAll: function () {
          this.mask = -1;
        },
        toggle: function (t) {
          this.mask ^= (1 << t) | 0;
        },
        disable: function (t) {
          this.mask &= ~((1 << t) | 0);
        },
        disableAll: function () {
          this.mask = 0;
        },
        test: function (t) {
          return 0 != (this.mask & t.mask);
        },
      });
    let D = 0;
    const N = new w(),
      k = new y(),
      U = new R(),
      z = new w(),
      B = new w(),
      F = new w(),
      H = new y(),
      G = new w(1, 0, 0),
      j = new w(0, 1, 0),
      V = new w(0, 0, 1),
      W = { type: "added" },
      q = { type: "removed" };
    function X() {
      Object.defineProperty(this, "id", { value: D++ }),
        (this.uuid = c.generateUUID()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = X.DefaultUp.clone());
      const t = new w(),
        e = new O(),
        n = new y(),
        i = new w(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new R() },
          normalMatrix: { value: new u() },
        }),
        (this.matrix = new R()),
        (this.matrixWorld = new R()),
        (this.matrixAutoUpdate = X.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new I()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.userData = {});
    }
    function Y() {
      X.call(this),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    (X.DefaultUp = new w(0, 1, 0)),
      (X.DefaultMatrixAutoUpdate = !0),
      (X.prototype = Object.assign(Object.create(s.prototype), {
        constructor: X,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix4: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (t) {
          return this.quaternion.premultiply(t), this;
        },
        setRotationFromAxisAngle: function (t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        },
        setRotationFromEuler: function (t) {
          this.quaternion.setFromEuler(t, !0);
        },
        setRotationFromMatrix: function (t) {
          this.quaternion.setFromRotationMatrix(t);
        },
        setRotationFromQuaternion: function (t) {
          this.quaternion.copy(t);
        },
        rotateOnAxis: function (t, e) {
          return k.setFromAxisAngle(t, e), this.quaternion.multiply(k), this;
        },
        rotateOnWorldAxis: function (t, e) {
          return k.setFromAxisAngle(t, e), this.quaternion.premultiply(k), this;
        },
        rotateX: function (t) {
          return this.rotateOnAxis(G, t);
        },
        rotateY: function (t) {
          return this.rotateOnAxis(j, t);
        },
        rotateZ: function (t) {
          return this.rotateOnAxis(V, t);
        },
        translateOnAxis: function (t, e) {
          return (
            N.copy(t).applyQuaternion(this.quaternion),
            this.position.add(N.multiplyScalar(e)),
            this
          );
        },
        translateX: function (t) {
          return this.translateOnAxis(G, t);
        },
        translateY: function (t) {
          return this.translateOnAxis(j, t);
        },
        translateZ: function (t) {
          return this.translateOnAxis(V, t);
        },
        localToWorld: function (t) {
          return t.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function (t) {
          return t.applyMatrix4(U.getInverse(this.matrixWorld));
        },
        lookAt: function (t, e, n) {
          t.isVector3 ? z.copy(t) : z.set(t, e, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            B.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? U.lookAt(B, z, this.up)
              : U.lookAt(z, B, this.up),
            this.quaternion.setFromRotationMatrix(U),
            i &&
              (U.extractRotation(i.matrixWorld),
              k.setFromRotationMatrix(U),
              this.quaternion.premultiply(k.inverse()));
        },
        add: function (t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(W))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        },
        remove: function (t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(q)),
            this
          );
        },
        attach: function (t) {
          return (
            this.updateWorldMatrix(!0, !1),
            U.getInverse(this.matrixWorld),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              U.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(U),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
          );
        },
        getObjectById: function (t) {
          return this.getObjectByProperty("id", t);
        },
        getObjectByName: function (t) {
          return this.getObjectByProperty("name", t);
        },
        getObjectByProperty: function (t, e) {
          if (this[t] === e) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== i) return i;
          }
        },
        getWorldPosition: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (t = new w())),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        },
        getWorldQuaternion: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (t = new y())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(B, t, F),
            t
          );
        },
        getWorldScale: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (t = new w())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(B, H, t),
            t
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (t = new w())),
            this.updateMatrixWorld(!0);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        },
        raycast: function () {},
        traverse: function (t) {
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
        },
        traverseVisible: function (t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
        },
        traverseAncestors: function (t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        },
        updateMatrixWorld: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
        },
        updateWorldMatrix: function (t, e) {
          const n = this.parent;
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, n = t.length; e < n; e++)
              t[e].updateWorldMatrix(!1, !0);
          }
        },
        toJSON: function (t) {
          const e = void 0 === t || "string" == typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON())),
            this.isMesh || this.isLine || this.isPoints)
          ) {
            i.geometry = r(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const n = e.shapes;
              if (Array.isArray(n))
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  r(t.shapes, i);
                }
              else r(t.shapes, n);
            }
          }
          if (void 0 !== this.material)
            if (Array.isArray(this.material)) {
              const e = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                e.push(r(t.materials, this.material[n]));
              i.material = e;
            } else i.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let e = 0; e < this.children.length; e++)
              i.children.push(this.children[e].toJSON(t).object);
          }
          if (e) {
            const e = o(t.geometries),
              i = o(t.materials),
              r = o(t.textures),
              s = o(t.images),
              a = o(t.shapes);
            e.length > 0 && (n.geometries = e),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              s.length > 0 && (n.images = s),
              a.length > 0 && (n.shapes = a);
          }
          return (n.object = i), n;
          function o(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
        },
        clone: function (t) {
          return new this.constructor().copy(this, t);
        },
        copy: function (t, e) {
          if (
            (void 0 === e && (e = !0),
            (this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const n = t.children[e];
              this.add(n.clone());
            }
          return this;
        },
      })),
      (Y.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Y,
        isScene: !0,
        copy: function (t, e) {
          return (
            X.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        },
        toJSON: function (t) {
          const e = X.prototype.toJSON.call(this, t);
          return (
            null !== this.background &&
              (e.object.background = this.background.toJSON(t)),
            null !== this.environment &&
              (e.object.environment = this.environment.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      }));
    const Z = [
        new w(),
        new w(),
        new w(),
        new w(),
        new w(),
        new w(),
        new w(),
        new w(),
      ],
      J = new w(),
      K = new ct(),
      $ = new w(),
      Q = new w(),
      tt = new w(),
      et = new w(),
      nt = new w(),
      it = new w(),
      rt = new w(),
      ot = new w(),
      st = new w(),
      at = new w();
    function ct(t, e) {
      (this.min = void 0 !== t ? t : new w(1 / 0, 1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new w(-1 / 0, -1 / 0, -1 / 0));
    }
    function lt(t, e, n, i, r) {
      for (let o = 0, s = t.length - 3; o <= s; o += 3) {
        at.fromArray(t, o);
        const s =
            r.x * Math.abs(at.x) + r.y * Math.abs(at.y) + r.z * Math.abs(at.z),
          a = e.dot(at),
          c = n.dot(at),
          l = i.dot(at);
        if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1;
      }
      return !0;
    }
    Object.assign(ct.prototype, {
      isBox3: !0,
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromArray: function (t) {
        let e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          o = -1 / 0,
          s = -1 / 0;
        for (let a = 0, c = t.length; a < c; a += 3) {
          const c = t[a],
            l = t[a + 1],
            u = t[a + 2];
          c < e && (e = c),
            l < n && (n = l),
            u < i && (i = u),
            c > r && (r = c),
            l > o && (o = l),
            u > s && (s = u);
        }
        return this.min.set(e, n, i), this.max.set(r, o, s), this;
      },
      setFromBufferAttribute: function (t) {
        let e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          o = -1 / 0,
          s = -1 / 0;
        for (let a = 0, c = t.count; a < c; a++) {
          const c = t.getX(a),
            l = t.getY(a),
            u = t.getZ(a);
          c < e && (e = c),
            l < n && (n = l),
            u < i && (i = u),
            c > r && (r = c),
            l > o && (o = l),
            u > s && (s = u);
        }
        return this.min.set(e, n, i), this.max.set(r, o, s), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        const n = J.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      setFromObject: function (t) {
        return this.makeEmpty(), this.expandByObject(t);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (t = new w())),
          this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (t = new w())),
          this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      expandByObject: function (t) {
        t.updateWorldMatrix(!1, !1);
        const e = t.geometry;
        void 0 !== e &&
          (null === e.boundingBox && e.computeBoundingBox(),
          K.copy(e.boundingBox),
          K.applyMatrix4(t.matrixWorld),
          this.union(K));
        const n = t.children;
        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
        return this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (e = new w())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      },
      intersectsSphere: function (t) {
        return (
          this.clampPoint(t.center, J),
          J.distanceToSquared(t.center) <= t.radius * t.radius
        );
      },
      intersectsPlane: function (t) {
        let e, n;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
          e <= -t.constant && n >= -t.constant
        );
      },
      intersectsTriangle: function (t) {
        if (this.isEmpty()) return !1;
        this.getCenter(rt),
          ot.subVectors(this.max, rt),
          $.subVectors(t.a, rt),
          Q.subVectors(t.b, rt),
          tt.subVectors(t.c, rt),
          et.subVectors(Q, $),
          nt.subVectors(tt, Q),
          it.subVectors($, tt);
        let e = [
          0,
          -et.z,
          et.y,
          0,
          -nt.z,
          nt.y,
          0,
          -it.z,
          it.y,
          et.z,
          0,
          -et.x,
          nt.z,
          0,
          -nt.x,
          it.z,
          0,
          -it.x,
          -et.y,
          et.x,
          0,
          -nt.y,
          nt.x,
          0,
          -it.y,
          it.x,
          0,
        ];
        return (
          !!lt(e, $, Q, tt, ot) &&
          ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!lt(e, $, Q, tt, ot) &&
            (st.crossVectors(et, nt),
            (e = [st.x, st.y, st.z]),
            lt(e, $, Q, tt, ot)))
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (e = new w())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return J.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      getBoundingSphere: function (t) {
        return (
          void 0 === t &&
            console.error(
              "THREE.Box3: .getBoundingSphere() target is now required"
            ),
          this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(J).length()),
          t
        );
      },
      intersect: function (t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      applyMatrix4: function (t) {
        return (
          this.isEmpty() ||
            (Z[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            Z[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            Z[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            Z[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            Z[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            Z[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            Z[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            Z[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(Z)),
          this
        );
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    });
    const ut = new ct();
    function ht(t, e) {
      (this.center = void 0 !== t ? t : new w()),
        (this.radius = void 0 !== e ? e : -1);
    }
    Object.assign(ht.prototype, {
      set: function (t, e) {
        return this.center.copy(t), (this.radius = e), this;
      },
      setFromPoints: function (t, e) {
        const n = this.center;
        void 0 !== e ? n.copy(e) : ut.setFromPoints(t).getCenter(n);
        let i = 0;
        for (let e = 0, r = t.length; e < r; e++)
          i = Math.max(i, n.distanceToSquared(t[e]));
        return (this.radius = Math.sqrt(i)), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      },
      isEmpty: function () {
        return this.radius < 0;
      },
      makeEmpty: function () {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      },
      containsPoint: function (t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (t) {
        return t.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      },
      intersectsBox: function (t) {
        return t.intersectsSphere(this);
      },
      intersectsPlane: function (t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (t, e) {
        const n = this.center.distanceToSquared(t);
        return (
          void 0 === e &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (e = new w())),
          e.copy(t),
          n > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      },
      getBoundingBox: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required"
            ),
            (t = new ct())),
          this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t)
        );
      },
      applyMatrix4: function (t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      },
      translate: function (t) {
        return this.center.add(t), this;
      },
      equals: function (t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      },
    });
    const pt = new w(),
      dt = new w(),
      ft = new w(),
      mt = new w(),
      gt = new w(),
      vt = new w(),
      yt = new w();
    function xt(t, e) {
      (this.origin = void 0 !== t ? t : new w()),
        (this.direction = void 0 !== e ? e : new w(0, 0, -1));
    }
    Object.assign(xt.prototype, {
      set: function (t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          this.origin.copy(t.origin), this.direction.copy(t.direction), this
        );
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Ray: .at() target is now required"),
            (e = new w())),
          e.copy(this.direction).multiplyScalar(t).add(this.origin)
        );
      },
      lookAt: function (t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      },
      recast: function (t) {
        return this.origin.copy(this.at(t, pt)), this;
      },
      closestPointToPoint: function (t, e) {
        void 0 === e &&
          (console.warn(
            "THREE.Ray: .closestPointToPoint() target is now required"
          ),
          (e = new w())),
          e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0
          ? e.copy(this.origin)
          : e.copy(this.direction).multiplyScalar(n).add(this.origin);
      },
      distanceToPoint: function (t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      },
      distanceSqToPoint: function (t) {
        const e = pt.subVectors(t, this.origin).dot(this.direction);
        return e < 0
          ? this.origin.distanceToSquared(t)
          : (pt.copy(this.direction).multiplyScalar(e).add(this.origin),
            pt.distanceToSquared(t));
      },
      distanceSqToSegment: function (t, e, n, i) {
        dt.copy(t).add(e).multiplyScalar(0.5),
          ft.copy(e).sub(t).normalize(),
          mt.copy(this.origin).sub(dt);
        const r = 0.5 * t.distanceTo(e),
          o = -this.direction.dot(ft),
          s = mt.dot(this.direction),
          a = -mt.dot(ft),
          c = mt.lengthSq(),
          l = Math.abs(1 - o * o);
        let u, h, p, d;
        if (l > 0)
          if (((u = o * a - s), (h = o * s - a), (d = r * l), u >= 0))
            if (h >= -d)
              if (h <= d) {
                const t = 1 / l;
                (u *= t),
                  (h *= t),
                  (p = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + c);
              } else
                (h = r),
                  (u = Math.max(0, -(o * h + s))),
                  (p = -u * u + h * (h + 2 * a) + c);
            else
              (h = -r),
                (u = Math.max(0, -(o * h + s))),
                (p = -u * u + h * (h + 2 * a) + c);
          else
            h <= -d
              ? ((u = Math.max(0, -(-o * r + s))),
                (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                (p = -u * u + h * (h + 2 * a) + c))
              : h <= d
              ? ((u = 0),
                (h = Math.min(Math.max(-r, -a), r)),
                (p = h * (h + 2 * a) + c))
              : ((u = Math.max(0, -(o * r + s))),
                (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                (p = -u * u + h * (h + 2 * a) + c));
        else
          (h = o > 0 ? -r : r),
            (u = Math.max(0, -(o * h + s))),
            (p = -u * u + h * (h + 2 * a) + c);
        return (
          n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
          i && i.copy(ft).multiplyScalar(h).add(dt),
          p
        );
      },
      intersectSphere: function (t, e) {
        pt.subVectors(t.center, this.origin);
        const n = pt.dot(this.direction),
          i = pt.dot(pt) - n * n,
          r = t.radius * t.radius;
        if (i > r) return null;
        const o = Math.sqrt(r - i),
          s = n - o,
          a = n + o;
        return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
      },
      intersectsSphere: function (t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      },
      distanceToPlane: function (t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null;
      },
      intersectPlane: function (t, e) {
        const n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e);
      },
      intersectsPlane: function (t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return !0;
        return t.normal.dot(this.direction) * e < 0;
      },
      intersectBox: function (t, e) {
        let n, i, r, o, s, a;
        const c = 1 / this.direction.x,
          l = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;
        return (
          c >= 0
            ? ((n = (t.min.x - h.x) * c), (i = (t.max.x - h.x) * c))
            : ((n = (t.max.x - h.x) * c), (i = (t.min.x - h.x) * c)),
          l >= 0
            ? ((r = (t.min.y - h.y) * l), (o = (t.max.y - h.y) * l))
            : ((r = (t.max.y - h.y) * l), (o = (t.min.y - h.y) * l)),
          n > o || r > i
            ? null
            : ((r > n || n != n) && (n = r),
              (o < i || i != i) && (i = o),
              u >= 0
                ? ((s = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                : ((s = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
              n > a || s > i
                ? null
                : ((s > n || n != n) && (n = s),
                  (a < i || i != i) && (i = a),
                  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        );
      },
      intersectsBox: function (t) {
        return null !== this.intersectBox(t, pt);
      },
      intersectTriangle: function (t, e, n, i, r) {
        gt.subVectors(e, t), vt.subVectors(n, t), yt.crossVectors(gt, vt);
        let o,
          s = this.direction.dot(yt);
        if (s > 0) {
          if (i) return null;
          o = 1;
        } else {
          if (!(s < 0)) return null;
          (o = -1), (s = -s);
        }
        mt.subVectors(this.origin, t);
        const a = o * this.direction.dot(vt.crossVectors(mt, vt));
        if (a < 0) return null;
        const c = o * this.direction.dot(gt.cross(mt));
        if (c < 0) return null;
        if (a + c > s) return null;
        const l = -o * mt.dot(yt);
        return l < 0 ? null : this.at(l / s, r);
      },
      applyMatrix4: function (t) {
        return (
          this.origin.applyMatrix4(t),
          this.direction.transformDirection(t),
          this
        );
      },
      equals: function (t) {
        return (
          t.origin.equals(this.origin) && t.direction.equals(this.direction)
        );
      },
    });
    const bt = new w(),
      wt = new w(),
      _t = new u();
    function Mt(t, e) {
      (this.normal = void 0 !== t ? t : new w(1, 0, 0)),
        (this.constant = void 0 !== e ? e : 0);
    }
    Object.assign(Mt.prototype, {
      isPlane: !0,
      set: function (t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      },
      setComponents: function (t, e, n, i) {
        return this.normal.set(t, e, n), (this.constant = i), this;
      },
      setFromNormalAndCoplanarPoint: function (t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      },
      setFromCoplanarPoints: function (t, e, n) {
        const i = bt.subVectors(n, e).cross(wt.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      },
      normalize: function () {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      },
      negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
      },
      distanceToPoint: function (t) {
        return this.normal.dot(t) + this.constant;
      },
      distanceToSphere: function (t) {
        return this.distanceToPoint(t.center) - t.radius;
      },
      projectPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required"
            ),
            (e = new w())),
          e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        );
      },
      intersectLine: function (t, e) {
        void 0 === e &&
          (console.warn("THREE.Plane: .intersectLine() target is now required"),
          (e = new w()));
        const n = t.delta(bt),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
        const r = -(t.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1
          ? void 0
          : e.copy(n).multiplyScalar(r).add(t.start);
      },
      intersectsLine: function (t) {
        const e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return (e < 0 && n > 0) || (n < 0 && e > 0);
      },
      intersectsBox: function (t) {
        return t.intersectsPlane(this);
      },
      intersectsSphere: function (t) {
        return t.intersectsPlane(this);
      },
      coplanarPoint: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required"
            ),
            (t = new w())),
          t.copy(this.normal).multiplyScalar(-this.constant)
        );
      },
      applyMatrix4: function (t, e) {
        const n = e || _t.getNormalMatrix(t),
          i = this.coplanarPoint(bt).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      },
      translate: function (t) {
        return (this.constant -= t.dot(this.normal)), this;
      },
      equals: function (t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      },
    });
    const St = new w(),
      Tt = new w(),
      Et = new w(),
      At = new w(),
      Lt = new w(),
      Rt = new w(),
      Pt = new w(),
      Ct = new w(),
      Ot = new w(),
      It = new w();
    function Dt(t, e, n) {
      (this.a = void 0 !== t ? t : new w()),
        (this.b = void 0 !== e ? e : new w()),
        (this.c = void 0 !== n ? n : new w());
    }
    Object.assign(Dt, {
      getNormal: function (t, e, n, i) {
        void 0 === i &&
          (console.warn("THREE.Triangle: .getNormal() target is now required"),
          (i = new w())),
          i.subVectors(n, e),
          St.subVectors(t, e),
          i.cross(St);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      },
      getBarycoord: function (t, e, n, i, r) {
        St.subVectors(i, e), Tt.subVectors(n, e), Et.subVectors(t, e);
        const o = St.dot(St),
          s = St.dot(Tt),
          a = St.dot(Et),
          c = Tt.dot(Tt),
          l = Tt.dot(Et),
          u = o * c - s * s;
        if (
          (void 0 === r &&
            (console.warn(
              "THREE.Triangle: .getBarycoord() target is now required"
            ),
            (r = new w())),
          0 === u)
        )
          return r.set(-2, -1, -1);
        const h = 1 / u,
          p = (c * a - s * l) * h,
          d = (o * l - s * a) * h;
        return r.set(1 - p - d, d, p);
      },
      containsPoint: function (t, e, n, i) {
        return (
          Dt.getBarycoord(t, e, n, i, At),
          At.x >= 0 && At.y >= 0 && At.x + At.y <= 1
        );
      },
      getUV: function (t, e, n, i, r, o, s, a) {
        return (
          this.getBarycoord(t, e, n, i, At),
          a.set(0, 0),
          a.addScaledVector(r, At.x),
          a.addScaledVector(o, At.y),
          a.addScaledVector(s, At.z),
          a
        );
      },
      isFrontFacing: function (t, e, n, i) {
        return (
          St.subVectors(n, e), Tt.subVectors(t, e), St.cross(Tt).dot(i) < 0
        );
      },
    }),
      Object.assign(Dt.prototype, {
        set: function (t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        },
        setFromPointsAndIndices: function (t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        },
        getArea: function () {
          return (
            St.subVectors(this.c, this.b),
            Tt.subVectors(this.a, this.b),
            0.5 * St.cross(Tt).length()
          );
        },
        getMidpoint: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (t = new w())),
            t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        },
        getNormal: function (t) {
          return Dt.getNormal(this.a, this.b, this.c, t);
        },
        getPlane: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (t = new Mt())),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        },
        getBarycoord: function (t, e) {
          return Dt.getBarycoord(t, this.a, this.b, this.c, e);
        },
        getUV: function (t, e, n, i, r) {
          return Dt.getUV(t, this.a, this.b, this.c, e, n, i, r);
        },
        containsPoint: function (t) {
          return Dt.containsPoint(t, this.a, this.b, this.c);
        },
        isFrontFacing: function (t) {
          return Dt.isFrontFacing(this.a, this.b, this.c, t);
        },
        intersectsBox: function (t) {
          return t.intersectsTriangle(this);
        },
        closestPointToPoint: function (t, e) {
          void 0 === e &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (e = new w()));
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, s;
          Lt.subVectors(i, n), Rt.subVectors(r, n), Ct.subVectors(t, n);
          const a = Lt.dot(Ct),
            c = Rt.dot(Ct);
          if (a <= 0 && c <= 0) return e.copy(n);
          Ot.subVectors(t, i);
          const l = Lt.dot(Ot),
            u = Rt.dot(Ot);
          if (l >= 0 && u <= l) return e.copy(i);
          const h = a * u - l * c;
          if (h <= 0 && a >= 0 && l <= 0)
            return (o = a / (a - l)), e.copy(n).addScaledVector(Lt, o);
          It.subVectors(t, r);
          const p = Lt.dot(It),
            d = Rt.dot(It);
          if (d >= 0 && p <= d) return e.copy(r);
          const f = p * c - a * d;
          if (f <= 0 && c >= 0 && d <= 0)
            return (s = c / (c - d)), e.copy(n).addScaledVector(Rt, s);
          const m = l * d - p * u;
          if (m <= 0 && u - l >= 0 && p - d >= 0)
            return (
              Pt.subVectors(r, i),
              (s = (u - l) / (u - l + (p - d))),
              e.copy(i).addScaledVector(Pt, s)
            );
          const g = 1 / (m + f + h);
          return (
            (o = f * g),
            (s = h * g),
            e.copy(n).addScaledVector(Lt, o).addScaledVector(Rt, s)
          );
        },
        equals: function (t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        },
      });
    const Nt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      kt = { h: 0, s: 0, l: 0 },
      Ut = { h: 0, s: 0, l: 0 };
    function zt(t, e, n) {
      return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
    }
    function Bt(t, e, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? t + 6 * (e - t) * n
          : n < 0.5
          ? e
          : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
      );
    }
    function Ft(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function Ht(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    function Gt(t, e, n, i, r, o) {
      (this.a = t),
        (this.b = e),
        (this.c = n),
        (this.normal = i && i.isVector3 ? i : new w()),
        (this.vertexNormals = Array.isArray(i) ? i : []),
        (this.color = r && r.isColor ? r : new zt()),
        (this.vertexColors = Array.isArray(r) ? r : []),
        (this.materialIndex = void 0 !== o ? o : 0);
    }
    Object.assign(zt.prototype, {
      isColor: !0,
      r: 1,
      g: 1,
      b: 1,
      set: function (t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      },
      setScalar: function (t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      },
      setHex: function (t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      },
      setRGB: function (t, e, n) {
        return (this.r = t), (this.g = e), (this.b = n), this;
      },
      setHSL: function (t, e, n) {
        if (
          ((t = c.euclideanModulo(t, 1)),
          (e = c.clamp(e, 0, 1)),
          (n = c.clamp(n, 0, 1)),
          0 === e)
        )
          this.r = this.g = this.b = n;
        else {
          const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
            r = 2 * n - i;
          (this.r = Bt(r, i, t + 1 / 3)),
            (this.g = Bt(r, i, t)),
            (this.b = Bt(r, i, t - 1 / 3));
        }
        return this;
      },
      setStyle: function (t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
          let t;
          const i = n[1],
            r = n[2];
          switch (i) {
            case "rgb":
            case "rgba":
              if (
                (t =
                  /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                  e(t[5]),
                  this
                );
              if (
                (t =
                  /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                  e(t[5]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (t =
                  /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    r
                  ))
              ) {
                const n = parseFloat(t[1]) / 360,
                  i = parseInt(t[2], 10) / 100,
                  r = parseInt(t[3], 10) / 100;
                return e(t[5]), this.setHSL(n, i, r);
              }
          }
        } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
          const t = n[1],
            e = t.length;
          if (3 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
              (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
              (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
              this
            );
          if (6 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
              (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
              (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
              this
            );
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      },
      setColorName: function (t) {
        const e = Nt[t];
        return (
          void 0 !== e
            ? this.setHex(e)
            : console.warn("THREE.Color: Unknown color " + t),
          this
        );
      },
      clone: function () {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function (t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      },
      copyGammaToLinear: function (t, e) {
        return (
          void 0 === e && (e = 2),
          (this.r = Math.pow(t.r, e)),
          (this.g = Math.pow(t.g, e)),
          (this.b = Math.pow(t.b, e)),
          this
        );
      },
      copyLinearToGamma: function (t, e) {
        void 0 === e && (e = 2);
        const n = e > 0 ? 1 / e : 1;
        return (
          (this.r = Math.pow(t.r, n)),
          (this.g = Math.pow(t.g, n)),
          (this.b = Math.pow(t.b, n)),
          this
        );
      },
      convertGammaToLinear: function (t) {
        return this.copyGammaToLinear(this, t), this;
      },
      convertLinearToGamma: function (t) {
        return this.copyLinearToGamma(this, t), this;
      },
      copySRGBToLinear: function (t) {
        return (this.r = Ft(t.r)), (this.g = Ft(t.g)), (this.b = Ft(t.b)), this;
      },
      copyLinearToSRGB: function (t) {
        return (this.r = Ht(t.r)), (this.g = Ht(t.g)), (this.b = Ht(t.b)), this;
      },
      convertSRGBToLinear: function () {
        return this.copySRGBToLinear(this), this;
      },
      convertLinearToSRGB: function () {
        return this.copyLinearToSRGB(this), this;
      },
      getHex: function () {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      },
      getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function (t) {
        void 0 === t &&
          (console.warn("THREE.Color: .getHSL() target is now required"),
          (t = { h: 0, s: 0, l: 0 }));
        const e = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(e, n, i),
          o = Math.min(e, n, i);
        let s, a;
        const c = (o + r) / 2;
        if (o === r) (s = 0), (a = 0);
        else {
          const t = r - o;
          switch (((a = c <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
            case e:
              s = (n - i) / t + (n < i ? 6 : 0);
              break;
            case n:
              s = (i - e) / t + 2;
              break;
            case i:
              s = (e - n) / t + 4;
          }
          s /= 6;
        }
        return (t.h = s), (t.s = a), (t.l = c), t;
      },
      getStyle: function () {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      },
      offsetHSL: function (t, e, n) {
        return (
          this.getHSL(kt),
          (kt.h += t),
          (kt.s += e),
          (kt.l += n),
          this.setHSL(kt.h, kt.s, kt.l),
          this
        );
      },
      add: function (t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      },
      addColors: function (t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      },
      addScalar: function (t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      },
      sub: function (t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      },
      multiply: function (t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      },
      multiplyScalar: function (t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      },
      lerp: function (t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      },
      lerpHSL: function (t, e) {
        this.getHSL(kt), t.getHSL(Ut);
        const n = c.lerp(kt.h, Ut.h, e),
          i = c.lerp(kt.s, Ut.s, e),
          r = c.lerp(kt.l, Ut.l, e);
        return this.setHSL(n, i, r), this;
      },
      equals: function (t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.r = t[e]),
          (this.g = t[e + 1]),
          (this.b = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.r),
          (t[e + 1] = this.g),
          (t[e + 2] = this.b),
          t
        );
      },
      fromBufferAttribute: function (t, e) {
        return (
          (this.r = t.getX(e)),
          (this.g = t.getY(e)),
          (this.b = t.getZ(e)),
          !0 === t.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      },
      toJSON: function () {
        return this.getHex();
      },
    }),
      (zt.NAMES = Nt),
      Object.assign(Gt.prototype, {
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            (this.materialIndex = t.materialIndex);
          for (let e = 0, n = t.vertexNormals.length; e < n; e++)
            this.vertexNormals[e] = t.vertexNormals[e].clone();
          for (let e = 0, n = t.vertexColors.length; e < n; e++)
            this.vertexColors[e] = t.vertexColors[e].clone();
          return this;
        },
      });
    let jt = 0;
    function Vt() {
      Object.defineProperty(this, "id", { value: jt++ }),
        (this.uuid = c.generateUUID()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = 1),
        (this.side = 0),
        (this.flatShading = !1),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = 100),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = 7680),
        (this.stencilZFail = 7680),
        (this.stencilZPass = 7680),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0);
    }
    function Wt(t) {
      Vt.call(this),
        (this.type = "MeshBasicMaterial"),
        (this.color = new zt(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (Vt.prototype = Object.assign(Object.create(s.prototype), {
      constructor: Vt,
      isMaterial: !0,
      onBeforeCompile: function () {},
      customProgramCacheKey: function () {
        return this.onBeforeCompile.toString();
      },
      setValues: function (t) {
        if (void 0 !== t)
          for (const e in t) {
            const n = t[e];
            if (void 0 === n) {
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined."
              );
              continue;
            }
            if ("shading" === e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = 1 === n);
              continue;
            }
            const i = this[e];
            void 0 !== i
              ? i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[e] = n)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    e +
                    "' is not a property of this material."
                );
          }
      },
      toJSON: function (t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = { textures: {}, images: {} });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function i(t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(t).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            (n.lightMap = this.lightMap.toJSON(t).uuid),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(t).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(t).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(t).uuid),
            (n.reflectivity = this.reflectivity),
            (n.refractionRatio = this.refractionRatio),
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity)),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.size && (n.size = this.size),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (n.blending = this.blending),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          0 !== this.side && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (n.morphTargets = !0),
          !0 === this.morphNormals && (n.morphNormals = !0),
          !0 === this.skinning && (n.skinning = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          e)
        ) {
          const e = i(t.textures),
            r = i(t.images);
          e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
        }
        return n;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.flatShading = t.flatShading),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.stencilWrite = t.stencilWrite);
        const e = t.clippingPlanes;
        let n = null;
        if (null !== e) {
          const t = e.length;
          n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = t.clipIntersection),
          (this.clipShadows = t.clipShadows),
          (this.shadowSide = t.shadowSide),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
      Object.defineProperty(Vt.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      (Wt.prototype = Object.create(Vt.prototype)),
      (Wt.prototype.constructor = Wt),
      (Wt.prototype.isMeshBasicMaterial = !0),
      (Wt.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    const qt = new w(),
      Xt = new l();
    function Yt(t, e, n) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === n),
        (this.usage = 35044),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    function Zt(t, e, n) {
      Yt.call(this, new Int8Array(t), e, n);
    }
    function Jt(t, e, n) {
      Yt.call(this, new Uint8Array(t), e, n);
    }
    function Kt(t, e, n) {
      Yt.call(this, new Uint8ClampedArray(t), e, n);
    }
    function $t(t, e, n) {
      Yt.call(this, new Int16Array(t), e, n);
    }
    function Qt(t, e, n) {
      Yt.call(this, new Uint16Array(t), e, n);
    }
    function te(t, e, n) {
      Yt.call(this, new Int32Array(t), e, n);
    }
    function ee(t, e, n) {
      Yt.call(this, new Uint32Array(t), e, n);
    }
    function ne(t, e, n) {
      Yt.call(this, new Float32Array(t), e, n);
    }
    function ie(t, e, n) {
      Yt.call(this, new Float64Array(t), e, n);
    }
    function re() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function oe(t) {
      if (0 === t.length) return -1 / 0;
      let e = t[0];
      for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
      return e;
    }
    Object.defineProperty(Yt.prototype, "needsUpdate", {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
      Object.assign(Yt.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
          return (this.usage = t), this;
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        copyArray: function (t) {
          return this.array.set(t), this;
        },
        copyColorsArray: function (t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (r = new zt())),
              (e[n++] = r.r),
              (e[n++] = r.g),
              (e[n++] = r.b);
          }
          return this;
        },
        copyVector2sArray: function (t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (r = new l())),
              (e[n++] = r.x),
              (e[n++] = r.y);
          }
          return this;
        },
        copyVector3sArray: function (t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (r = new w())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z);
          }
          return this;
        },
        copyVector4sArray: function (t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (r = new m())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z),
              (e[n++] = r.w);
          }
          return this;
        },
        applyMatrix3: function (t) {
          if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Xt.fromBufferAttribute(this, e),
                Xt.applyMatrix3(t),
                this.setXY(e, Xt.x, Xt.y);
          else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              qt.fromBufferAttribute(this, e),
                qt.applyMatrix3(t),
                this.setXYZ(e, qt.x, qt.y, qt.z);
          return this;
        },
        applyMatrix4: function (t) {
          for (let e = 0, n = this.count; e < n; e++)
            (qt.x = this.getX(e)),
              (qt.y = this.getY(e)),
              (qt.z = this.getZ(e)),
              qt.applyMatrix4(t),
              this.setXYZ(e, qt.x, qt.y, qt.z);
          return this;
        },
        applyNormalMatrix: function (t) {
          for (let e = 0, n = this.count; e < n; e++)
            (qt.x = this.getX(e)),
              (qt.y = this.getY(e)),
              (qt.z = this.getZ(e)),
              qt.applyNormalMatrix(t),
              this.setXYZ(e, qt.x, qt.y, qt.z);
          return this;
        },
        transformDirection: function (t) {
          for (let e = 0, n = this.count; e < n; e++)
            (qt.x = this.getX(e)),
              (qt.y = this.getY(e)),
              (qt.z = this.getZ(e)),
              qt.transformDirection(t),
              this.setXYZ(e, qt.x, qt.y, qt.z);
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        getX: function (t) {
          return this.array[t * this.itemSize];
        },
        setX: function (t, e) {
          return (this.array[t * this.itemSize] = e), this;
        },
        getY: function (t) {
          return this.array[t * this.itemSize + 1];
        },
        setY: function (t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        },
        getZ: function (t) {
          return this.array[t * this.itemSize + 2];
        },
        setZ: function (t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        },
        getW: function (t) {
          return this.array[t * this.itemSize + 3];
        },
        setW: function (t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        },
        setXY: function (t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        clone: function () {
          return new this.constructor(this.array, this.itemSize).copy(this);
        },
        toJSON: function () {
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
        },
      }),
      (Zt.prototype = Object.create(Yt.prototype)),
      (Zt.prototype.constructor = Zt),
      (Jt.prototype = Object.create(Yt.prototype)),
      (Jt.prototype.constructor = Jt),
      (Kt.prototype = Object.create(Yt.prototype)),
      (Kt.prototype.constructor = Kt),
      ($t.prototype = Object.create(Yt.prototype)),
      ($t.prototype.constructor = $t),
      (Qt.prototype = Object.create(Yt.prototype)),
      (Qt.prototype.constructor = Qt),
      (te.prototype = Object.create(Yt.prototype)),
      (te.prototype.constructor = te),
      (ee.prototype = Object.create(Yt.prototype)),
      (ee.prototype.constructor = ee),
      (ne.prototype = Object.create(Yt.prototype)),
      (ne.prototype.constructor = ne),
      (ie.prototype = Object.create(Yt.prototype)),
      (ie.prototype.constructor = ie),
      Object.assign(re.prototype, {
        computeGroups: function (t) {
          const e = [];
          let n,
            i,
            r = void 0;
          const o = t.faces;
          for (i = 0; i < o.length; i++) {
            const t = o[i];
            t.materialIndex !== r &&
              ((r = t.materialIndex),
              void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
              (n = { start: 3 * i, materialIndex: r }));
          }
          void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
            (this.groups = e);
        },
        fromGeometry: function (t) {
          const e = t.faces,
            n = t.vertices,
            i = t.faceVertexUvs,
            r = i[0] && i[0].length > 0,
            o = i[1] && i[1].length > 0,
            s = t.morphTargets,
            a = s.length;
          let c;
          if (a > 0) {
            c = [];
            for (let t = 0; t < a; t++) c[t] = { name: s[t].name, data: [] };
            this.morphTargets.position = c;
          }
          const u = t.morphNormals,
            h = u.length;
          let p;
          if (h > 0) {
            p = [];
            for (let t = 0; t < h; t++) p[t] = { name: u[t].name, data: [] };
            this.morphTargets.normal = p;
          }
          const d = t.skinIndices,
            f = t.skinWeights,
            m = d.length === n.length,
            g = f.length === n.length;
          n.length > 0 &&
            0 === e.length &&
            console.error(
              "THREE.DirectGeometry: Faceless geometries are not supported."
            );
          for (let t = 0; t < e.length; t++) {
            const v = e[t];
            this.vertices.push(n[v.a], n[v.b], n[v.c]);
            const y = v.vertexNormals;
            if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
            else {
              const t = v.normal;
              this.normals.push(t, t, t);
            }
            const x = v.vertexColors;
            if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
            else {
              const t = v.color;
              this.colors.push(t, t, t);
            }
            if (!0 === r) {
              const e = i[0][t];
              void 0 !== e
                ? this.uvs.push(e[0], e[1], e[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                    t
                  ),
                  this.uvs.push(new l(), new l(), new l()));
            }
            if (!0 === o) {
              const e = i[1][t];
              void 0 !== e
                ? this.uvs2.push(e[0], e[1], e[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    t
                  ),
                  this.uvs2.push(new l(), new l(), new l()));
            }
            for (let t = 0; t < a; t++) {
              const e = s[t].vertices;
              c[t].data.push(e[v.a], e[v.b], e[v.c]);
            }
            for (let e = 0; e < h; e++) {
              const n = u[e].vertexNormals[t];
              p[e].data.push(n.a, n.b, n.c);
            }
            m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
              g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
          }
          return (
            this.computeGroups(t),
            (this.verticesNeedUpdate = t.verticesNeedUpdate),
            (this.normalsNeedUpdate = t.normalsNeedUpdate),
            (this.colorsNeedUpdate = t.colorsNeedUpdate),
            (this.uvsNeedUpdate = t.uvsNeedUpdate),
            (this.groupsNeedUpdate = t.groupsNeedUpdate),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            this
          );
        },
      });
    let se = 1;
    const ae = new R(),
      ce = new X(),
      le = new w(),
      ue = new ct(),
      he = new ct(),
      pe = new w();
    function de() {
      Object.defineProperty(this, "id", { value: (se += 2) }),
        (this.uuid = c.generateUUID()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    de.prototype = Object.assign(Object.create(s.prototype), {
      constructor: de,
      isBufferGeometry: !0,
      getIndex: function () {
        return this.index;
      },
      setIndex: function (t) {
        Array.isArray(t)
          ? (this.index = new (oe(t) > 65535 ? ee : Qt)(t, 1))
          : (this.index = t);
      },
      getAttribute: function (t) {
        return this.attributes[t];
      },
      setAttribute: function (t, e) {
        return (this.attributes[t] = e), this;
      },
      deleteAttribute: function (t) {
        return delete this.attributes[t], this;
      },
      addGroup: function (t, e, n) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: void 0 !== n ? n : 0,
        });
      },
      clearGroups: function () {
        this.groups = [];
      },
      setDrawRange: function (t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      },
      applyMatrix4: function (t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const e = new u().getNormalMatrix(t);
          n.applyNormalMatrix(e), (n.needsUpdate = !0);
        }
        const i = this.attributes.tangent;
        return (
          void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      },
      rotateX: function (t) {
        return ae.makeRotationX(t), this.applyMatrix4(ae), this;
      },
      rotateY: function (t) {
        return ae.makeRotationY(t), this.applyMatrix4(ae), this;
      },
      rotateZ: function (t) {
        return ae.makeRotationZ(t), this.applyMatrix4(ae), this;
      },
      translate: function (t, e, n) {
        return ae.makeTranslation(t, e, n), this.applyMatrix4(ae), this;
      },
      scale: function (t, e, n) {
        return ae.makeScale(t, e, n), this.applyMatrix4(ae), this;
      },
      lookAt: function (t) {
        return (
          ce.lookAt(t), ce.updateMatrix(), this.applyMatrix4(ce.matrix), this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(le).negate(),
          this.translate(le.x, le.y, le.z),
          this
        );
      },
      setFromObject: function (t) {
        const e = t.geometry;
        if (t.isPoints || t.isLine) {
          const t = new ne(3 * e.vertices.length, 3),
            n = new ne(3 * e.colors.length, 3);
          if (
            (this.setAttribute("position", t.copyVector3sArray(e.vertices)),
            this.setAttribute("color", n.copyColorsArray(e.colors)),
            e.lineDistances && e.lineDistances.length === e.vertices.length)
          ) {
            const t = new ne(e.lineDistances.length, 1);
            this.setAttribute("lineDistance", t.copyArray(e.lineDistances));
          }
          null !== e.boundingSphere &&
            (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone());
        } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
        return this;
      },
      setFromPoints: function (t) {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          e.push(i.x, i.y, i.z || 0);
        }
        return this.setAttribute("position", new ne(e, 3)), this;
      },
      updateFromObject: function (t) {
        let e = t.geometry;
        if (t.isMesh) {
          let t = e.__directGeometry;
          if (
            (!0 === e.elementsNeedUpdate &&
              ((t = void 0), (e.elementsNeedUpdate = !1)),
            void 0 === t)
          )
            return this.fromGeometry(e);
          (t.verticesNeedUpdate = e.verticesNeedUpdate),
            (t.normalsNeedUpdate = e.normalsNeedUpdate),
            (t.colorsNeedUpdate = e.colorsNeedUpdate),
            (t.uvsNeedUpdate = e.uvsNeedUpdate),
            (t.groupsNeedUpdate = e.groupsNeedUpdate),
            (e.verticesNeedUpdate = !1),
            (e.normalsNeedUpdate = !1),
            (e.colorsNeedUpdate = !1),
            (e.uvsNeedUpdate = !1),
            (e.groupsNeedUpdate = !1),
            (e = t);
        }
        if (!0 === e.verticesNeedUpdate) {
          const t = this.attributes.position;
          void 0 !== t &&
            (t.copyVector3sArray(e.vertices), (t.needsUpdate = !0)),
            (e.verticesNeedUpdate = !1);
        }
        if (!0 === e.normalsNeedUpdate) {
          const t = this.attributes.normal;
          void 0 !== t &&
            (t.copyVector3sArray(e.normals), (t.needsUpdate = !0)),
            (e.normalsNeedUpdate = !1);
        }
        if (!0 === e.colorsNeedUpdate) {
          const t = this.attributes.color;
          void 0 !== t && (t.copyColorsArray(e.colors), (t.needsUpdate = !0)),
            (e.colorsNeedUpdate = !1);
        }
        if (e.uvsNeedUpdate) {
          const t = this.attributes.uv;
          void 0 !== t && (t.copyVector2sArray(e.uvs), (t.needsUpdate = !0)),
            (e.uvsNeedUpdate = !1);
        }
        if (e.lineDistancesNeedUpdate) {
          const t = this.attributes.lineDistance;
          void 0 !== t && (t.copyArray(e.lineDistances), (t.needsUpdate = !0)),
            (e.lineDistancesNeedUpdate = !1);
        }
        return (
          e.groupsNeedUpdate &&
            (e.computeGroups(t.geometry),
            (this.groups = e.groups),
            (e.groupsNeedUpdate = !1)),
          this
        );
      },
      fromGeometry: function (t) {
        return (
          (t.__directGeometry = new re().fromGeometry(t)),
          this.fromDirectGeometry(t.__directGeometry)
        );
      },
      fromDirectGeometry: function (t) {
        const e = new Float32Array(3 * t.vertices.length);
        if (
          (this.setAttribute(
            "position",
            new Yt(e, 3).copyVector3sArray(t.vertices)
          ),
          t.normals.length > 0)
        ) {
          const e = new Float32Array(3 * t.normals.length);
          this.setAttribute(
            "normal",
            new Yt(e, 3).copyVector3sArray(t.normals)
          );
        }
        if (t.colors.length > 0) {
          const e = new Float32Array(3 * t.colors.length);
          this.setAttribute("color", new Yt(e, 3).copyColorsArray(t.colors));
        }
        if (t.uvs.length > 0) {
          const e = new Float32Array(2 * t.uvs.length);
          this.setAttribute("uv", new Yt(e, 2).copyVector2sArray(t.uvs));
        }
        if (t.uvs2.length > 0) {
          const e = new Float32Array(2 * t.uvs2.length);
          this.setAttribute("uv2", new Yt(e, 2).copyVector2sArray(t.uvs2));
        }
        this.groups = t.groups;
        for (const e in t.morphTargets) {
          const n = [],
            i = t.morphTargets[e];
          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t],
              r = new ne(3 * e.data.length, 3);
            (r.name = e.name), n.push(r.copyVector3sArray(e.data));
          }
          this.morphAttributes[e] = n;
        }
        if (t.skinIndices.length > 0) {
          const e = new ne(4 * t.skinIndices.length, 4);
          this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices));
        }
        if (t.skinWeights.length > 0) {
          const e = new ne(4 * t.skinWeights.length, 4);
          this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights));
        }
        return (
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new ct());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              ue.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (pe.addVectors(this.boundingBox.min, ue.min),
                    this.boundingBox.expandByPoint(pe),
                    pe.addVectors(this.boundingBox.max, ue.max),
                    this.boundingBox.expandByPoint(pe))
                  : (this.boundingBox.expandByPoint(ue.min),
                    this.boundingBox.expandByPoint(ue.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new ht());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t) {
          const n = this.boundingSphere.center;
          if ((ue.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              he.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (pe.addVectors(ue.min, he.min),
                    ue.expandByPoint(pe),
                    pe.addVectors(ue.max, he.max),
                    ue.expandByPoint(pe))
                  : (ue.expandByPoint(he.min), ue.expandByPoint(he.max));
            }
          ue.getCenter(n);
          let i = 0;
          for (let e = 0, r = t.count; e < r; e++)
            pe.fromBufferAttribute(t, e),
              (i = Math.max(i, n.distanceToSquared(pe)));
          if (e)
            for (let r = 0, o = e.length; r < o; r++) {
              const o = e[r],
                s = this.morphTargetsRelative;
              for (let e = 0, r = o.count; e < r; e++)
                pe.fromBufferAttribute(o, e),
                  s && (le.fromBufferAttribute(t, e), pe.add(le)),
                  (i = Math.max(i, n.distanceToSquared(pe)));
            }
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      },
      computeFaceNormals: function () {},
      computeVertexNormals: function () {
        const t = this.index,
          e = this.getAttribute("position");
        if (void 0 !== e) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new Yt(new Float32Array(3 * e.count), 3)),
              this.setAttribute("normal", n);
          else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
          const i = new w(),
            r = new w(),
            o = new w(),
            s = new w(),
            a = new w(),
            c = new w(),
            l = new w(),
            u = new w();
          if (t)
            for (let h = 0, p = t.count; h < p; h += 3) {
              const p = t.getX(h + 0),
                d = t.getX(h + 1),
                f = t.getX(h + 2);
              i.fromBufferAttribute(e, p),
                r.fromBufferAttribute(e, d),
                o.fromBufferAttribute(e, f),
                l.subVectors(o, r),
                u.subVectors(i, r),
                l.cross(u),
                s.fromBufferAttribute(n, p),
                a.fromBufferAttribute(n, d),
                c.fromBufferAttribute(n, f),
                s.add(l),
                a.add(l),
                c.add(l),
                n.setXYZ(p, s.x, s.y, s.z),
                n.setXYZ(d, a.x, a.y, a.z),
                n.setXYZ(f, c.x, c.y, c.z);
            }
          else
            for (let t = 0, s = e.count; t < s; t += 3)
              i.fromBufferAttribute(e, t + 0),
                r.fromBufferAttribute(e, t + 1),
                o.fromBufferAttribute(e, t + 2),
                l.subVectors(o, r),
                u.subVectors(i, r),
                l.cross(u),
                n.setXYZ(t + 0, l.x, l.y, l.z),
                n.setXYZ(t + 1, l.x, l.y, l.z),
                n.setXYZ(t + 2, l.x, l.y, l.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      },
      merge: function (t, e) {
        if (!t || !t.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            t
          );
        void 0 === e &&
          ((e = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        const n = this.attributes;
        for (const i in n) {
          if (void 0 === t.attributes[i]) continue;
          const r = n[i].array,
            o = t.attributes[i],
            s = o.array,
            a = o.itemSize * e,
            c = Math.min(s.length, r.length - a);
          for (let t = 0, e = a; t < c; t++, e++) r[e] = s[t];
        }
        return this;
      },
      normalizeNormals: function () {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++)
          pe.fromBufferAttribute(t, e),
            pe.normalize(),
            t.setXYZ(e, pe.x, pe.y, pe.z);
      },
      toNonIndexed: function () {
        function t(t, e) {
          const n = t.array,
            i = t.itemSize,
            r = t.normalized,
            o = new n.constructor(e.length * i);
          let s = 0,
            a = 0;
          for (let t = 0, r = e.length; t < r; t++) {
            s = e[t] * i;
            for (let t = 0; t < i; t++) o[a++] = n[s++];
          }
          return new Yt(o, i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
            ),
            this
          );
        const e = new de(),
          n = this.index.array,
          i = this.attributes;
        for (const r in i) {
          const o = t(i[r], n);
          e.setAttribute(r, o);
        }
        const r = this.morphAttributes;
        for (const i in r) {
          const o = [],
            s = r[i];
          for (let e = 0, i = s.length; e < i; e++) {
            const i = t(s[e], n);
            o.push(i);
          }
          e.morphAttributes[i] = o;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let t = 0, n = o.length; t < n; t++) {
          const n = o[t];
          e.addGroup(n.start, n.count, n.materialIndex);
        }
        return e;
      },
      toJSON: function () {
        const t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = { attributes: {} };
        const e = this.index;
        null !== e &&
          (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array),
          });
        const n = this.attributes;
        for (const e in n) {
          const i = n[e],
            r = i.toJSON(t.data);
          "" !== i.name && (r.name = i.name), (t.data.attributes[e] = r);
        }
        const i = {};
        let r = !1;
        for (const e in this.morphAttributes) {
          const n = this.morphAttributes[e],
            o = [];
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e],
              r = i.toJSON(t.data);
            "" !== i.name && (r.name = i.name), o.push(r);
          }
          o.length > 0 && ((i[e] = o), (r = !0));
        }
        r &&
          ((t.data.morphAttributes = i),
          (t.data.morphTargetsRelative = this.morphTargetsRelative));
        const o = this.groups;
        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
        const s = this.boundingSphere;
        return (
          null !== s &&
            (t.data.boundingSphere = {
              center: s.center.toArray(),
              radius: s.radius,
            }),
          t
        );
      },
      clone: function () {
        return new de().copy(this);
      },
      copy: function (t) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const e = {};
        this.name = t.name;
        const n = t.index;
        null !== n && this.setIndex(n.clone(e));
        const i = t.attributes;
        for (const t in i) {
          const n = i[t];
          this.setAttribute(t, n.clone(e));
        }
        const r = t.morphAttributes;
        for (const t in r) {
          const n = [],
            i = r[t];
          for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
          this.morphAttributes[t] = n;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const o = t.groups;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const s = t.boundingBox;
        null !== s && (this.boundingBox = s.clone());
        const a = t.boundingSphere;
        return (
          null !== a && (this.boundingSphere = a.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    });
    const fe = new R(),
      me = new xt(),
      ge = new ht(),
      ve = new w(),
      ye = new w(),
      xe = new w(),
      be = new w(),
      we = new w(),
      _e = new w(),
      Me = new w(),
      Se = new w(),
      Te = new w(),
      Ee = new l(),
      Ae = new l(),
      Le = new l(),
      Re = new w(),
      Pe = new w();
    function Ce(t, e) {
      X.call(this),
        (this.type = "Mesh"),
        (this.geometry = void 0 !== t ? t : new de()),
        (this.material = void 0 !== e ? e : new Wt()),
        this.updateMorphTargets();
    }
    function Oe(t, e, n, i, r, o, s, a) {
      let c;
      if (
        ((c =
          1 === e.side
            ? i.intersectTriangle(s, o, r, !0, a)
            : i.intersectTriangle(r, o, s, 2 !== e.side, a)),
        null === c)
      )
        return null;
      Pe.copy(a), Pe.applyMatrix4(t.matrixWorld);
      const l = n.ray.origin.distanceTo(Pe);
      return l < n.near || l > n.far
        ? null
        : { distance: l, point: Pe.clone(), object: t };
    }
    function Ie(t, e, n, i, r, o, s, a, c, u, h, p) {
      ve.fromBufferAttribute(r, u),
        ye.fromBufferAttribute(r, h),
        xe.fromBufferAttribute(r, p);
      const d = t.morphTargetInfluences;
      if (e.morphTargets && o && d) {
        Me.set(0, 0, 0), Se.set(0, 0, 0), Te.set(0, 0, 0);
        for (let t = 0, e = o.length; t < e; t++) {
          const e = d[t],
            n = o[t];
          0 !== e &&
            (be.fromBufferAttribute(n, u),
            we.fromBufferAttribute(n, h),
            _e.fromBufferAttribute(n, p),
            s
              ? (Me.addScaledVector(be, e),
                Se.addScaledVector(we, e),
                Te.addScaledVector(_e, e))
              : (Me.addScaledVector(be.sub(ve), e),
                Se.addScaledVector(we.sub(ye), e),
                Te.addScaledVector(_e.sub(xe), e)));
        }
        ve.add(Me), ye.add(Se), xe.add(Te);
      }
      t.isSkinnedMesh &&
        (t.boneTransform(u, ve),
        t.boneTransform(h, ye),
        t.boneTransform(p, xe));
      const f = Oe(t, e, n, i, ve, ye, xe, Re);
      if (f) {
        a &&
          (Ee.fromBufferAttribute(a, u),
          Ae.fromBufferAttribute(a, h),
          Le.fromBufferAttribute(a, p),
          (f.uv = Dt.getUV(Re, ve, ye, xe, Ee, Ae, Le, new l()))),
          c &&
            (Ee.fromBufferAttribute(c, u),
            Ae.fromBufferAttribute(c, h),
            Le.fromBufferAttribute(c, p),
            (f.uv2 = Dt.getUV(Re, ve, ye, xe, Ee, Ae, Le, new l())));
        const t = new Gt(u, h, p);
        Dt.getNormal(ve, ye, xe, t.normal), (f.face = t);
      }
      return f;
    }
    Ce.prototype = Object.assign(Object.create(X.prototype), {
      constructor: Ce,
      isMesh: !0,
      copy: function (t) {
        return (
          X.prototype.copy.call(this, t),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary
            )),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      },
      updateMorphTargets: function () {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
      raycast: function (t, e) {
        const n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
        if (void 0 === i) return;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          ge.copy(n.boundingSphere),
          ge.applyMatrix4(r),
          !1 === t.ray.intersectsSphere(ge))
        )
          return;
        if (
          (fe.getInverse(r),
          me.copy(t.ray).applyMatrix4(fe),
          null !== n.boundingBox && !1 === me.intersectsBox(n.boundingBox))
        )
          return;
        let o;
        if (n.isBufferGeometry) {
          const r = n.index,
            s = n.attributes.position,
            a = n.morphAttributes.position,
            c = n.morphTargetsRelative,
            l = n.attributes.uv,
            u = n.attributes.uv2,
            h = n.groups,
            p = n.drawRange;
          if (null !== r)
            if (Array.isArray(i))
              for (let n = 0, d = h.length; n < d; n++) {
                const d = h[n],
                  f = i[d.materialIndex];
                for (
                  let n = Math.max(d.start, p.start),
                    i = Math.min(d.start + d.count, p.start + p.count);
                  n < i;
                  n += 3
                ) {
                  const i = r.getX(n),
                    h = r.getX(n + 1),
                    p = r.getX(n + 2);
                  (o = Ie(this, f, t, me, s, a, c, l, u, i, h, p)),
                    o &&
                      ((o.faceIndex = Math.floor(n / 3)),
                      (o.face.materialIndex = d.materialIndex),
                      e.push(o));
                }
              }
            else {
              for (
                let n = Math.max(0, p.start),
                  h = Math.min(r.count, p.start + p.count);
                n < h;
                n += 3
              ) {
                const h = r.getX(n),
                  p = r.getX(n + 1),
                  d = r.getX(n + 2);
                (o = Ie(this, i, t, me, s, a, c, l, u, h, p, d)),
                  o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
              }
            }
          else if (void 0 !== s)
            if (Array.isArray(i))
              for (let n = 0, r = h.length; n < r; n++) {
                const r = h[n],
                  d = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, p.start),
                    i = Math.min(r.start + r.count, p.start + p.count);
                  n < i;
                  n += 3
                ) {
                  (o = Ie(this, d, t, me, s, a, c, l, u, n, n + 1, n + 2)),
                    o &&
                      ((o.faceIndex = Math.floor(n / 3)),
                      (o.face.materialIndex = r.materialIndex),
                      e.push(o));
                }
              }
            else {
              for (
                let n = Math.max(0, p.start),
                  r = Math.min(s.count, p.start + p.count);
                n < r;
                n += 3
              ) {
                (o = Ie(this, i, t, me, s, a, c, l, u, n, n + 1, n + 2)),
                  o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
              }
            }
        } else if (n.isGeometry) {
          const r = Array.isArray(i),
            s = n.vertices,
            a = n.faces;
          let c;
          const u = n.faceVertexUvs[0];
          u.length > 0 && (c = u);
          for (let n = 0, u = a.length; n < u; n++) {
            const u = a[n],
              h = r ? i[u.materialIndex] : i;
            if (void 0 === h) continue;
            const p = s[u.a],
              d = s[u.b],
              f = s[u.c];
            if (((o = Oe(this, h, t, me, p, d, f, Re)), o)) {
              if (c && c[n]) {
                const t = c[n];
                Ee.copy(t[0]),
                  Ae.copy(t[1]),
                  Le.copy(t[2]),
                  (o.uv = Dt.getUV(Re, p, d, f, Ee, Ae, Le, new l()));
              }
              (o.face = u), (o.faceIndex = n), e.push(o);
            }
          }
        }
      },
    });
    let De = 0;
    const Ne = new R(),
      ke = new X(),
      Ue = new w();
    function ze() {
      Object.defineProperty(this, "id", { value: (De += 2) }),
        (this.uuid = c.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    ze.prototype = Object.assign(Object.create(s.prototype), {
      constructor: ze,
      isGeometry: !0,
      applyMatrix4: function (t) {
        const e = new u().getNormalMatrix(t);
        for (let e = 0, n = this.vertices.length; e < n; e++) {
          this.vertices[e].applyMatrix4(t);
        }
        for (let t = 0, n = this.faces.length; t < n; t++) {
          const n = this.faces[t];
          n.normal.applyMatrix3(e).normalize();
          for (let t = 0, i = n.vertexNormals.length; t < i; t++)
            n.vertexNormals[t].applyMatrix3(e).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      },
      rotateX: function (t) {
        return Ne.makeRotationX(t), this.applyMatrix4(Ne), this;
      },
      rotateY: function (t) {
        return Ne.makeRotationY(t), this.applyMatrix4(Ne), this;
      },
      rotateZ: function (t) {
        return Ne.makeRotationZ(t), this.applyMatrix4(Ne), this;
      },
      translate: function (t, e, n) {
        return Ne.makeTranslation(t, e, n), this.applyMatrix4(Ne), this;
      },
      scale: function (t, e, n) {
        return Ne.makeScale(t, e, n), this.applyMatrix4(Ne), this;
      },
      lookAt: function (t) {
        return (
          ke.lookAt(t), ke.updateMatrix(), this.applyMatrix4(ke.matrix), this
        );
      },
      fromBufferGeometry: function (t) {
        const e = this,
          n = null !== t.index ? t.index : void 0,
          i = t.attributes;
        if (void 0 === i.position)
          return (
            console.error(
              "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
            ),
            this
          );
        const r = i.position,
          o = i.normal,
          s = i.color,
          a = i.uv,
          c = i.uv2;
        void 0 !== c && (this.faceVertexUvs[1] = []);
        for (let t = 0; t < r.count; t++)
          e.vertices.push(new w().fromBufferAttribute(r, t)),
            void 0 !== s && e.colors.push(new zt().fromBufferAttribute(s, t));
        function u(t, n, i, r) {
          const u =
              void 0 === s
                ? []
                : [
                    e.colors[t].clone(),
                    e.colors[n].clone(),
                    e.colors[i].clone(),
                  ],
            h = new Gt(
              t,
              n,
              i,
              void 0 === o
                ? []
                : [
                    new w().fromBufferAttribute(o, t),
                    new w().fromBufferAttribute(o, n),
                    new w().fromBufferAttribute(o, i),
                  ],
              u,
              r
            );
          e.faces.push(h),
            void 0 !== a &&
              e.faceVertexUvs[0].push([
                new l().fromBufferAttribute(a, t),
                new l().fromBufferAttribute(a, n),
                new l().fromBufferAttribute(a, i),
              ]),
            void 0 !== c &&
              e.faceVertexUvs[1].push([
                new l().fromBufferAttribute(c, t),
                new l().fromBufferAttribute(c, n),
                new l().fromBufferAttribute(c, i),
              ]);
        }
        const h = t.groups;
        if (h.length > 0)
          for (let t = 0; t < h.length; t++) {
            const e = h[t],
              i = e.start;
            for (let t = i, r = i + e.count; t < r; t += 3)
              void 0 !== n
                ? u(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex)
                : u(t, t + 1, t + 2, e.materialIndex);
          }
        else if (void 0 !== n)
          for (let t = 0; t < n.count; t += 3)
            u(n.getX(t), n.getX(t + 1), n.getX(t + 2));
        else for (let t = 0; t < r.count; t += 3) u(t, t + 1, t + 2);
        return (
          this.computeFaceNormals(),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Ue).negate(),
          this.translate(Ue.x, Ue.y, Ue.z),
          this
        );
      },
      normalize: function () {
        this.computeBoundingSphere();
        const t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          i = new R();
        return (
          i.set(
            n,
            0,
            0,
            -n * t.x,
            0,
            n,
            0,
            -n * t.y,
            0,
            0,
            n,
            -n * t.z,
            0,
            0,
            0,
            1
          ),
          this.applyMatrix4(i),
          this
        );
      },
      computeFaceNormals: function () {
        const t = new w(),
          e = new w();
        for (let n = 0, i = this.faces.length; n < i; n++) {
          const i = this.faces[n],
            r = this.vertices[i.a],
            o = this.vertices[i.b],
            s = this.vertices[i.c];
          t.subVectors(s, o),
            e.subVectors(r, o),
            t.cross(e),
            t.normalize(),
            i.normal.copy(t);
        }
      },
      computeVertexNormals: function (t) {
        void 0 === t && (t = !0);
        const e = new Array(this.vertices.length);
        for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new w();
        if (t) {
          const t = new w(),
            n = new w();
          for (let i = 0, r = this.faces.length; i < r; i++) {
            const r = this.faces[i],
              o = this.vertices[r.a],
              s = this.vertices[r.b],
              a = this.vertices[r.c];
            t.subVectors(a, s),
              n.subVectors(o, s),
              t.cross(n),
              e[r.a].add(t),
              e[r.b].add(t),
              e[r.c].add(t);
          }
        } else {
          this.computeFaceNormals();
          for (let t = 0, n = this.faces.length; t < n; t++) {
            const n = this.faces[t];
            e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
          }
        }
        for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
        for (let t = 0, n = this.faces.length; t < n; t++) {
          const n = this.faces[t],
            i = n.vertexNormals;
          3 === i.length
            ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c]))
            : ((i[0] = e[n.a].clone()),
              (i[1] = e[n.b].clone()),
              (i[2] = e[n.c].clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeFlatVertexNormals: function () {
        this.computeFaceNormals();
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t],
            n = e.vertexNormals;
          3 === n.length
            ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal))
            : ((n[0] = e.normal.clone()),
              (n[1] = e.normal.clone()),
              (n[2] = e.normal.clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeMorphNormals: function () {
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          e.__originalFaceNormal
            ? e.__originalFaceNormal.copy(e.normal)
            : (e.__originalFaceNormal = e.normal.clone()),
            e.__originalVertexNormals || (e.__originalVertexNormals = []);
          for (let t = 0, n = e.vertexNormals.length; t < n; t++)
            e.__originalVertexNormals[t]
              ? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
              : (e.__originalVertexNormals[t] = e.vertexNormals[t].clone());
        }
        const t = new ze();
        t.faces = this.faces;
        for (let e = 0, n = this.morphTargets.length; e < n; e++) {
          if (!this.morphNormals[e]) {
            (this.morphNormals[e] = {}),
              (this.morphNormals[e].faceNormals = []),
              (this.morphNormals[e].vertexNormals = []);
            const t = this.morphNormals[e].faceNormals,
              n = this.morphNormals[e].vertexNormals;
            for (let e = 0, i = this.faces.length; e < i; e++) {
              const e = new w(),
                i = { a: new w(), b: new w(), c: new w() };
              t.push(e), n.push(i);
            }
          }
          const n = this.morphNormals[e];
          (t.vertices = this.morphTargets[e].vertices),
            t.computeFaceNormals(),
            t.computeVertexNormals();
          for (let t = 0, e = this.faces.length; t < e; t++) {
            const e = this.faces[t],
              i = n.faceNormals[t],
              r = n.vertexNormals[t];
            i.copy(e.normal),
              r.a.copy(e.vertexNormals[0]),
              r.b.copy(e.vertexNormals[1]),
              r.c.copy(e.vertexNormals[2]);
          }
        }
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          (e.normal = e.__originalFaceNormal),
            (e.vertexNormals = e.__originalVertexNormals);
        }
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new ct()),
          this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new ht()),
          this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function (t, e, n) {
        if (!t || !t.isGeometry)
          return void console.error(
            "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
            t
          );
        let i,
          r = this.vertices.length,
          o = this.vertices,
          s = t.vertices,
          a = this.faces,
          c = t.faces,
          l = this.colors,
          h = t.colors;
        void 0 === n && (n = 0),
          void 0 !== e && (i = new u().getNormalMatrix(e));
        for (let t = 0, n = s.length; t < n; t++) {
          const n = s[t].clone();
          void 0 !== e && n.applyMatrix4(e), o.push(n);
        }
        for (let t = 0, e = h.length; t < e; t++) l.push(h[t].clone());
        for (let t = 0, e = c.length; t < e; t++) {
          let e,
            o,
            s,
            l = c[t],
            u = l.vertexNormals,
            h = l.vertexColors;
          (e = new Gt(l.a + r, l.b + r, l.c + r)),
            e.normal.copy(l.normal),
            void 0 !== i && e.normal.applyMatrix3(i).normalize();
          for (let t = 0, n = u.length; t < n; t++)
            (o = u[t].clone()),
              void 0 !== i && o.applyMatrix3(i).normalize(),
              e.vertexNormals.push(o);
          e.color.copy(l.color);
          for (let t = 0, n = h.length; t < n; t++)
            (s = h[t]), e.vertexColors.push(s.clone());
          (e.materialIndex = l.materialIndex + n), a.push(e);
        }
        for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
          const n = t.faceVertexUvs[e];
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t],
              r = [];
            for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
            this.faceVertexUvs[e].push(r);
          }
        }
      },
      mergeMesh: function (t) {
        t && t.isMesh
          ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
          : console.error(
              "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
              t
            );
      },
      mergeVertices: function () {
        const t = {},
          e = [],
          n = [],
          i = Math.pow(10, 4);
        for (let r = 0, o = this.vertices.length; r < o; r++) {
          const o = this.vertices[r],
            s =
              Math.round(o.x * i) +
              "_" +
              Math.round(o.y * i) +
              "_" +
              Math.round(o.z * i);
          void 0 === t[s]
            ? ((t[s] = r), e.push(this.vertices[r]), (n[r] = e.length - 1))
            : (n[r] = n[t[s]]);
        }
        const r = [];
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          (e.a = n[e.a]), (e.b = n[e.b]), (e.c = n[e.c]);
          const i = [e.a, e.b, e.c];
          for (let e = 0; e < 3; e++)
            if (i[e] === i[(e + 1) % 3]) {
              r.push(t);
              break;
            }
        }
        for (let t = r.length - 1; t >= 0; t--) {
          const e = r[t];
          this.faces.splice(e, 1);
          for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)
            this.faceVertexUvs[t].splice(e, 1);
        }
        const o = this.vertices.length - e.length;
        return (this.vertices = e), o;
      },
      setFromPoints: function (t) {
        this.vertices = [];
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          this.vertices.push(new w(n.x, n.y, n.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function () {
        const t = this.faces,
          e = t.length;
        for (let n = 0; n < e; n++) t[n]._id = n;
        t.sort(function (t, e) {
          return t.materialIndex - e.materialIndex;
        });
        const n = this.faceVertexUvs[0],
          i = this.faceVertexUvs[1];
        let r, o;
        n && n.length === e && (r = []), i && i.length === e && (o = []);
        for (let s = 0; s < e; s++) {
          const e = t[s]._id;
          r && r.push(n[e]), o && o.push(i[e]);
        }
        r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
      },
      toJSON: function () {
        const t = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        const e = [];
        for (let t = 0; t < this.vertices.length; t++) {
          const n = this.vertices[t];
          e.push(n.x, n.y, n.z);
        }
        const n = [],
          i = [],
          r = {},
          o = [],
          s = {},
          a = [],
          c = {};
        for (let t = 0; t < this.faces.length; t++) {
          const e = this.faces[t],
            i = !0,
            r = !1,
            o = void 0 !== this.faceVertexUvs[0][t],
            s = e.normal.length() > 0,
            a = e.vertexNormals.length > 0,
            c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
            d = e.vertexColors.length > 0;
          let f = 0;
          if (
            ((f = l(f, 0, 0)),
            (f = l(f, 1, i)),
            (f = l(f, 2, r)),
            (f = l(f, 3, o)),
            (f = l(f, 4, s)),
            (f = l(f, 5, a)),
            (f = l(f, 6, c)),
            (f = l(f, 7, d)),
            n.push(f),
            n.push(e.a, e.b, e.c),
            n.push(e.materialIndex),
            o)
          ) {
            const e = this.faceVertexUvs[0][t];
            n.push(p(e[0]), p(e[1]), p(e[2]));
          }
          if ((s && n.push(u(e.normal)), a)) {
            const t = e.vertexNormals;
            n.push(u(t[0]), u(t[1]), u(t[2]));
          }
          if ((c && n.push(h(e.color)), d)) {
            const t = e.vertexColors;
            n.push(h(t[0]), h(t[1]), h(t[2]));
          }
        }
        function l(t, e, n) {
          return n ? t | (1 << e) : t & ~(1 << e);
        }
        function u(t) {
          const e = t.x.toString() + t.y.toString() + t.z.toString();
          return (
            void 0 !== r[e] || ((r[e] = i.length / 3), i.push(t.x, t.y, t.z)),
            r[e]
          );
        }
        function h(t) {
          const e = t.r.toString() + t.g.toString() + t.b.toString();
          return (
            void 0 !== s[e] || ((s[e] = o.length), o.push(t.getHex())), s[e]
          );
        }
        function p(t) {
          const e = t.x.toString() + t.y.toString();
          return (
            void 0 !== c[e] || ((c[e] = a.length / 2), a.push(t.x, t.y)), c[e]
          );
        }
        return (
          (t.data = {}),
          (t.data.vertices = e),
          (t.data.normals = i),
          o.length > 0 && (t.data.colors = o),
          a.length > 0 && (t.data.uvs = [a]),
          (t.data.faces = n),
          t
        );
      },
      clone: function () {
        return new ze().copy(this);
      },
      copy: function (t) {
        (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        const e = t.vertices;
        for (let t = 0, n = e.length; t < n; t++)
          this.vertices.push(e[t].clone());
        const n = t.colors;
        for (let t = 0, e = n.length; t < e; t++)
          this.colors.push(n[t].clone());
        const i = t.faces;
        for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
        for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
          const n = t.faceVertexUvs[e];
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t],
              r = [];
            for (let t = 0, e = i.length; t < e; t++) {
              const e = i[t];
              r.push(e.clone());
            }
            this.faceVertexUvs[e].push(r);
          }
        }
        const r = t.morphTargets;
        for (let t = 0, e = r.length; t < e; t++) {
          const e = {};
          if (((e.name = r[t].name), void 0 !== r[t].vertices)) {
            e.vertices = [];
            for (let n = 0, i = r[t].vertices.length; n < i; n++)
              e.vertices.push(r[t].vertices[n].clone());
          }
          if (void 0 !== r[t].normals) {
            e.normals = [];
            for (let n = 0, i = r[t].normals.length; n < i; n++)
              e.normals.push(r[t].normals[n].clone());
          }
          this.morphTargets.push(e);
        }
        const o = t.morphNormals;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = {};
          if (void 0 !== o[t].vertexNormals) {
            e.vertexNormals = [];
            for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
              const i = o[t].vertexNormals[n],
                r = {};
              (r.a = i.a.clone()),
                (r.b = i.b.clone()),
                (r.c = i.c.clone()),
                e.vertexNormals.push(r);
            }
          }
          if (void 0 !== o[t].faceNormals) {
            e.faceNormals = [];
            for (let n = 0, i = o[t].faceNormals.length; n < i; n++)
              e.faceNormals.push(o[t].faceNormals[n].clone());
          }
          this.morphNormals.push(e);
        }
        const s = t.skinWeights;
        for (let t = 0, e = s.length; t < e; t++)
          this.skinWeights.push(s[t].clone());
        const a = t.skinIndices;
        for (let t = 0, e = a.length; t < e; t++)
          this.skinIndices.push(a[t].clone());
        const c = t.lineDistances;
        for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);
        const l = t.boundingBox;
        null !== l && (this.boundingBox = l.clone());
        const u = t.boundingSphere;
        return (
          null !== u && (this.boundingSphere = u.clone()),
          (this.elementsNeedUpdate = t.elementsNeedUpdate),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    });
    class Be extends de {
      constructor(t, e, n, i, r, o) {
        super(),
          (this.type = "BoxBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: o,
          });
        const s = this;
        (t = t || 1),
          (e = e || 1),
          (n = n || 1),
          (i = Math.floor(i) || 1),
          (r = Math.floor(r) || 1),
          (o = Math.floor(o) || 1);
        const a = [],
          c = [],
          l = [],
          u = [];
        let h = 0,
          p = 0;
        function d(t, e, n, i, r, o, d, f, m, g, v) {
          const y = o / m,
            x = d / g,
            b = o / 2,
            _ = d / 2,
            M = f / 2,
            S = m + 1,
            T = g + 1;
          let E = 0,
            A = 0;
          const L = new w();
          for (let o = 0; o < T; o++) {
            const s = o * x - _;
            for (let a = 0; a < S; a++) {
              const h = a * y - b;
              (L[t] = h * i),
                (L[e] = s * r),
                (L[n] = M),
                c.push(L.x, L.y, L.z),
                (L[t] = 0),
                (L[e] = 0),
                (L[n] = f > 0 ? 1 : -1),
                l.push(L.x, L.y, L.z),
                u.push(a / m),
                u.push(1 - o / g),
                (E += 1);
            }
          }
          for (let t = 0; t < g; t++)
            for (let e = 0; e < m; e++) {
              const n = h + e + S * t,
                i = h + e + S * (t + 1),
                r = h + (e + 1) + S * (t + 1),
                o = h + (e + 1) + S * t;
              a.push(n, i, o), a.push(i, r, o), (A += 6);
            }
          s.addGroup(p, A, v), (p += A), (h += E);
        }
        d("z", "y", "x", -1, -1, n, e, t, o, r, 0),
          d("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
          d("x", "z", "y", 1, 1, t, n, e, i, o, 2),
          d("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
          d("x", "y", "z", 1, -1, t, e, n, i, r, 4),
          d("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
          this.setIndex(a),
          this.setAttribute("position", new ne(c, 3)),
          this.setAttribute("normal", new ne(l, 3)),
          this.setAttribute("uv", new ne(u, 2));
      }
    }
    function Fe(t) {
      const e = {};
      for (const n in t) {
        e[n] = {};
        for (const i in t[n]) {
          const r = t[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture)
            ? (e[n][i] = r.clone())
            : Array.isArray(r)
            ? (e[n][i] = r.slice())
            : (e[n][i] = r);
        }
      }
      return e;
    }
    function He(t) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const i = Fe(t[n]);
        for (const t in i) e[t] = i[t];
      }
      return e;
    }
    const Ge = { clone: Fe, merge: He };
    function je(t) {
      Vt.call(this),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(t));
    }
    function Ve() {
      X.call(this),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new R()),
        (this.projectionMatrix = new R()),
        (this.projectionMatrixInverse = new R());
    }
    function We(t, e, n, i) {
      Ve.call(this),
        (this.type = "PerspectiveCamera"),
        (this.fov = void 0 !== t ? t : 50),
        (this.zoom = 1),
        (this.near = void 0 !== n ? n : 0.1),
        (this.far = void 0 !== i ? i : 2e3),
        (this.focus = 10),
        (this.aspect = void 0 !== e ? e : 1),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    (je.prototype = Object.create(Vt.prototype)),
      (je.prototype.constructor = je),
      (je.prototype.isShaderMaterial = !0),
      (je.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = Fe(t.uniforms)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.extensions = Object.assign({}, t.extensions)),
          this
        );
      }),
      (je.prototype.toJSON = function (t) {
        const e = Vt.prototype.toJSON.call(this, t);
        e.uniforms = {};
        for (const n in this.uniforms) {
          const i = this.uniforms[n].value;
          i && i.isTexture
            ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
            : i && i.isColor
            ? (e.uniforms[n] = { type: "c", value: i.getHex() })
            : i && i.isVector2
            ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
            : i && i.isVector3
            ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
            : i && i.isVector4
            ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
            : i && i.isMatrix3
            ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
            : i && i.isMatrix4
            ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
            : (e.uniforms[n] = { value: i });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader);
        const n = {};
        for (const t in this.extensions)
          !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e;
      }),
      (Ve.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Ve,
        isCamera: !0,
        copy: function (t, e) {
          return (
            X.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (t = new w())),
            this.updateMatrixWorld(!0);
          const e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        },
        updateMatrixWorld: function (t) {
          X.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        updateWorldMatrix: function (t, e) {
          X.prototype.updateWorldMatrix.call(this, t, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (We.prototype = Object.assign(Object.create(Ve.prototype), {
        constructor: We,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
          return (
            Ve.prototype.copy.call(this, t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        },
        setFocalLength: function (t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * c.RAD2DEG * Math.atan(e)),
            this.updateProjectionMatrix();
        },
        getFocalLength: function () {
          const t = Math.tan(0.5 * c.DEG2RAD * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        },
        getEffectiveFOV: function () {
          return (
            2 *
            c.RAD2DEG *
            Math.atan(Math.tan(0.5 * c.DEG2RAD * this.fov) / this.zoom)
          );
        },
        getFilmWidth: function () {
          return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function () {
          return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function (t, e, n, i, r, o) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          let t = this.near,
            e = (t * Math.tan(0.5 * c.DEG2RAD * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i,
            o = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = o.fullWidth,
              s = o.fullHeight;
            (r += (o.offsetX * i) / t),
              (e -= (o.offsetY * n) / s),
              (i *= o.width / t),
              (n *= o.height / s);
          }
          const s = this.filmOffset;
          0 !== s && (r += (t * s) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far
            ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          const e = X.prototype.toJSON.call(this, t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        },
      }));
    function qe(t, e, n) {
      if (
        (X.call(this),
        (this.type = "CubeCamera"),
        !0 !== n.isWebGLCubeRenderTarget)
      )
        return void console.error(
          "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
        );
      this.renderTarget = n;
      const i = new We(90, 1, t, e);
      (i.layers = this.layers),
        i.up.set(0, -1, 0),
        i.lookAt(new w(1, 0, 0)),
        this.add(i);
      const r = new We(90, 1, t, e);
      (r.layers = this.layers),
        r.up.set(0, -1, 0),
        r.lookAt(new w(-1, 0, 0)),
        this.add(r);
      const o = new We(90, 1, t, e);
      (o.layers = this.layers),
        o.up.set(0, 0, 1),
        o.lookAt(new w(0, 1, 0)),
        this.add(o);
      const s = new We(90, 1, t, e);
      (s.layers = this.layers),
        s.up.set(0, 0, -1),
        s.lookAt(new w(0, -1, 0)),
        this.add(s);
      const a = new We(90, 1, t, e);
      (a.layers = this.layers),
        a.up.set(0, -1, 0),
        a.lookAt(new w(0, 0, 1)),
        this.add(a);
      const c = new We(90, 1, t, e);
      (c.layers = this.layers),
        c.up.set(0, -1, 0),
        c.lookAt(new w(0, 0, -1)),
        this.add(c),
        (this.update = function (t, e) {
          null === this.parent && this.updateMatrixWorld();
          const l = t.xr.enabled,
            u = t.getRenderTarget();
          t.xr.enabled = !1;
          const h = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, o),
            t.setRenderTarget(n, 3),
            t.render(e, s),
            t.setRenderTarget(n, 4),
            t.render(e, a),
            (n.texture.generateMipmaps = h),
            t.setRenderTarget(n, 5),
            t.render(e, c),
            t.setRenderTarget(u),
            (t.xr.enabled = l);
        }),
        (this.clear = function (t, e, i, r) {
          const o = t.getRenderTarget();
          for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);
          t.setRenderTarget(o);
        });
    }
    function Xe(t, e, n) {
      Number.isInteger(e) &&
        (console.warn(
          "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
        ),
        (e = n)),
        g.call(this, t, t, e);
    }
    function Ye(t, e, n, i, r, o, s, a, c, l, u, h) {
      f.call(this, null, o, s, a, c, l, i, r, u, h),
        (this.image = { data: t || null, width: e || 1, height: n || 1 }),
        (this.magFilter = void 0 !== c ? c : 1003),
        (this.minFilter = void 0 !== l ? l : 1003),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1),
        (this.needsUpdate = !0);
    }
    (qe.prototype = Object.create(X.prototype)),
      (qe.prototype.constructor = qe),
      (Xe.prototype = Object.create(g.prototype)),
      (Xe.prototype.constructor = Xe),
      (Xe.prototype.isWebGLCubeRenderTarget = !0),
      (Xe.prototype.fromEquirectangularTexture = function (t, e) {
        (this.texture.type = e.type),
          (this.texture.format = e.format),
          (this.texture.encoding = e.encoding);
        const n = new Y(),
          i = {
            uniforms: { tEquirect: { value: null } },
            vertexShader: [
              "varying vec3 vWorldDirection;",
              "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
              "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
              "}",
              "void main() {",
              "\tvWorldDirection = transformDirection( position, modelMatrix );",
              "\t#include <begin_vertex>",
              "\t#include <project_vertex>",
              "}",
            ].join("\n"),
            fragmentShader: [
              "uniform sampler2D tEquirect;",
              "varying vec3 vWorldDirection;",
              "#include <common>",
              "void main() {",
              "\tvec3 direction = normalize( vWorldDirection );",
              "\tvec2 sampleUV = equirectUv( direction );",
              "\tgl_FragColor = texture2D( tEquirect, sampleUV );",
              "}",
            ].join("\n"),
          },
          r = new je({
            name: "CubemapFromEquirect",
            uniforms: Fe(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: 1,
            blending: 0,
          });
        r.uniforms.tEquirect.value = e;
        const o = new Ce(new Be(5, 5, 5), r);
        n.add(o);
        return (
          new qe(1, 10, this).update(t, n),
          o.geometry.dispose(),
          o.material.dispose(),
          this
        );
      }),
      (Ye.prototype = Object.create(f.prototype)),
      (Ye.prototype.constructor = Ye),
      (Ye.prototype.isDataTexture = !0);
    const Ze = new ht(),
      Je = new w();
    function Ke(t, e, n, i, r, o) {
      this.planes = [
        void 0 !== t ? t : new Mt(),
        void 0 !== e ? e : new Mt(),
        void 0 !== n ? n : new Mt(),
        void 0 !== i ? i : new Mt(),
        void 0 !== r ? r : new Mt(),
        void 0 !== o ? o : new Mt(),
      ];
    }
    Object.assign(Ke.prototype, {
      set: function (t, e, n, i, r, o) {
        const s = this.planes;
        return (
          s[0].copy(t),
          s[1].copy(e),
          s[2].copy(n),
          s[3].copy(i),
          s[4].copy(r),
          s[5].copy(o),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this;
      },
      setFromProjectionMatrix: function (t) {
        const e = this.planes,
          n = t.elements,
          i = n[0],
          r = n[1],
          o = n[2],
          s = n[3],
          a = n[4],
          c = n[5],
          l = n[6],
          u = n[7],
          h = n[8],
          p = n[9],
          d = n[10],
          f = n[11],
          m = n[12],
          g = n[13],
          v = n[14],
          y = n[15];
        return (
          e[0].setComponents(s - i, u - a, f - h, y - m).normalize(),
          e[1].setComponents(s + i, u + a, f + h, y + m).normalize(),
          e[2].setComponents(s + r, u + c, f + p, y + g).normalize(),
          e[3].setComponents(s - r, u - c, f - p, y - g).normalize(),
          e[4].setComponents(s - o, u - l, f - d, y - v).normalize(),
          e[5].setComponents(s + o, u + l, f + d, y + v).normalize(),
          this
        );
      },
      intersectsObject: function (t) {
        const e = t.geometry;
        return (
          null === e.boundingSphere && e.computeBoundingSphere(),
          Ze.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Ze)
        );
      },
      intersectsSprite: function (t) {
        return (
          Ze.center.set(0, 0, 0),
          (Ze.radius = 0.7071067811865476),
          Ze.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Ze)
        );
      },
      intersectsSphere: function (t) {
        const e = this.planes,
          n = t.center,
          i = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(n) < i) return !1;
        }
        return !0;
      },
      intersectsBox: function (t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
          const i = e[n];
          if (
            ((Je.x = i.normal.x > 0 ? t.max.x : t.min.x),
            (Je.y = i.normal.y > 0 ? t.max.y : t.min.y),
            (Je.z = i.normal.z > 0 ? t.max.z : t.min.z),
            i.distanceToPoint(Je) < 0)
          )
            return !1;
        }
        return !0;
      },
      containsPoint: function (t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
        return !0;
      },
    });
    const $e = {
      common: {
        diffuse: { value: new zt(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new u() },
        uv2Transform: { value: new u() },
        alphaMap: { value: null },
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 },
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new l(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new zt(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
      },
      points: {
        diffuse: { value: new zt(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new u() },
      },
      sprite: {
        diffuse: { value: new zt(15658734) },
        opacity: { value: 1 },
        center: { value: new l(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new u() },
      },
    };
    function Qe() {
      let t = null,
        e = !1,
        n = null,
        i = null;
      function r(e, o) {
        n(e, o), (i = t.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== e &&
            null !== n &&
            ((i = t.requestAnimationFrame(r)), (e = !0));
        },
        stop: function () {
          t.cancelAnimationFrame(i), (e = !1);
        },
        setAnimationLoop: function (t) {
          n = t;
        },
        setContext: function (e) {
          t = e;
        },
      };
    }
    function tn(t, e) {
      const n = e.isWebGL2,
        i = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
        },
        remove: function (e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const n = i.get(e);
          n && (t.deleteBuffer(n.buffer), i.delete(e));
        },
        update: function (e, r) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const o = i.get(e);
          void 0 === o
            ? i.set(
                e,
                (function (e, n) {
                  const i = e.array,
                    r = e.usage,
                    o = t.createBuffer();
                  t.bindBuffer(n, o),
                    t.bufferData(n, i, r),
                    e.onUploadCallback();
                  let s = 5126;
                  return (
                    i instanceof Float32Array
                      ? (s = 5126)
                      : i instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : i instanceof Uint16Array
                      ? (s = 5123)
                      : i instanceof Int16Array
                      ? (s = 5122)
                      : i instanceof Uint32Array
                      ? (s = 5125)
                      : i instanceof Int32Array
                      ? (s = 5124)
                      : i instanceof Int8Array
                      ? (s = 5120)
                      : i instanceof Uint8Array && (s = 5121),
                    {
                      buffer: o,
                      type: s,
                      bytesPerElement: i.BYTES_PER_ELEMENT,
                      version: e.version,
                    }
                  );
                })(e, r)
              )
            : o.version < e.version &&
              (!(function (e, i, r) {
                const o = i.array,
                  s = i.updateRange;
                t.bindBuffer(r, e),
                  -1 === s.count
                    ? t.bufferSubData(r, 0, o)
                    : (n
                        ? t.bufferSubData(
                            r,
                            s.offset * o.BYTES_PER_ELEMENT,
                            o,
                            s.offset,
                            s.count
                          )
                        : t.bufferSubData(
                            r,
                            s.offset * o.BYTES_PER_ELEMENT,
                            o.subarray(s.offset, s.offset + s.count)
                          ),
                      (s.count = -1));
              })(o.buffer, e, r),
              (o.version = e.version));
        },
      };
    }
    function en(t, e, n, i) {
      ze.call(this),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        }),
        this.fromBufferGeometry(new nn(t, e, n, i)),
        this.mergeVertices();
    }
    function nn(t, e, n, i) {
      de.call(this),
        (this.type = "PlaneBufferGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      const r = (t = t || 1) / 2,
        o = (e = e || 1) / 2,
        s = Math.floor(n) || 1,
        a = Math.floor(i) || 1,
        c = s + 1,
        l = a + 1,
        u = t / s,
        h = e / a,
        p = [],
        d = [],
        f = [],
        m = [];
      for (let t = 0; t < l; t++) {
        const e = t * h - o;
        for (let n = 0; n < c; n++) {
          const i = n * u - r;
          d.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a);
        }
      }
      for (let t = 0; t < a; t++)
        for (let e = 0; e < s; e++) {
          const n = e + c * t,
            i = e + c * (t + 1),
            r = e + 1 + c * (t + 1),
            o = e + 1 + c * t;
          p.push(n, i, o), p.push(i, r, o);
        }
      this.setIndex(p),
        this.setAttribute("position", new ne(d, 3)),
        this.setAttribute("normal", new ne(f, 3)),
        this.setAttribute("uv", new ne(m, 2));
    }
    (en.prototype = Object.create(ze.prototype)),
      (en.prototype.constructor = en),
      (nn.prototype = Object.create(de.prototype)),
      (nn.prototype.constructor = nn);
    const rn = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin:
          "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      },
      on = {
        basic: {
          uniforms: He([
            $e.common,
            $e.specularmap,
            $e.envmap,
            $e.aomap,
            $e.lightmap,
            $e.fog,
          ]),
          vertexShader: rn.meshbasic_vert,
          fragmentShader: rn.meshbasic_frag,
        },
        lambert: {
          uniforms: He([
            $e.common,
            $e.specularmap,
            $e.envmap,
            $e.aomap,
            $e.lightmap,
            $e.emissivemap,
            $e.fog,
            $e.lights,
            { emissive: { value: new zt(0) } },
          ]),
          vertexShader: rn.meshlambert_vert,
          fragmentShader: rn.meshlambert_frag,
        },
        phong: {
          uniforms: He([
            $e.common,
            $e.specularmap,
            $e.envmap,
            $e.aomap,
            $e.lightmap,
            $e.emissivemap,
            $e.bumpmap,
            $e.normalmap,
            $e.displacementmap,
            $e.fog,
            $e.lights,
            {
              emissive: { value: new zt(0) },
              specular: { value: new zt(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: rn.meshphong_vert,
          fragmentShader: rn.meshphong_frag,
        },
        standard: {
          uniforms: He([
            $e.common,
            $e.envmap,
            $e.aomap,
            $e.lightmap,
            $e.emissivemap,
            $e.bumpmap,
            $e.normalmap,
            $e.displacementmap,
            $e.roughnessmap,
            $e.metalnessmap,
            $e.fog,
            $e.lights,
            {
              emissive: { value: new zt(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: rn.meshphysical_vert,
          fragmentShader: rn.meshphysical_frag,
        },
        toon: {
          uniforms: He([
            $e.common,
            $e.aomap,
            $e.lightmap,
            $e.emissivemap,
            $e.bumpmap,
            $e.normalmap,
            $e.displacementmap,
            $e.gradientmap,
            $e.fog,
            $e.lights,
            { emissive: { value: new zt(0) } },
          ]),
          vertexShader: rn.meshtoon_vert,
          fragmentShader: rn.meshtoon_frag,
        },
        matcap: {
          uniforms: He([
            $e.common,
            $e.bumpmap,
            $e.normalmap,
            $e.displacementmap,
            $e.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: rn.meshmatcap_vert,
          fragmentShader: rn.meshmatcap_frag,
        },
        points: {
          uniforms: He([$e.points, $e.fog]),
          vertexShader: rn.points_vert,
          fragmentShader: rn.points_frag,
        },
        dashed: {
          uniforms: He([
            $e.common,
            $e.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: rn.linedashed_vert,
          fragmentShader: rn.linedashed_frag,
        },
        depth: {
          uniforms: He([$e.common, $e.displacementmap]),
          vertexShader: rn.depth_vert,
          fragmentShader: rn.depth_frag,
        },
        normal: {
          uniforms: He([
            $e.common,
            $e.bumpmap,
            $e.normalmap,
            $e.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: rn.normal_vert,
          fragmentShader: rn.normal_frag,
        },
        sprite: {
          uniforms: He([$e.sprite, $e.fog]),
          vertexShader: rn.sprite_vert,
          fragmentShader: rn.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new u() }, t2D: { value: null } },
          vertexShader: rn.background_vert,
          fragmentShader: rn.background_frag,
        },
        cube: {
          uniforms: He([$e.envmap, { opacity: { value: 1 } }]),
          vertexShader: rn.cube_vert,
          fragmentShader: rn.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: rn.equirect_vert,
          fragmentShader: rn.equirect_frag,
        },
        distanceRGBA: {
          uniforms: He([
            $e.common,
            $e.displacementmap,
            {
              referencePosition: { value: new w() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: rn.distanceRGBA_vert,
          fragmentShader: rn.distanceRGBA_frag,
        },
        shadow: {
          uniforms: He([
            $e.lights,
            $e.fog,
            { color: { value: new zt(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: rn.shadow_vert,
          fragmentShader: rn.shadow_frag,
        },
      };
    function sn(t, e, n, i) {
      const r = new zt(0);
      let o,
        s,
        a = 0,
        c = null,
        l = 0,
        u = null;
      function h(t, n) {
        e.buffers.color.setClear(t.r, t.g, t.b, n, i);
      }
      return {
        getClearColor: function () {
          return r;
        },
        setClearColor: function (t, e) {
          r.set(t), (a = void 0 !== e ? e : 1), h(r, a);
        },
        getClearAlpha: function () {
          return a;
        },
        setClearAlpha: function (t) {
          (a = t), h(r, a);
        },
        render: function (e, i, p, d) {
          let f = !0 === i.isScene ? i.background : null;
          const m = t.xr,
            g = m.getSession && m.getSession();
          if (
            (g && "additive" === g.environmentBlendMode && (f = null),
            null === f ? h(r, a) : f && f.isColor && (h(f, 1), (d = !0)),
            (t.autoClear || d) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            f &&
              (f.isCubeTexture ||
                f.isWebGLCubeRenderTarget ||
                306 === f.mapping))
          ) {
            void 0 === s &&
              ((s = new Ce(
                new Be(1, 1, 1),
                new je({
                  name: "BackgroundCubeMaterial",
                  uniforms: Fe(on.cube.uniforms),
                  vertexShader: on.cube.vertexShader,
                  fragmentShader: on.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              s.geometry.deleteAttribute("normal"),
              s.geometry.deleteAttribute("uv"),
              (s.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(s.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              n.update(s));
            const i = f.isWebGLCubeRenderTarget ? f.texture : f;
            (s.material.uniforms.envMap.value = i),
              (s.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1),
              (c === f && l === i.version && u === t.toneMapping) ||
                ((s.material.needsUpdate = !0),
                (c = f),
                (l = i.version),
                (u = t.toneMapping)),
              e.unshift(s, s.geometry, s.material, 0, 0, null);
          } else
            f &&
              f.isTexture &&
              (void 0 === o &&
                ((o = new Ce(
                  new nn(2, 2),
                  new je({
                    name: "BackgroundMaterial",
                    uniforms: Fe(on.background.uniforms),
                    vertexShader: on.background.vertexShader,
                    fragmentShader: on.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                o.geometry.deleteAttribute("normal"),
                Object.defineProperty(o.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                n.update(o)),
              (o.material.uniforms.t2D.value = f),
              !0 === f.matrixAutoUpdate && f.updateMatrix(),
              o.material.uniforms.uvTransform.value.copy(f.matrix),
              (c === f && l === f.version && u === t.toneMapping) ||
                ((o.material.needsUpdate = !0),
                (c = f),
                (l = f.version),
                (u = t.toneMapping)),
              e.unshift(o, o.geometry, o.material, 0, 0, null));
        },
      };
    }
    function an(t, e, n, i) {
      const r = t.getParameter(34921),
        o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        s = i.isWebGL2 || null !== o,
        a = {},
        c = p(null);
      let l = c;
      function u(e) {
        return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
      }
      function h(e) {
        return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
      }
      function p(t) {
        const e = [],
          n = [],
          i = [];
        for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: e,
          enabledAttributes: n,
          attributeDivisors: i,
          object: t,
          attributes: {},
        };
      }
      function d() {
        const t = l.newAttributes;
        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
      }
      function f(t) {
        m(t, 0);
      }
      function m(n, r) {
        const o = l.newAttributes,
          s = l.enabledAttributes,
          a = l.attributeDivisors;
        if (
          ((o[n] = 1),
          0 === s[n] && (t.enableVertexAttribArray(n), (s[n] = 1)),
          a[n] !== r)
        ) {
          (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
            (a[n] = r);
        }
      }
      function g() {
        const e = l.newAttributes,
          n = l.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
          n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
      }
      function v(e, n, r, o, s, a) {
        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
          ? t.vertexAttribPointer(e, n, r, o, s, a)
          : t.vertexAttribIPointer(e, n, r, o, s, a);
      }
      function y() {
        x(), l !== c && ((l = c), u(l.object));
      }
      function x() {
        (c.geometry = null), (c.program = null), (c.wireframe = !1);
      }
      return {
        setup: function (r, c, h, y, x) {
          let b = !1;
          if (s) {
            const e = (function (e, n, r) {
              const s = !0 === r.wireframe;
              let c = a[e.id];
              void 0 === c && ((c = {}), (a[e.id] = c));
              let l = c[n.id];
              void 0 === l && ((l = {}), (c[n.id] = l));
              let u = l[s];
              void 0 === u &&
                ((u = p(
                  i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()
                )),
                (l[s] = u));
              return u;
            })(y, h, c);
            l !== e && ((l = e), u(l.object)),
              (b = (function (t) {
                const e = l.attributes,
                  n = t.attributes;
                if (Object.keys(e).length !== Object.keys(n).length) return !0;
                for (const t in n) {
                  const i = e[t],
                    r = n[t];
                  if (i.attribute !== r) return !0;
                  if (i.data !== r.data) return !0;
                }
                return !1;
              })(y)),
              b &&
                (function (t) {
                  const e = {},
                    n = t.attributes;
                  for (const t in n) {
                    const i = n[t],
                      r = {};
                    (r.attribute = i), i.data && (r.data = i.data), (e[t] = r);
                  }
                  l.attributes = e;
                })(y);
          } else {
            const t = !0 === c.wireframe;
            (l.geometry === y.id && l.program === h.id && l.wireframe === t) ||
              ((l.geometry = y.id),
              (l.program = h.id),
              (l.wireframe = t),
              (b = !0));
          }
          !0 === r.isInstancedMesh && (b = !0),
            null !== x && n.update(x, 34963),
            b &&
              (!(function (r, o, s, a) {
                if (
                  !1 === i.isWebGL2 &&
                  (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                  null === e.get("ANGLE_instanced_arrays")
                )
                  return;
                d();
                const c = a.attributes,
                  l = s.getAttributes(),
                  u = o.defaultAttributeValues;
                for (const e in l) {
                  const i = l[e];
                  if (i >= 0) {
                    const o = c[e];
                    if (void 0 !== o) {
                      const e = o.normalized,
                        r = o.itemSize,
                        s = n.get(o);
                      if (void 0 === s) continue;
                      const c = s.buffer,
                        l = s.type,
                        u = s.bytesPerElement;
                      if (o.isInterleavedBufferAttribute) {
                        const n = o.data,
                          s = n.stride,
                          h = o.offset;
                        n && n.isInstancedInterleavedBuffer
                          ? (m(i, n.meshPerAttribute),
                            void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                n.meshPerAttribute * n.count))
                          : f(i),
                          t.bindBuffer(34962, c),
                          v(i, r, l, e, s * u, h * u);
                      } else
                        o.isInstancedBufferAttribute
                          ? (m(i, o.meshPerAttribute),
                            void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                o.meshPerAttribute * o.count))
                          : f(i),
                          t.bindBuffer(34962, c),
                          v(i, r, l, e, 0, 0);
                    } else if ("instanceMatrix" === e) {
                      const e = n.get(r.instanceMatrix);
                      if (void 0 === e) continue;
                      const o = e.buffer,
                        s = e.type;
                      m(i + 0, 1),
                        m(i + 1, 1),
                        m(i + 2, 1),
                        m(i + 3, 1),
                        t.bindBuffer(34962, o),
                        t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                        t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                        t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                        t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
                    } else if (void 0 !== u) {
                      const n = u[e];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            t.vertexAttrib2fv(i, n);
                            break;
                          case 3:
                            t.vertexAttrib3fv(i, n);
                            break;
                          case 4:
                            t.vertexAttrib4fv(i, n);
                            break;
                          default:
                            t.vertexAttrib1fv(i, n);
                        }
                    }
                  }
                }
                g();
              })(r, c, h, y),
              null !== x && t.bindBuffer(34963, n.get(x).buffer));
        },
        reset: y,
        resetDefaultState: x,
        dispose: function () {
          y();
          for (const t in a) {
            const e = a[t];
            for (const t in e) {
              const n = e[t];
              for (const t in n) h(n[t].object), delete n[t];
              delete e[t];
            }
            delete a[t];
          }
        },
        releaseStatesOfGeometry: function (t) {
          if (void 0 === a[t.id]) return;
          const e = a[t.id];
          for (const t in e) {
            const n = e[t];
            for (const t in n) h(n[t].object), delete n[t];
            delete e[t];
          }
          delete a[t.id];
        },
        releaseStatesOfProgram: function (t) {
          for (const e in a) {
            const n = a[e];
            if (void 0 === n[t.id]) continue;
            const i = n[t.id];
            for (const t in i) h(i[t].object), delete i[t];
            delete n[t.id];
          }
        },
        initAttributes: d,
        enableAttribute: f,
        disableUnusedAttributes: g,
      };
    }
    function cn(t, e, n, i) {
      const r = i.isWebGL2;
      let o;
      (this.setMode = function (t) {
        o = t;
      }),
        (this.render = function (e, i) {
          t.drawArrays(o, e, i), n.update(i, o);
        }),
        (this.renderInstances = function (i, s, a, c) {
          if (0 === c) return;
          let l, u;
          if (r) (l = t), (u = "drawArraysInstanced");
          else if (
            ((l = e.get("ANGLE_instanced_arrays")),
            (u = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[u](o, s, a, c), n.update(a, o, c);
        });
    }
    function ln(t, e, n) {
      let i;
      function r(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          t.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      const o =
        ("undefined" != typeof WebGL2RenderingContext &&
          t instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          t instanceof WebGL2ComputeRenderingContext);
      let s = void 0 !== n.precision ? n.precision : "highp";
      const a = r(s);
      a !== s &&
        (console.warn(
          "THREE.WebGLRenderer:",
          s,
          "not supported, using",
          a,
          "instead."
        ),
        (s = a));
      const c = !0 === n.logarithmicDepthBuffer,
        l = t.getParameter(34930),
        u = t.getParameter(35660),
        h = t.getParameter(3379),
        p = t.getParameter(34076),
        d = t.getParameter(34921),
        f = t.getParameter(36347),
        m = t.getParameter(36348),
        g = t.getParameter(36349),
        v = u > 0,
        y = o || !!e.get("OES_texture_float");
      return {
        isWebGL2: o,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          const n = e.get("EXT_texture_filter_anisotropic");
          return (
            (i =
              null !== n
                ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                : 0),
            i
          );
        },
        getMaxPrecision: r,
        precision: s,
        logarithmicDepthBuffer: c,
        maxTextures: l,
        maxVertexTextures: u,
        maxTextureSize: h,
        maxCubemapSize: p,
        maxAttributes: d,
        maxVertexUniforms: f,
        maxVaryings: m,
        maxFragmentUniforms: g,
        vertexTextures: v,
        floatFragmentTextures: y,
        floatVertexTextures: v && y,
        maxSamples: o ? t.getParameter(36183) : 0,
      };
    }
    function un() {
      const t = this;
      let e = null,
        n = 0,
        i = !1,
        r = !1;
      const o = new Mt(),
        s = new u(),
        a = { value: null, needsUpdate: !1 };
      function c() {
        a.value !== e && ((a.value = e), (a.needsUpdate = n > 0)),
          (t.numPlanes = n),
          (t.numIntersection = 0);
      }
      function l(e, n, i, r) {
        let c = null !== e ? e.length : 0,
          l = null;
        if (0 !== c) {
          if (((l = a.value), !0 !== r || null === l)) {
            const t = i + 4 * c,
              r = n.matrixWorldInverse;
            s.getNormalMatrix(r),
              (null === l || l.length < t) && (l = new Float32Array(t));
            for (let t = 0, n = i; t !== c; ++t, n += 4)
              o.copy(e[t]).applyMatrix4(r, s),
                o.normal.toArray(l, n),
                (l[n + 3] = o.constant);
          }
          (a.value = l), (a.needsUpdate = !0);
        }
        return (t.numPlanes = c), (t.numIntersection = 0), l;
      }
      (this.uniform = a),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, r, o) {
          const s = 0 !== t.length || r || 0 !== n || i;
          return (i = r), (e = l(t, o, 0)), (n = t.length), s;
        }),
        (this.beginShadows = function () {
          (r = !0), l(null);
        }),
        (this.endShadows = function () {
          (r = !1), c();
        }),
        (this.setState = function (t, o, s, u, h, p) {
          if (!i || null === t || 0 === t.length || (r && !s))
            r ? l(null) : c();
          else {
            const i = r ? 0 : n,
              s = 4 * i;
            let c = h.clippingState || null;
            (a.value = c), (c = l(t, u, s, p));
            for (let t = 0; t !== s; ++t) c[t] = e[t];
            (h.clippingState = c),
              (this.numIntersection = o ? this.numPlanes : 0),
              (this.numPlanes += i);
          }
        });
    }
    function hn(t) {
      const e = {};
      return {
        get: function (n) {
          if (void 0 !== e[n]) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = t.getExtension(n);
          }
          return (
            null === i &&
              console.warn(
                "THREE.WebGLRenderer: " + n + " extension not supported."
              ),
            (e[n] = i),
            i
          );
        },
      };
    }
    function pn(t, e, n, i) {
      const r = new WeakMap(),
        o = new WeakMap();
      function s(t) {
        const a = t.target,
          c = r.get(a);
        null !== c.index && e.remove(c.index);
        for (const t in c.attributes) e.remove(c.attributes[t]);
        a.removeEventListener("dispose", s), r.delete(a);
        const l = o.get(c);
        l && (e.remove(l), o.delete(c)),
          i.releaseStatesOfGeometry(a),
          !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
          n.memory.geometries--;
      }
      function a(t) {
        const n = [],
          i = t.index,
          r = t.attributes.position;
        let s = 0;
        if (null !== i) {
          const t = i.array;
          s = i.version;
          for (let e = 0, i = t.length; e < i; e += 3) {
            const i = t[e + 0],
              r = t[e + 1],
              o = t[e + 2];
            n.push(i, r, r, o, o, i);
          }
        } else {
          const t = r.array;
          s = r.version;
          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
            const t = e + 0,
              i = e + 1,
              r = e + 2;
            n.push(t, i, i, r, r, t);
          }
        }
        const a = new (oe(n) > 65535 ? ee : Qt)(n, 1);
        a.version = s;
        const c = o.get(t);
        c && e.remove(c), o.set(t, a);
      }
      return {
        get: function (t, e) {
          let i = r.get(e);
          return (
            i ||
            (e.addEventListener("dispose", s),
            e.isBufferGeometry
              ? (i = e)
              : e.isGeometry &&
                (void 0 === e._bufferGeometry &&
                  (e._bufferGeometry = new de().setFromObject(t)),
                (i = e._bufferGeometry)),
            r.set(e, i),
            n.memory.geometries++,
            i)
          );
        },
        update: function (t) {
          const n = t.attributes;
          for (const t in n) e.update(n[t], 34962);
          const i = t.morphAttributes;
          for (const t in i) {
            const n = i[t];
            for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
          }
        },
        getWireframeAttribute: function (t) {
          const e = o.get(t);
          if (e) {
            const n = t.index;
            null !== n && e.version < n.version && a(t);
          } else a(t);
          return o.get(t);
        },
      };
    }
    function dn(t, e, n, i) {
      const r = i.isWebGL2;
      let o, s, a;
      (this.setMode = function (t) {
        o = t;
      }),
        (this.setIndex = function (t) {
          (s = t.type), (a = t.bytesPerElement);
        }),
        (this.render = function (e, i) {
          t.drawElements(o, i, s, e * a), n.update(i, o);
        }),
        (this.renderInstances = function (i, c, l, u) {
          if (0 === u) return;
          let h, p;
          if (r) (h = t), (p = "drawElementsInstanced");
          else if (
            ((h = e.get("ANGLE_instanced_arrays")),
            (p = "drawElementsInstancedANGLE"),
            null === h)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          h[p](o, l, s, c * a, u), n.update(l, o, u);
        });
    }
    function fn(t) {
      const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          e.frame++,
            (e.calls = 0),
            (e.triangles = 0),
            (e.points = 0),
            (e.lines = 0);
        },
        update: function (t, n, i) {
          switch (((i = i || 1), e.calls++, n)) {
            case 4:
              e.triangles += i * (t / 3);
              break;
            case 1:
              e.lines += i * (t / 2);
              break;
            case 3:
              e.lines += i * (t - 1);
              break;
            case 2:
              e.lines += i * t;
              break;
            case 0:
              e.points += i * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }
    function mn(t, e) {
      return t[0] - e[0];
    }
    function gn(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function vn(t) {
      const e = {},
        n = new Float32Array(8),
        i = [];
      for (let t = 0; t < 8; t++) i[t] = [t, 0];
      return {
        update: function (r, o, s, a) {
          const c = r.morphTargetInfluences,
            l = void 0 === c ? 0 : c.length;
          let u = e[o.id];
          if (void 0 === u) {
            u = [];
            for (let t = 0; t < l; t++) u[t] = [t, 0];
            e[o.id] = u;
          }
          for (let t = 0; t < l; t++) {
            const e = u[t];
            (e[0] = t), (e[1] = c[t]);
          }
          u.sort(gn);
          for (let t = 0; t < 8; t++)
            t < l && u[t][1]
              ? ((i[t][0] = u[t][0]), (i[t][1] = u[t][1]))
              : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
          i.sort(mn);
          const h = s.morphTargets && o.morphAttributes.position,
            p = s.morphNormals && o.morphAttributes.normal;
          let d = 0;
          for (let t = 0; t < 8; t++) {
            const e = i[t],
              r = e[0],
              s = e[1];
            r !== Number.MAX_SAFE_INTEGER && s
              ? (h &&
                  o.getAttribute("morphTarget" + t) !== h[r] &&
                  o.setAttribute("morphTarget" + t, h[r]),
                p &&
                  o.getAttribute("morphNormal" + t) !== p[r] &&
                  o.setAttribute("morphNormal" + t, p[r]),
                (n[t] = s),
                (d += s))
              : (h &&
                  void 0 !== o.getAttribute("morphTarget" + t) &&
                  o.deleteAttribute("morphTarget" + t),
                p &&
                  void 0 !== o.getAttribute("morphNormal" + t) &&
                  o.deleteAttribute("morphNormal" + t),
                (n[t] = 0));
          }
          const f = o.morphTargetsRelative ? 1 : 1 - d;
          a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
            a.getUniforms().setValue(t, "morphTargetInfluences", n);
        },
      };
    }
    function yn(t, e, n, i) {
      let r = new WeakMap();
      return {
        update: function (t) {
          const o = i.render.frame,
            s = t.geometry,
            a = e.get(t, s);
          return (
            r.get(a) !== o &&
              (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)),
            t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
            a
          );
        },
        dispose: function () {
          r = new WeakMap();
        },
      };
    }
    function xn(t, e, n, i, r, o, s, a, c, l) {
      (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : 301),
        (s = void 0 !== s ? s : 1022),
        f.call(this, t, e, n, i, r, o, s, a, c, l),
        (this.flipY = !1);
    }
    function bn(t, e, n, i) {
      f.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: i || 1,
        }),
        (this.magFilter = 1003),
        (this.minFilter = 1003),
        (this.wrapR = 1001),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    function wn(t, e, n, i) {
      f.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: i || 1,
        }),
        (this.magFilter = 1003),
        (this.minFilter = 1003),
        (this.wrapR = 1001),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    (on.physical = {
      uniforms: He([
        on.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new l(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: new zt(0) },
          transparency: { value: 0 },
        },
      ]),
      vertexShader: rn.meshphysical_vert,
      fragmentShader: rn.meshphysical_frag,
    }),
      (xn.prototype = Object.create(f.prototype)),
      (xn.prototype.constructor = xn),
      (xn.prototype.isCubeTexture = !0),
      Object.defineProperty(xn.prototype, "images", {
        get: function () {
          return this.image;
        },
        set: function (t) {
          this.image = t;
        },
      }),
      (bn.prototype = Object.create(f.prototype)),
      (bn.prototype.constructor = bn),
      (bn.prototype.isDataTexture2DArray = !0),
      (wn.prototype = Object.create(f.prototype)),
      (wn.prototype.constructor = wn),
      (wn.prototype.isDataTexture3D = !0);
    const _n = new f(),
      Mn = new bn(),
      Sn = new wn(),
      Tn = new xn(),
      En = [],
      An = [],
      Ln = new Float32Array(16),
      Rn = new Float32Array(9),
      Pn = new Float32Array(4);
    function Cn(t, e, n) {
      const i = t[0];
      if (i <= 0 || i > 0) return t;
      let r = e * n,
        o = En[r];
      if ((void 0 === o && ((o = new Float32Array(r)), (En[r] = o)), 0 !== e)) {
        i.toArray(o, 0);
        for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(o, r);
      }
      return o;
    }
    function On(t, e) {
      if (t.length !== e.length) return !1;
      for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function In(t, e) {
      for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
    }
    function Dn(t, e) {
      let n = An[e];
      void 0 === n && ((n = new Int32Array(e)), (An[e] = n));
      for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
      return n;
    }
    function Nn(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
    }
    function kn(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (On(n, e)) return;
        t.uniform2fv(this.addr, e), In(n, e);
      }
    }
    function Un(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else if (void 0 !== e.r)
        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (n[0] = e.r),
          (n[1] = e.g),
          (n[2] = e.b));
      else {
        if (On(n, e)) return;
        t.uniform3fv(this.addr, e), In(n, e);
      }
    }
    function zn(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (On(n, e)) return;
        t.uniform4fv(this.addr, e), In(n, e);
      }
    }
    function Bn(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (On(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), In(n, e);
      } else {
        if (On(n, i)) return;
        Pn.set(i), t.uniformMatrix2fv(this.addr, !1, Pn), In(n, i);
      }
    }
    function Fn(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (On(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), In(n, e);
      } else {
        if (On(n, i)) return;
        Rn.set(i), t.uniformMatrix3fv(this.addr, !1, Rn), In(n, i);
      }
    }
    function Hn(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (On(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), In(n, e);
      } else {
        if (On(n, i)) return;
        Ln.set(i), t.uniformMatrix4fv(this.addr, !1, Ln), In(n, i);
      }
    }
    function Gn(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTexture2D(e || _n, r);
    }
    function jn(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(e || Mn, r);
    }
    function Vn(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(e || Sn, r);
    }
    function Wn(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTextureCube(e || Tn, r);
    }
    function qn(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
    }
    function Xn(t, e) {
      const n = this.cache;
      On(n, e) || (t.uniform2iv(this.addr, e), In(n, e));
    }
    function Yn(t, e) {
      const n = this.cache;
      On(n, e) || (t.uniform3iv(this.addr, e), In(n, e));
    }
    function Zn(t, e) {
      const n = this.cache;
      On(n, e) || (t.uniform4iv(this.addr, e), In(n, e));
    }
    function Jn(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
    }
    function Kn(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function $n(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function Qn(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function ti(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function ei(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function ni(t, e) {
      const n = Cn(e, this.size, 2);
      t.uniform2fv(this.addr, n);
    }
    function ii(t, e) {
      const n = Cn(e, this.size, 3);
      t.uniform3fv(this.addr, n);
    }
    function ri(t, e) {
      const n = Cn(e, this.size, 4);
      t.uniform4fv(this.addr, n);
    }
    function oi(t, e) {
      const n = Cn(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n);
    }
    function si(t, e) {
      const n = Cn(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n);
    }
    function ai(t, e) {
      const n = Cn(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n);
    }
    function ci(t, e, n) {
      const i = e.length,
        r = Dn(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || _n, r[t]);
    }
    function li(t, e, n) {
      const i = e.length,
        r = Dn(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Tn, r[t]);
    }
    function ui(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Nn;
            case 35664:
              return kn;
            case 35665:
              return Un;
            case 35666:
              return zn;
            case 35674:
              return Bn;
            case 35675:
              return Fn;
            case 35676:
              return Hn;
            case 5124:
            case 35670:
              return qn;
            case 35667:
            case 35671:
              return Xn;
            case 35668:
            case 35672:
              return Yn;
            case 35669:
            case 35673:
              return Zn;
            case 5125:
              return Jn;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Gn;
            case 35679:
            case 36299:
            case 36307:
              return Vn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Wn;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return jn;
          }
        })(e.type));
    }
    function hi(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Kn;
            case 35664:
              return ni;
            case 35665:
              return ii;
            case 35666:
              return ri;
            case 35674:
              return oi;
            case 35675:
              return si;
            case 35676:
              return ai;
            case 5124:
            case 35670:
              return $n;
            case 35667:
            case 35671:
              return Qn;
            case 35668:
            case 35672:
              return ti;
            case 35669:
            case 35673:
              return ei;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return ci;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return li;
          }
        })(e.type));
    }
    function pi(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    (hi.prototype.updateCache = function (t) {
      let e = this.cache;
      t instanceof Float32Array &&
        e.length !== t.length &&
        (this.cache = new Float32Array(t.length)),
        In(e, t);
    }),
      (pi.prototype.setValue = function (t, e, n) {
        const i = this.seq;
        for (let r = 0, o = i.length; r !== o; ++r) {
          const o = i[r];
          o.setValue(t, e[o.id], n);
        }
      });
    const di = /([\w\d_]+)(\])?(\[|\.)?/g;
    function fi(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function mi(t, e, n) {
      const i = t.name,
        r = i.length;
      for (di.lastIndex = 0; ; ) {
        const o = di.exec(i),
          s = di.lastIndex;
        let a = o[1],
          c = "]" === o[2],
          l = o[3];
        if ((c && (a |= 0), void 0 === l || ("[" === l && s + 2 === r))) {
          fi(n, void 0 === l ? new ui(a, t, e) : new hi(a, t, e));
          break;
        }
        {
          let t = n.map[a];
          void 0 === t && ((t = new pi(a)), fi(n, t)), (n = t);
        }
      }
    }
    function gi(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, 35718);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        mi(n, t.getUniformLocation(e, n.name), this);
      }
    }
    function vi(t, e, n) {
      const i = t.createShader(e);
      return t.shaderSource(i, n), t.compileShader(i), i;
    }
    (gi.prototype.setValue = function (t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }),
      (gi.prototype.setOptional = function (t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i);
      }),
      (gi.upload = function (t, e, n, i) {
        for (let r = 0, o = e.length; r !== o; ++r) {
          const o = e[r],
            s = n[o.id];
          !1 !== s.needsUpdate && o.setValue(t, s.value, i);
        }
      }),
      (gi.seqWithValue = function (t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
          const r = t[i];
          r.id in e && n.push(r);
        }
        return n;
      });
    let yi = 0;
    function xi(t) {
      switch (t) {
        case 3e3:
          return ["Linear", "( value )"];
        case 3001:
          return ["sRGB", "( value )"];
        case 3002:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case 3007:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
          return ["LogLuv", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
          );
      }
    }
    function bi(t, e, n) {
      const i = t.getShaderParameter(e, 35713),
        r = t.getShaderInfoLog(e).trim();
      if (i && "" === r) return "";
      return (
        "THREE.WebGLShader: gl.getShaderInfoLog() " +
        n +
        "\n" +
        r +
        (function (t) {
          const e = t.split("\n");
          for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
          return e.join("\n");
        })(t.getShaderSource(e))
      );
    }
    function wi(t, e) {
      const n = xi(e);
      return (
        "vec4 " +
        t +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function _i(t, e) {
      const n = xi(e);
      return (
        "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }
    function Mi(t, e) {
      let n;
      switch (e) {
        case 1:
          n = "Linear";
          break;
        case 2:
          n = "Reinhard";
          break;
        case 3:
          n = "OptimizedCineon";
          break;
        case 4:
          n = "ACESFilmic";
          break;
        case 5:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            (n = "Linear");
      }
      return (
        "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function Si(t) {
      return "" !== t;
    }
    function Ti(t, e) {
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function Ei(t, e) {
      return t
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          e.numClippingPlanes - e.numClipIntersection
        );
    }
    const Ai = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Li(t) {
      return t.replace(Ai, Ri);
    }
    function Ri(t, e) {
      const n = rn[e];
      if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
      return Li(n);
    }
    const Pi =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      Ci =
        /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
    function Oi(t) {
      return t.replace(Ci, Di).replace(Pi, Ii);
    }
    function Ii(t, e, n, i) {
      return (
        console.warn(
          "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        Di(t, e, n, i)
      );
    }
    function Di(t, e, n, i) {
      let r = "";
      for (let t = parseInt(e); t < parseInt(n); t++)
        r += i
          .replace(/\[ i \]/g, "[ " + t + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, t);
      return r;
    }
    function Ni(t) {
      let e =
        "precision " +
        t.precision +
        " float;\nprecision " +
        t.precision +
        " int;";
      return (
        "highp" === t.precision
          ? (e += "\n#define HIGH_PRECISION")
          : "mediump" === t.precision
          ? (e += "\n#define MEDIUM_PRECISION")
          : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
      );
    }
    function ki(t, e, n, i) {
      const r = t.getContext(),
        o = n.defines;
      let s = n.vertexShader,
        a = n.fragmentShader;
      const c = (function (t) {
          let e = "SHADOWMAP_TYPE_BASIC";
          return (
            1 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF")
              : 2 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        })(n),
        l = (function (t) {
          let e = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (t.envMapMode) {
              case 301:
              case 302:
                e = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
              case 303:
              case 304:
                e = "ENVMAP_TYPE_EQUIREC";
            }
          return e;
        })(n),
        u = (function (t) {
          let e = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (t.envMapMode) {
              case 302:
              case 304:
                e = "ENVMAP_MODE_REFRACTION";
            }
          return e;
        })(n),
        h = (function (t) {
          let e = "ENVMAP_BLENDING_NONE";
          if (t.envMap)
            switch (t.combine) {
              case 0:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                e = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                e = "ENVMAP_BLENDING_ADD";
            }
          return e;
        })(n),
        p = t.gammaFactor > 0 ? t.gammaFactor : 1,
        d = n.isWebGL2
          ? ""
          : (function (t) {
              return [
                t.extensionDerivatives ||
                t.envMapCubeUV ||
                t.bumpMap ||
                t.tangentSpaceNormalMap ||
                t.clearcoatNormalMap ||
                t.flatShading ||
                "physical" === t.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                t.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (t.extensionShaderTextureLOD || t.envMap) &&
                t.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(Si)
                .join("\n");
            })(n),
        f = (function (t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            !1 !== i && e.push("#define " + n + " " + i);
          }
          return e.join("\n");
        })(o),
        m = r.createProgram();
      let g, v;
      if (
        (n.isRawShaderMaterial
          ? ((g = [f].filter(Si).join("\n")),
            g.length > 0 && (g += "\n"),
            (v = [d, f].filter(Si).join("\n")),
            v.length > 0 && (v += "\n"))
          : ((g = [
              Ni(n),
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + p,
              "#define MAX_BONES " + n.maxBones,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + u : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.useVertexTexture ? "#define BONE_TEXTURE" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              " attribute mat4 instanceMatrix;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#ifdef USE_COLOR",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Si)
              .join("\n")),
            (v = [
              d,
              Ni(n),
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.alphaTest
                ? "#define ALPHATEST " +
                  n.alphaTest +
                  (n.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + p,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + l : "",
              n.envMap ? "#define " + u : "",
              n.envMap ? "#define " + h : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (n.extensionShaderTextureLOD || n.envMap) &&
              n.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== n.toneMapping ? rn.tonemapping_pars_fragment : "",
              0 !== n.toneMapping ? Mi("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              rn.encodings_pars_fragment,
              n.map ? wi("mapTexelToLinear", n.mapEncoding) : "",
              n.matcap ? wi("matcapTexelToLinear", n.matcapEncoding) : "",
              n.envMap ? wi("envMapTexelToLinear", n.envMapEncoding) : "",
              n.emissiveMap
                ? wi("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                : "",
              n.lightMap ? wi("lightMapTexelToLinear", n.lightMapEncoding) : "",
              _i("linearToOutputTexel", n.outputEncoding),
              n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
              "\n",
            ]
              .filter(Si)
              .join("\n"))),
        (s = Li(s)),
        (s = Ti(s, n)),
        (s = Ei(s, n)),
        (a = Li(a)),
        (a = Ti(a, n)),
        (a = Ei(a, n)),
        (s = Oi(s)),
        (a = Oi(a)),
        n.isWebGL2 && !n.isRawShaderMaterial)
      ) {
        let t = !1;
        const e = /^\s*#version\s+300\s+es\s*\n/;
        n.isShaderMaterial &&
          null !== s.match(e) &&
          null !== a.match(e) &&
          ((t = !0), (s = s.replace(e, "")), (a = a.replace(e, ""))),
          (g =
            [
              "#version 300 es\n",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            g),
          (v =
            [
              "#version 300 es\n",
              "#define varying in",
              t ? "" : "out highp vec4 pc_fragColor;",
              t ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            v);
      }
      const y = v + a,
        x = vi(r, 35633, g + s),
        b = vi(r, 35632, y);
      if (
        (r.attachShader(m, x),
        r.attachShader(m, b),
        void 0 !== n.index0AttributeName
          ? r.bindAttribLocation(m, 0, n.index0AttributeName)
          : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
        r.linkProgram(m),
        t.debug.checkShaderErrors)
      ) {
        const t = r.getProgramInfoLog(m).trim(),
          e = r.getShaderInfoLog(x).trim(),
          n = r.getShaderInfoLog(b).trim();
        let i = !0,
          o = !0;
        if (!1 === r.getProgramParameter(m, 35714)) {
          i = !1;
          const e = bi(r, x, "vertex"),
            n = bi(r, b, "fragment");
          console.error(
            "THREE.WebGLProgram: shader error: ",
            r.getError(),
            "35715",
            r.getProgramParameter(m, 35715),
            "gl.getProgramInfoLog",
            t,
            e,
            n
          );
        } else
          "" !== t
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
            : ("" !== e && "" !== n) || (o = !1);
        o &&
          (this.diagnostics = {
            runnable: i,
            programLog: t,
            vertexShader: { log: e, prefix: g },
            fragmentShader: { log: n, prefix: v },
          });
      }
      let w, _;
      return (
        r.deleteShader(x),
        r.deleteShader(b),
        (this.getUniforms = function () {
          return void 0 === w && (w = new gi(r, m)), w;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === _ &&
              (_ = (function (t, e) {
                const n = {},
                  i = t.getProgramParameter(e, 35721);
                for (let r = 0; r < i; r++) {
                  const i = t.getActiveAttrib(e, r).name;
                  n[i] = t.getAttribLocation(e, i);
                }
                return n;
              })(r, m)),
            _
          );
        }),
        (this.destroy = function () {
          i.releaseStatesOfProgram(this),
            r.deleteProgram(m),
            (this.program = void 0);
        }),
        (this.name = n.shaderName),
        (this.id = yi++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = m),
        (this.vertexShader = x),
        (this.fragmentShader = b),
        this
      );
    }
    function Ui(t, e, n, i) {
      const r = [],
        o = n.isWebGL2,
        s = n.logarithmicDepthBuffer,
        a = n.floatVertexTextures,
        c = n.maxVertexUniforms,
        l = n.vertexTextures;
      let u = n.precision;
      const h = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        p = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoatMap",
          "clearcoatRoughnessMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "maxMorphTargets",
          "maxMorphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "sheen",
        ];
      function d(t) {
        let e;
        return (
          t
            ? t.isTexture
              ? (e = t.encoding)
              : t.isWebGLRenderTarget &&
                (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (e = t.texture.encoding))
            : (e = 3e3),
          e
        );
      }
      return {
        getParameters: function (i, r, p, f, m, g, v) {
          const y = f.fog,
            x = i.isMeshStandardMaterial ? f.environment : null,
            b = i.envMap || x,
            w = h[i.type],
            _ = v.isSkinnedMesh
              ? (function (t) {
                  const e = t.skeleton.bones;
                  if (a) return 1024;
                  {
                    const t = c,
                      n = Math.floor((t - 20) / 4),
                      i = Math.min(n, e.length);
                    return i < e.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            e.length +
                            " bones. This GPU supports " +
                            i +
                            "."
                        ),
                        0)
                      : i;
                  }
                })(v)
              : 0;
          null !== i.precision &&
            ((u = n.getMaxPrecision(i.precision)),
            u !== i.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                i.precision,
                "not supported, using",
                u,
                "instead."
              ));
          const M = (function (t, e) {
            let n;
            if (e) {
              const i = on[e];
              n = {
                name: t.name || t.type,
                uniforms: Ge.clone(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
              };
            } else
              n = {
                name: t.name || t.type,
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader,
              };
            return n;
          })(i, w);
          i.onBeforeCompile(M, t);
          const S = t.getRenderTarget();
          return {
            isWebGL2: o,
            shaderID: w,
            shaderName: M.name,
            uniforms: M.uniforms,
            vertexShader: M.vertexShader,
            fragmentShader: M.fragmentShader,
            defines: i.defines,
            isRawShaderMaterial: i.isRawShaderMaterial,
            isShaderMaterial: i.isShaderMaterial,
            precision: u,
            instancing: !0 === v.isInstancedMesh,
            supportsVertexTextures: l,
            outputEncoding: null !== S ? d(S.texture) : t.outputEncoding,
            map: !!i.map,
            mapEncoding: d(i.map),
            matcap: !!i.matcap,
            matcapEncoding: d(i.matcap),
            envMap: !!b,
            envMapMode: b && b.mapping,
            envMapEncoding: d(b),
            envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
            lightMap: !!i.lightMap,
            lightMapEncoding: d(i.lightMap),
            aoMap: !!i.aoMap,
            emissiveMap: !!i.emissiveMap,
            emissiveMapEncoding: d(i.emissiveMap),
            bumpMap: !!i.bumpMap,
            normalMap: !!i.normalMap,
            objectSpaceNormalMap: 1 === i.normalMapType,
            tangentSpaceNormalMap: 0 === i.normalMapType,
            clearcoatMap: !!i.clearcoatMap,
            clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
            clearcoatNormalMap: !!i.clearcoatNormalMap,
            displacementMap: !!i.displacementMap,
            roughnessMap: !!i.roughnessMap,
            metalnessMap: !!i.metalnessMap,
            specularMap: !!i.specularMap,
            alphaMap: !!i.alphaMap,
            gradientMap: !!i.gradientMap,
            sheen: !!i.sheen,
            combine: i.combine,
            vertexTangents: i.normalMap && i.vertexTangents,
            vertexColors: i.vertexColors,
            vertexUvs: !!(
              i.map ||
              i.bumpMap ||
              i.normalMap ||
              i.specularMap ||
              i.alphaMap ||
              i.emissiveMap ||
              i.roughnessMap ||
              i.metalnessMap ||
              i.clearcoatMap ||
              i.clearcoatRoughnessMap ||
              i.clearcoatNormalMap ||
              i.displacementMap
            ),
            uvsVertexOnly: !(
              i.map ||
              i.bumpMap ||
              i.normalMap ||
              i.specularMap ||
              i.alphaMap ||
              i.emissiveMap ||
              i.roughnessMap ||
              i.metalnessMap ||
              i.clearcoatNormalMap ||
              !i.displacementMap
            ),
            fog: !!y,
            useFog: i.fog,
            fogExp2: y && y.isFogExp2,
            flatShading: i.flatShading,
            sizeAttenuation: i.sizeAttenuation,
            logarithmicDepthBuffer: s,
            skinning: i.skinning && _ > 0,
            maxBones: _,
            useVertexTexture: a,
            morphTargets: i.morphTargets,
            morphNormals: i.morphNormals,
            maxMorphTargets: t.maxMorphTargets,
            maxMorphNormals: t.maxMorphNormals,
            numDirLights: r.directional.length,
            numPointLights: r.point.length,
            numSpotLights: r.spot.length,
            numRectAreaLights: r.rectArea.length,
            numHemiLights: r.hemi.length,
            numDirLightShadows: r.directionalShadowMap.length,
            numPointLightShadows: r.pointShadowMap.length,
            numSpotLightShadows: r.spotShadowMap.length,
            numClippingPlanes: m,
            numClipIntersection: g,
            dithering: i.dithering,
            shadowMapEnabled: t.shadowMap.enabled && p.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: i.toneMapped ? t.toneMapping : 0,
            physicallyCorrectLights: t.physicallyCorrectLights,
            premultipliedAlpha: i.premultipliedAlpha,
            alphaTest: i.alphaTest,
            doubleSided: 2 === i.side,
            flipSided: 1 === i.side,
            depthPacking: void 0 !== i.depthPacking && i.depthPacking,
            index0AttributeName: i.index0AttributeName,
            extensionDerivatives: i.extensions && i.extensions.derivatives,
            extensionFragDepth: i.extensions && i.extensions.fragDepth,
            extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
            extensionShaderTextureLOD:
              i.extensions && i.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"),
            rendererExtensionDrawBuffers:
              o || null !== e.get("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              o || null !== e.get("EXT_shader_texture_lod"),
            customProgramCacheKey: i.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (e) {
          const n = [];
          if (
            (e.shaderID
              ? n.push(e.shaderID)
              : (n.push(e.fragmentShader), n.push(e.vertexShader)),
            void 0 !== e.defines)
          )
            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
          if (void 0 === e.isRawShaderMaterial) {
            for (let t = 0; t < p.length; t++) n.push(e[p[t]]);
            n.push(t.outputEncoding), n.push(t.gammaFactor);
          }
          return n.push(e.customProgramCacheKey), n.join();
        },
        acquireProgram: function (e, n) {
          let o;
          for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            if (e.cacheKey === n) {
              (o = e), ++o.usedTimes;
              break;
            }
          }
          return void 0 === o && ((o = new ki(t, n, e, i)), r.push(o)), o;
        },
        releaseProgram: function (t) {
          if (0 == --t.usedTimes) {
            const e = r.indexOf(t);
            (r[e] = r[r.length - 1]), r.pop(), t.destroy();
          }
        },
        programs: r,
      };
    }
    function zi() {
      let t = new WeakMap();
      return {
        get: function (e) {
          let n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, n, i) {
          t.get(e)[n] = i;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Bi(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.program !== e.program
        ? t.program.id - e.program.id
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function Fi(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function Hi() {
      const t = [];
      let e = 0;
      const n = [],
        i = [],
        r = { id: -1 };
      function o(n, i, o, s, a, c) {
        let l = t[e];
        return (
          void 0 === l
            ? ((l = {
                id: n.id,
                object: n,
                geometry: i,
                material: o,
                program: o.program || r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: a,
                group: c,
              }),
              (t[e] = l))
            : ((l.id = n.id),
              (l.object = n),
              (l.geometry = i),
              (l.material = o),
              (l.program = o.program || r),
              (l.groupOrder = s),
              (l.renderOrder = n.renderOrder),
              (l.z = a),
              (l.group = c)),
          e++,
          l
        );
      }
      return {
        opaque: n,
        transparent: i,
        init: function () {
          (e = 0), (n.length = 0), (i.length = 0);
        },
        push: function (t, e, r, s, a, c) {
          const l = o(t, e, r, s, a, c);
          (!0 === r.transparent ? i : n).push(l);
        },
        unshift: function (t, e, r, s, a, c) {
          const l = o(t, e, r, s, a, c);
          (!0 === r.transparent ? i : n).unshift(l);
        },
        finish: function () {
          for (let n = e, i = t.length; n < i; n++) {
            const e = t[n];
            if (null === e.id) break;
            (e.id = null),
              (e.object = null),
              (e.geometry = null),
              (e.material = null),
              (e.program = null),
              (e.group = null);
          }
        },
        sort: function (t, e) {
          n.length > 1 && n.sort(t || Bi), i.length > 1 && i.sort(e || Fi);
        },
      };
    }
    function Gi() {
      let t = new WeakMap();
      function e(n) {
        const i = n.target;
        i.removeEventListener("dispose", e), t.delete(i);
      }
      return {
        get: function (n, i) {
          const r = t.get(n);
          let o;
          return (
            void 0 === r
              ? ((o = new Hi()),
                t.set(n, new WeakMap()),
                t.get(n).set(i, o),
                n.addEventListener("dispose", e))
              : ((o = r.get(i)), void 0 === o && ((o = new Hi()), r.set(i, o))),
            o
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function ji() {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
              n = { direction: new w(), color: new zt() };
              break;
            case "SpotLight":
              n = {
                position: new w(),
                direction: new w(),
                color: new zt(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = { position: new w(), color: new zt(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              n = {
                direction: new w(),
                skyColor: new zt(),
                groundColor: new zt(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new zt(),
                position: new w(),
                halfWidth: new w(),
                halfHeight: new w(),
              };
          }
          return (t[e.id] = n), n;
        },
      };
    }
    let Vi = 0;
    function Wi(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
    }
    function qi() {
      const t = new ji(),
        e = (function () {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new l(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new l(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        })(),
        n = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let t = 0; t < 9; t++) n.probe.push(new w());
      const i = new w(),
        r = new R(),
        o = new R();
      return {
        setup: function (s, a, c) {
          let l = 0,
            u = 0,
            h = 0;
          for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
          let p = 0,
            d = 0,
            f = 0,
            m = 0,
            g = 0,
            v = 0,
            y = 0,
            x = 0;
          const b = c.matrixWorldInverse;
          s.sort(Wi);
          for (let a = 0, c = s.length; a < c; a++) {
            const c = s[a],
              w = c.color,
              _ = c.intensity,
              M = c.distance,
              S = c.shadow && c.shadow.map ? c.shadow.map.texture : null;
            if (c.isAmbientLight)
              (l += w.r * _), (u += w.g * _), (h += w.b * _);
            else if (c.isLightProbe)
              for (let t = 0; t < 9; t++)
                n.probe[t].addScaledVector(c.sh.coefficients[t], _);
            else if (c.isDirectionalLight) {
              const r = t.get(c);
              if (
                (r.color.copy(c.color).multiplyScalar(c.intensity),
                r.direction.setFromMatrixPosition(c.matrixWorld),
                i.setFromMatrixPosition(c.target.matrixWorld),
                r.direction.sub(i),
                r.direction.transformDirection(b),
                c.castShadow)
              ) {
                const t = c.shadow,
                  i = e.get(c);
                (i.shadowBias = t.bias),
                  (i.shadowNormalBias = t.normalBias),
                  (i.shadowRadius = t.radius),
                  (i.shadowMapSize = t.mapSize),
                  (n.directionalShadow[p] = i),
                  (n.directionalShadowMap[p] = S),
                  (n.directionalShadowMatrix[p] = c.shadow.matrix),
                  v++;
              }
              (n.directional[p] = r), p++;
            } else if (c.isSpotLight) {
              const r = t.get(c);
              if (
                (r.position.setFromMatrixPosition(c.matrixWorld),
                r.position.applyMatrix4(b),
                r.color.copy(w).multiplyScalar(_),
                (r.distance = M),
                r.direction.setFromMatrixPosition(c.matrixWorld),
                i.setFromMatrixPosition(c.target.matrixWorld),
                r.direction.sub(i),
                r.direction.transformDirection(b),
                (r.coneCos = Math.cos(c.angle)),
                (r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra))),
                (r.decay = c.decay),
                c.castShadow)
              ) {
                const t = c.shadow,
                  i = e.get(c);
                (i.shadowBias = t.bias),
                  (i.shadowNormalBias = t.normalBias),
                  (i.shadowRadius = t.radius),
                  (i.shadowMapSize = t.mapSize),
                  (n.spotShadow[f] = i),
                  (n.spotShadowMap[f] = S),
                  (n.spotShadowMatrix[f] = c.shadow.matrix),
                  x++;
              }
              (n.spot[f] = r), f++;
            } else if (c.isRectAreaLight) {
              const e = t.get(c);
              e.color.copy(w).multiplyScalar(_),
                e.position.setFromMatrixPosition(c.matrixWorld),
                e.position.applyMatrix4(b),
                o.identity(),
                r.copy(c.matrixWorld),
                r.premultiply(b),
                o.extractRotation(r),
                e.halfWidth.set(0.5 * c.width, 0, 0),
                e.halfHeight.set(0, 0.5 * c.height, 0),
                e.halfWidth.applyMatrix4(o),
                e.halfHeight.applyMatrix4(o),
                (n.rectArea[m] = e),
                m++;
            } else if (c.isPointLight) {
              const i = t.get(c);
              if (
                (i.position.setFromMatrixPosition(c.matrixWorld),
                i.position.applyMatrix4(b),
                i.color.copy(c.color).multiplyScalar(c.intensity),
                (i.distance = c.distance),
                (i.decay = c.decay),
                c.castShadow)
              ) {
                const t = c.shadow,
                  i = e.get(c);
                (i.shadowBias = t.bias),
                  (i.shadowNormalBias = t.normalBias),
                  (i.shadowRadius = t.radius),
                  (i.shadowMapSize = t.mapSize),
                  (i.shadowCameraNear = t.camera.near),
                  (i.shadowCameraFar = t.camera.far),
                  (n.pointShadow[d] = i),
                  (n.pointShadowMap[d] = S),
                  (n.pointShadowMatrix[d] = c.shadow.matrix),
                  y++;
              }
              (n.point[d] = i), d++;
            } else if (c.isHemisphereLight) {
              const e = t.get(c);
              e.direction.setFromMatrixPosition(c.matrixWorld),
                e.direction.transformDirection(b),
                e.direction.normalize(),
                e.skyColor.copy(c.color).multiplyScalar(_),
                e.groundColor.copy(c.groundColor).multiplyScalar(_),
                (n.hemi[g] = e),
                g++;
            }
          }
          (n.ambient[0] = l), (n.ambient[1] = u), (n.ambient[2] = h);
          const w = n.hash;
          (w.directionalLength === p &&
            w.pointLength === d &&
            w.spotLength === f &&
            w.rectAreaLength === m &&
            w.hemiLength === g &&
            w.numDirectionalShadows === v &&
            w.numPointShadows === y &&
            w.numSpotShadows === x) ||
            ((n.directional.length = p),
            (n.spot.length = f),
            (n.rectArea.length = m),
            (n.point.length = d),
            (n.hemi.length = g),
            (n.directionalShadow.length = v),
            (n.directionalShadowMap.length = v),
            (n.pointShadow.length = y),
            (n.pointShadowMap.length = y),
            (n.spotShadow.length = x),
            (n.spotShadowMap.length = x),
            (n.directionalShadowMatrix.length = v),
            (n.pointShadowMatrix.length = y),
            (n.spotShadowMatrix.length = x),
            (w.directionalLength = p),
            (w.pointLength = d),
            (w.spotLength = f),
            (w.rectAreaLength = m),
            (w.hemiLength = g),
            (w.numDirectionalShadows = v),
            (w.numPointShadows = y),
            (w.numSpotShadows = x),
            (n.version = Vi++));
        },
        state: n,
      };
    }
    function Xi() {
      const t = new qi(),
        e = [],
        n = [];
      return {
        init: function () {
          (e.length = 0), (n.length = 0);
        },
        state: { lightsArray: e, shadowsArray: n, lights: t },
        setupLights: function (i) {
          t.setup(e, n, i);
        },
        pushLight: function (t) {
          e.push(t);
        },
        pushShadow: function (t) {
          n.push(t);
        },
      };
    }
    function Yi() {
      let t = new WeakMap();
      function e(n) {
        const i = n.target;
        i.removeEventListener("dispose", e), t.delete(i);
      }
      return {
        get: function (n, i) {
          let r;
          return (
            !1 === t.has(n)
              ? ((r = new Xi()),
                t.set(n, new WeakMap()),
                t.get(n).set(i, r),
                n.addEventListener("dispose", e))
              : !1 === t.get(n).has(i)
              ? ((r = new Xi()), t.get(n).set(i, r))
              : (r = t.get(n).get(i)),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Zi(t) {
      Vt.call(this),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        this.setValues(t);
    }
    function Ji(t) {
      Vt.call(this),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new w()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.fog = !1),
        this.setValues(t);
    }
    (Zi.prototype = Object.create(Vt.prototype)),
      (Zi.prototype.constructor = Zi),
      (Zi.prototype.isMeshDepthMaterial = !0),
      (Zi.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          (this.depthPacking = t.depthPacking),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }),
      (Ji.prototype = Object.create(Vt.prototype)),
      (Ji.prototype.constructor = Ji),
      (Ji.prototype.isMeshDistanceMaterial = !0),
      (Ji.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      });
    function Ki(t, e, n) {
      let i = new Ke();
      const r = new l(),
        o = new l(),
        s = new m(),
        a = [],
        c = [],
        u = {},
        h = { 0: 1, 1: 0, 2: 2 },
        p = new je({
          defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new l() },
            radius: { value: 4 },
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        }),
        d = p.clone();
      d.defines.HORIZONAL_PASS = 1;
      const f = new de();
      f.setAttribute(
        "position",
        new Yt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const v = new Ce(f, p),
        y = this;
      function x(n, i) {
        const r = e.update(v);
        (p.uniforms.shadow_pass.value = n.map.texture),
          (p.uniforms.resolution.value = n.mapSize),
          (p.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.mapPass),
          t.clear(),
          t.renderBufferDirect(i, null, r, p, v, null),
          (d.uniforms.shadow_pass.value = n.mapPass.texture),
          (d.uniforms.resolution.value = n.mapSize),
          (d.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.map),
          t.clear(),
          t.renderBufferDirect(i, null, r, d, v, null);
      }
      function b(t, e, n) {
        const i = (t << 0) | (e << 1) | (n << 2);
        let r = a[i];
        return (
          void 0 === r &&
            ((r = new Zi({ depthPacking: 3201, morphTargets: t, skinning: e })),
            (a[i] = r)),
          r
        );
      }
      function w(t, e, n) {
        const i = (t << 0) | (e << 1) | (n << 2);
        let r = c[i];
        return (
          void 0 === r &&
            ((r = new Ji({ morphTargets: t, skinning: e })), (c[i] = r)),
          r
        );
      }
      function _(e, n, i, r, o, s, a) {
        let c = null,
          l = b,
          p = e.customDepthMaterial;
        if (
          (!0 === r.isPointLight && ((l = w), (p = e.customDistanceMaterial)),
          void 0 === p)
        ) {
          let t = !1;
          !0 === i.morphTargets &&
            (t =
              n.morphAttributes &&
              n.morphAttributes.position &&
              n.morphAttributes.position.length > 0);
          let r = !1;
          !0 === e.isSkinnedMesh &&
            (!0 === i.skinning
              ? (r = !0)
              : console.warn(
                  "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                  e
                ));
          c = l(t, r, !0 === e.isInstancedMesh);
        } else c = p;
        if (
          t.localClippingEnabled &&
          !0 === i.clipShadows &&
          0 !== i.clippingPlanes.length
        ) {
          const t = c.uuid,
            e = i.uuid;
          let n = u[t];
          void 0 === n && ((n = {}), (u[t] = n));
          let r = n[e];
          void 0 === r && ((r = c.clone()), (n[e] = r)), (c = r);
        }
        return (
          (c.visible = i.visible),
          (c.wireframe = i.wireframe),
          (c.side =
            3 === a
              ? null !== i.shadowSide
                ? i.shadowSide
                : i.side
              : null !== i.shadowSide
              ? i.shadowSide
              : h[i.side]),
          (c.clipShadows = i.clipShadows),
          (c.clippingPlanes = i.clippingPlanes),
          (c.clipIntersection = i.clipIntersection),
          (c.wireframeLinewidth = i.wireframeLinewidth),
          (c.linewidth = i.linewidth),
          !0 === r.isPointLight &&
            !0 === c.isMeshDistanceMaterial &&
            (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
            (c.nearDistance = o),
            (c.farDistance = s)),
          c
        );
      }
      function M(n, r, o, s, a) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && 3 === a)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            o.matrixWorldInverse,
            n.matrixWorld
          );
          const i = e.update(n),
            r = n.material;
          if (Array.isArray(r)) {
            const e = i.groups;
            for (let c = 0, l = e.length; c < l; c++) {
              const l = e[c],
                u = r[l.materialIndex];
              if (u && u.visible) {
                const e = _(n, i, u, s, o.near, o.far, a);
                t.renderBufferDirect(o, null, i, e, n, l);
              }
            }
          } else if (r.visible) {
            const e = _(n, i, r, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, i, e, n, null);
          }
        }
        const c = n.children;
        for (let t = 0, e = c.length; t < e; t++) M(c[t], r, o, s, a);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1),
        (this.render = function (e, a, c) {
          if (!1 === y.enabled) return;
          if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
          if (0 === e.length) return;
          const l = t.getRenderTarget(),
            u = t.getActiveCubeFace(),
            h = t.getActiveMipmapLevel(),
            p = t.state;
          p.setBlending(0),
            p.buffers.color.setClear(1, 1, 1, 1),
            p.buffers.depth.setTest(!0),
            p.setScissorTest(!1);
          for (let l = 0, u = e.length; l < u; l++) {
            const u = e[l],
              h = u.shadow;
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
              continue;
            }
            r.copy(h.mapSize);
            const d = h.getFrameExtents();
            if (
              (r.multiply(d),
              o.copy(h.mapSize),
              (r.x > n || r.y > n) &&
                (r.x > n &&
                  ((o.x = Math.floor(n / d.x)),
                  (r.x = o.x * d.x),
                  (h.mapSize.x = o.x)),
                r.y > n &&
                  ((o.y = Math.floor(n / d.y)),
                  (r.y = o.y * d.y),
                  (h.mapSize.y = o.y))),
              null === h.map && !h.isPointLightShadow && 3 === this.type)
            ) {
              const t = { minFilter: 1006, magFilter: 1006, format: 1023 };
              (h.map = new g(r.x, r.y, t)),
                (h.map.texture.name = u.name + ".shadowMap"),
                (h.mapPass = new g(r.x, r.y, t)),
                h.camera.updateProjectionMatrix();
            }
            if (null === h.map) {
              const t = { minFilter: 1003, magFilter: 1003, format: 1023 };
              (h.map = new g(r.x, r.y, t)),
                (h.map.texture.name = u.name + ".shadowMap"),
                h.camera.updateProjectionMatrix();
            }
            t.setRenderTarget(h.map), t.clear();
            const f = h.getViewportCount();
            for (let t = 0; t < f; t++) {
              const e = h.getViewport(t);
              s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                p.viewport(s),
                h.updateMatrices(u, t),
                (i = h.getFrustum()),
                M(a, c, h.camera, u, this.type);
            }
            h.isPointLightShadow || 3 !== this.type || x(h, c),
              (h.needsUpdate = !1);
          }
          (y.needsUpdate = !1), t.setRenderTarget(l, u, h);
        });
    }
    function $i(t, e, n) {
      const i = n.isWebGL2;
      const r = new (function () {
          let e = !1;
          const n = new m();
          let i = null;
          const r = new m(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, o, s, a) {
              !0 === a && ((e *= s), (i *= s), (o *= s)),
                n.set(e, i, o, s),
                !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        })(),
        o = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (t) {
              t ? D(2929) : N(2929);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                if (e)
                  switch (e) {
                    case 0:
                      t.depthFunc(512);
                      break;
                    case 1:
                      t.depthFunc(519);
                      break;
                    case 2:
                      t.depthFunc(513);
                      break;
                    case 3:
                      t.depthFunc(515);
                      break;
                    case 4:
                      t.depthFunc(514);
                      break;
                    case 5:
                      t.depthFunc(518);
                      break;
                    case 6:
                      t.depthFunc(516);
                      break;
                    case 7:
                      t.depthFunc(517);
                      break;
                    default:
                      t.depthFunc(515);
                  }
                else t.depthFunc(515);
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            },
          };
        })(),
        s = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null,
            o = null,
            s = null,
            a = null,
            c = null,
            l = null;
          return {
            setTest: function (t) {
              e || (t ? D(2960) : N(2960));
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, s) {
              (i === e && r === n && o === s) ||
                (t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
            },
            setOp: function (e, n, i) {
              (s === e && a === n && c === i) ||
                (t.stencilOp(e, n, i), (s = e), (a = n), (c = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              l !== e && (t.clearStencil(e), (l = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (o = null),
                (s = null),
                (a = null),
                (c = null),
                (l = null);
            },
          };
        })();
      let a = {},
        c = null,
        l = null,
        u = null,
        h = null,
        p = null,
        d = null,
        f = null,
        g = null,
        v = null,
        y = !1,
        x = null,
        b = null,
        w = null,
        _ = null,
        M = null;
      const S = t.getParameter(35661);
      let T = !1,
        E = 0;
      const A = t.getParameter(7938);
      -1 !== A.indexOf("WebGL")
        ? ((E = parseFloat(/^WebGL\ ([0-9])/.exec(A)[1])), (T = E >= 1))
        : -1 !== A.indexOf("OpenGL ES") &&
          ((E = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(A)[1])), (T = E >= 2));
      let L = null,
        R = {};
      const P = new m(),
        C = new m();
      function O(e, n, i) {
        const r = new Uint8Array(4),
          o = t.createTexture();
        t.bindTexture(e, o),
          t.texParameteri(e, 10241, 9728),
          t.texParameteri(e, 10240, 9728);
        for (let e = 0; e < i; e++)
          t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return o;
      }
      const I = {};
      function D(e) {
        !0 !== a[e] && (t.enable(e), (a[e] = !0));
      }
      function N(e) {
        !1 !== a[e] && (t.disable(e), (a[e] = !1));
      }
      (I[3553] = O(3553, 3553, 1)),
        (I[34067] = O(34067, 34069, 6)),
        r.setClear(0, 0, 0, 1),
        o.setClear(1),
        s.setClear(0),
        D(2929),
        o.setFunc(3),
        B(!1),
        F(1),
        D(2884),
        z(0);
      const k = { 100: 32774, 101: 32778, 102: 32779 };
      if (i) (k[103] = 32775), (k[104] = 32776);
      else {
        const t = e.get("EXT_blend_minmax");
        null !== t && ((k[103] = t.MIN_EXT), (k[104] = t.MAX_EXT));
      }
      const U = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773,
      };
      function z(e, n, i, r, o, s, a, c) {
        if (0 !== e) {
          if ((l || (D(3042), (l = !0)), 5 === e))
            (o = o || n),
              (s = s || i),
              (a = a || r),
              (n === h && o === f) ||
                (t.blendEquationSeparate(k[n], k[o]), (h = n), (f = o)),
              (i === p && r === d && s === g && a === v) ||
                (t.blendFuncSeparate(U[i], U[r], U[s], U[a]),
                (p = i),
                (d = r),
                (g = s),
                (v = a)),
              (u = e),
              (y = null);
          else if (e !== u || c !== y) {
            if (
              ((100 === h && 100 === f) ||
                (t.blendEquation(32774), (h = 100), (f = 100)),
              c)
            )
              switch (e) {
                case 1:
                  t.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  t.blendFunc(1, 1);
                  break;
                case 3:
                  t.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  t.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case 1:
                  t.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  t.blendFunc(770, 1);
                  break;
                case 3:
                  t.blendFunc(0, 769);
                  break;
                case 4:
                  t.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (p = null), (d = null), (g = null), (v = null), (u = e), (y = c);
          }
        } else l && (N(3042), (l = !1));
      }
      function B(e) {
        x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e));
      }
      function F(e) {
        0 !== e
          ? (D(2884),
            e !== b &&
              (1 === e
                ? t.cullFace(1029)
                : 2 === e
                ? t.cullFace(1028)
                : t.cullFace(1032)))
          : N(2884),
          (b = e);
      }
      function H(e, n, i) {
        e
          ? (D(32823),
            (_ === n && M === i) || (t.polygonOffset(n, i), (_ = n), (M = i)))
          : N(32823);
      }
      function G(e) {
        void 0 === e && (e = 33984 + S - 1),
          L !== e && (t.activeTexture(e), (L = e));
      }
      return {
        buffers: { color: r, depth: o, stencil: s },
        enable: D,
        disable: N,
        useProgram: function (e) {
          return c !== e && (t.useProgram(e), (c = e), !0);
        },
        setBlending: z,
        setMaterial: function (t, e) {
          2 === t.side ? N(2884) : D(2884);
          let n = 1 === t.side;
          e && (n = !n),
            B(n),
            1 === t.blending && !1 === t.transparent
              ? z(0)
              : z(
                  t.blending,
                  t.blendEquation,
                  t.blendSrc,
                  t.blendDst,
                  t.blendEquationAlpha,
                  t.blendSrcAlpha,
                  t.blendDstAlpha,
                  t.premultipliedAlpha
                ),
            o.setFunc(t.depthFunc),
            o.setTest(t.depthTest),
            o.setMask(t.depthWrite),
            r.setMask(t.colorWrite);
          const i = t.stencilWrite;
          s.setTest(i),
            i &&
              (s.setMask(t.stencilWriteMask),
              s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
              s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
            H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
        },
        setFlipSided: B,
        setCullFace: F,
        setLineWidth: function (e) {
          e !== w && (T && t.lineWidth(e), (w = e));
        },
        setPolygonOffset: H,
        setScissorTest: function (t) {
          t ? D(3089) : N(3089);
        },
        activeTexture: G,
        bindTexture: function (e, n) {
          null === L && G();
          let i = R[L];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (R[L] = i)),
            (i.type === e && i.texture === n) ||
              (t.bindTexture(e, n || I[e]), (i.type = e), (i.texture = n));
        },
        unbindTexture: function () {
          const e = R[L];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage2D: function () {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage3D: function () {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        scissor: function (e) {
          !1 === P.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), P.copy(e));
        },
        viewport: function (e) {
          !1 === C.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), C.copy(e));
        },
        reset: function () {
          (a = {}),
            (L = null),
            (R = {}),
            (c = null),
            (u = null),
            (x = null),
            (b = null),
            r.reset(),
            o.reset(),
            s.reset();
        },
      };
    }
    function Qi(t, e, n, i, r, o, s) {
      const a = r.isWebGL2,
        l = r.maxTextures,
        u = r.maxCubemapSize,
        h = r.maxTextureSize,
        p = r.maxSamples,
        d = new WeakMap();
      let f,
        m = !1;
      try {
        m =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function g(t, e) {
        return m
          ? new OffscreenCanvas(t, e)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function v(t, e, n, i) {
        let r = 1;
        if (
          ((t.width > i || t.height > i) &&
            (r = i / Math.max(t.width, t.height)),
          r < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const i = e ? c.floorPowerOfTwo : Math.floor,
              o = i(r * t.width),
              s = i(r * t.height);
            void 0 === f && (f = g(o, s));
            const a = n ? g(o, s) : f;
            (a.width = o), (a.height = s);
            return (
              a.getContext("2d").drawImage(t, 0, 0, o, s),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  o +
                  "x" +
                  s +
                  ")."
              ),
              a
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              ),
            t
          );
        }
        return t;
      }
      function y(t) {
        return c.isPowerOfTwo(t.width) && c.isPowerOfTwo(t.height);
      }
      function x(t, e) {
        return (
          t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        );
      }
      function b(e, n, r, o) {
        t.generateMipmap(e);
        i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E;
      }
      function w(n, i, r) {
        if (!1 === a) return i;
        if (null !== n) {
          if (void 0 !== t[n]) return t[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let o = i;
        return (
          6403 === i &&
            (5126 === r && (o = 33326),
            5131 === r && (o = 33325),
            5121 === r && (o = 33321)),
          6407 === i &&
            (5126 === r && (o = 34837),
            5131 === r && (o = 34843),
            5121 === r && (o = 32849)),
          6408 === i &&
            (5126 === r && (o = 34836),
            5131 === r && (o = 34842),
            5121 === r && (o = 32856)),
          (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
            e.get("EXT_color_buffer_float"),
          o
        );
      }
      function _(t) {
        return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
      }
      function M(e) {
        const n = e.target;
        n.removeEventListener("dispose", M),
          (function (e) {
            const n = i.get(e);
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture), i.remove(e);
          })(n),
          n.isVideoTexture && d.delete(n),
          s.memory.textures--;
      }
      function S(e) {
        const n = e.target;
        n.removeEventListener("dispose", S),
          (function (e) {
            const n = i.get(e),
              r = i.get(e.texture);
            if (!e) return;
            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLCubeRenderTarget)
              for (let e = 0; e < 6; e++)
                t.deleteFramebuffer(n.__webglFramebuffer[e]),
                  n.__webglDepthbuffer &&
                    t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
            else
              t.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthbuffer),
                n.__webglMultisampledFramebuffer &&
                  t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                n.__webglColorRenderbuffer &&
                  t.deleteRenderbuffer(n.__webglColorRenderbuffer),
                n.__webglDepthRenderbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
            i.remove(e.texture), i.remove(e);
          })(n),
          s.memory.textures--;
      }
      let T = 0;
      function E(t, e) {
        const r = i.get(t);
        if (
          (t.isVideoTexture &&
            (function (t) {
              const e = s.render.frame;
              d.get(t) !== e && (d.set(t, e), t.update());
            })(t),
          t.version > 0 && r.__version !== t.version)
        ) {
          const n = t.image;
          if (void 0 === n)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== n.complete) return void I(r, t, e);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
      }
      function A(e, r) {
        if (6 !== e.image.length) return;
        const s = i.get(e);
        if (e.version > 0 && s.__version !== e.version) {
          O(s, e),
            n.activeTexture(33984 + r),
            n.bindTexture(34067, s.__webglTexture),
            t.pixelStorei(37440, e.flipY);
          const i =
              e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
            c = e.image[0] && e.image[0].isDataTexture,
            l = [];
          for (let t = 0; t < 6; t++)
            l[t] =
              i || c
                ? c
                  ? e.image[t].image
                  : e.image[t]
                : v(e.image[t], !1, !0, u);
          const h = l[0],
            p = y(h) || a,
            d = o.convert(e.format),
            f = o.convert(e.type),
            m = w(e.internalFormat, d, f);
          let g;
          if ((C(34067, e, p), i)) {
            for (let t = 0; t < 6; t++) {
              g = l[t].mipmaps;
              for (let i = 0; i < g.length; i++) {
                const r = g[i];
                1023 !== e.format && 1022 !== e.format
                  ? null !== d
                    ? n.compressedTexImage2D(
                        34069 + t,
                        i,
                        m,
                        r.width,
                        r.height,
                        0,
                        r.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : n.texImage2D(
                      34069 + t,
                      i,
                      m,
                      r.width,
                      r.height,
                      0,
                      d,
                      f,
                      r.data
                    );
              }
            }
            s.__maxMipLevel = g.length - 1;
          } else {
            g = e.mipmaps;
            for (let t = 0; t < 6; t++)
              if (c) {
                n.texImage2D(
                  34069 + t,
                  0,
                  m,
                  l[t].width,
                  l[t].height,
                  0,
                  d,
                  f,
                  l[t].data
                );
                for (let e = 0; e < g.length; e++) {
                  const i = g[e].image[t].image;
                  n.texImage2D(
                    34069 + t,
                    e + 1,
                    m,
                    i.width,
                    i.height,
                    0,
                    d,
                    f,
                    i.data
                  );
                }
              } else {
                n.texImage2D(34069 + t, 0, m, d, f, l[t]);
                for (let e = 0; e < g.length; e++) {
                  const i = g[e];
                  n.texImage2D(34069 + t, e + 1, m, d, f, i.image[t]);
                }
              }
            s.__maxMipLevel = g.length;
          }
          x(e, p) && b(34067, e, h.width, h.height),
            (s.__version = e.version),
            e.onUpdate && e.onUpdate(e);
        } else
          n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture);
      }
      function L(t, e) {
        n.activeTexture(33984 + e),
          n.bindTexture(34067, i.get(t).__webglTexture);
      }
      const R = { 1e3: 10497, 1001: 33071, 1002: 33648 },
        P = {
          1003: 9728,
          1004: 9984,
          1005: 9986,
          1006: 9729,
          1007: 9985,
          1008: 9987,
        };
      function C(n, o, s) {
        s
          ? (t.texParameteri(n, 10242, R[o.wrapS]),
            t.texParameteri(n, 10243, R[o.wrapT]),
            (32879 !== n && 35866 !== n) ||
              t.texParameteri(n, 32882, R[o.wrapR]),
            t.texParameteri(n, 10240, P[o.magFilter]),
            t.texParameteri(n, 10241, P[o.minFilter]))
          : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
            (1001 === o.wrapS && 1001 === o.wrapT) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            t.texParameteri(n, 10240, _(o.magFilter)),
            t.texParameteri(n, 10241, _(o.minFilter)),
            1003 !== o.minFilter &&
              1006 !== o.minFilter &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              ));
        const c = e.get("EXT_texture_filter_anisotropic");
        if (c) {
          if (1015 === o.type && null === e.get("OES_texture_float_linear"))
            return;
          if (
            1016 === o.type &&
            null === (a || e.get("OES_texture_half_float_linear"))
          )
            return;
          (o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              c.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(o.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(o).__currentAnisotropy = o.anisotropy));
        }
      }
      function O(e, n) {
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0),
          n.addEventListener("dispose", M),
          (e.__webglTexture = t.createTexture()),
          s.memory.textures++);
      }
      function I(e, i, r) {
        let s = 3553;
        i.isDataTexture2DArray && (s = 35866),
          i.isDataTexture3D && (s = 32879),
          O(e, i),
          n.activeTexture(33984 + r),
          n.bindTexture(s, e.__webglTexture),
          t.pixelStorei(37440, i.flipY),
          t.pixelStorei(37441, i.premultiplyAlpha),
          t.pixelStorei(3317, i.unpackAlignment);
        const c =
            (function (t) {
              return (
                !a &&
                (1001 !== t.wrapS ||
                  1001 !== t.wrapT ||
                  (1003 !== t.minFilter && 1006 !== t.minFilter))
              );
            })(i) && !1 === y(i.image),
          l = v(i.image, c, !1, h),
          u = y(l) || a,
          p = o.convert(i.format);
        let d,
          f = o.convert(i.type),
          m = w(i.internalFormat, p, f);
        C(s, i, u);
        const g = i.mipmaps;
        if (i.isDepthTexture)
          (m = 6402),
            a
              ? (m =
                  1015 === i.type
                    ? 36012
                    : 1014 === i.type
                    ? 33190
                    : 1020 === i.type
                    ? 35056
                    : 33189)
              : 1015 === i.type &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            1026 === i.format &&
              6402 === m &&
              1012 !== i.type &&
              1014 !== i.type &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = 1012),
              (f = o.convert(i.type))),
            1027 === i.format &&
              6402 === m &&
              ((m = 34041),
              1020 !== i.type &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = 1020),
                (f = o.convert(i.type)))),
            n.texImage2D(3553, 0, m, l.width, l.height, 0, p, f, null);
        else if (i.isDataTexture)
          if (g.length > 0 && u) {
            for (let t = 0, e = g.length; t < e; t++)
              (d = g[t]),
                n.texImage2D(3553, t, m, d.width, d.height, 0, p, f, d.data);
            (i.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
          } else
            n.texImage2D(3553, 0, m, l.width, l.height, 0, p, f, l.data),
              (e.__maxMipLevel = 0);
        else if (i.isCompressedTexture) {
          for (let t = 0, e = g.length; t < e; t++)
            (d = g[t]),
              1023 !== i.format && 1022 !== i.format
                ? null !== p
                  ? n.compressedTexImage2D(
                      3553,
                      t,
                      m,
                      d.width,
                      d.height,
                      0,
                      d.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, t, m, d.width, d.height, 0, p, f, d.data);
          e.__maxMipLevel = g.length - 1;
        } else if (i.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            m,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            f,
            l.data
          ),
            (e.__maxMipLevel = 0);
        else if (i.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            m,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            f,
            l.data
          ),
            (e.__maxMipLevel = 0);
        else if (g.length > 0 && u) {
          for (let t = 0, e = g.length; t < e; t++)
            (d = g[t]), n.texImage2D(3553, t, m, p, f, d);
          (i.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
        } else n.texImage2D(3553, 0, m, p, f, l), (e.__maxMipLevel = 0);
        x(i, u) && b(s, i, l.width, l.height),
          (e.__version = i.version),
          i.onUpdate && i.onUpdate(i);
      }
      function D(e, r, s, a) {
        const c = o.convert(r.texture.format),
          l = o.convert(r.texture.type),
          u = w(r.texture.internalFormat, c, l);
        n.texImage2D(a, 0, u, r.width, r.height, 0, c, l, null),
          t.bindFramebuffer(36160, e),
          t.framebufferTexture2D(
            36160,
            s,
            a,
            i.get(r.texture).__webglTexture,
            0
          ),
          t.bindFramebuffer(36160, null);
      }
      function N(e, n, i) {
        if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
          let r = 33189;
          if (i) {
            const e = n.depthTexture;
            e &&
              e.isDepthTexture &&
              (1015 === e.type ? (r = 36012) : 1014 === e.type && (r = 33190));
            const i = U(n);
            t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
          } else t.renderbufferStorage(36161, r, n.width, n.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (i) {
            const e = U(n);
            t.renderbufferStorageMultisample(
              36161,
              e,
              35056,
              n.width,
              n.height
            );
          } else t.renderbufferStorage(36161, 34041, n.width, n.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          const e = o.convert(n.texture.format),
            r = o.convert(n.texture.type),
            s = w(n.texture.internalFormat, e, r);
          if (i) {
            const e = U(n);
            t.renderbufferStorageMultisample(36161, e, s, n.width, n.height);
          } else t.renderbufferStorage(36161, s, n.width, n.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function k(e) {
        const n = i.get(e),
          r = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
          if (r)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (e, n) {
            if (n && n.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (t.bindFramebuffer(36160, e),
              !n.depthTexture || !n.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (i.get(n.depthTexture).__webglTexture &&
              n.depthTexture.image.width === n.width &&
              n.depthTexture.image.height === n.height) ||
              ((n.depthTexture.image.width = n.width),
              (n.depthTexture.image.height = n.height),
              (n.depthTexture.needsUpdate = !0)),
              E(n.depthTexture, 0);
            const r = i.get(n.depthTexture).__webglTexture;
            if (1026 === n.depthTexture.format)
              t.framebufferTexture2D(36160, 36096, 3553, r, 0);
            else {
              if (1027 !== n.depthTexture.format)
                throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, r, 0);
            }
          })(n.__webglFramebuffer, e);
        } else if (r) {
          n.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++)
            t.bindFramebuffer(36160, n.__webglFramebuffer[i]),
              (n.__webglDepthbuffer[i] = t.createRenderbuffer()),
              N(n.__webglDepthbuffer[i], e, !1);
        } else
          t.bindFramebuffer(36160, n.__webglFramebuffer),
            (n.__webglDepthbuffer = t.createRenderbuffer()),
            N(n.__webglDepthbuffer, e, !1);
        t.bindFramebuffer(36160, null);
      }
      function U(t) {
        return a && t.isWebGLMultisampleRenderTarget
          ? Math.min(p, t.samples)
          : 0;
      }
      let z = !1,
        B = !1;
      (this.allocateTextureUnit = function () {
        const t = T;
        return (
          t >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l
            ),
          (T += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          T = 0;
        }),
        (this.setTexture2D = E),
        (this.setTexture2DArray = function (t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? I(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(35866, r.__webglTexture));
        }),
        (this.setTexture3D = function (t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? I(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(32879, r.__webglTexture));
        }),
        (this.setTextureCube = A),
        (this.setTextureCubeDynamic = L),
        (this.setupRenderTarget = function (e) {
          const r = i.get(e),
            c = i.get(e.texture);
          e.addEventListener("dispose", S),
            (c.__webglTexture = t.createTexture()),
            s.memory.textures++;
          const l = !0 === e.isWebGLCubeRenderTarget,
            u = !0 === e.isWebGLMultisampleRenderTarget,
            h = y(e) || a;
          if (
            (!a ||
              1022 !== e.texture.format ||
              (1015 !== e.texture.type && 1016 !== e.texture.type) ||
              ((e.texture.format = 1023),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            l)
          ) {
            r.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
              r.__webglFramebuffer[e] = t.createFramebuffer();
          } else if (((r.__webglFramebuffer = t.createFramebuffer()), u))
            if (a) {
              (r.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (r.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
              const n = o.convert(e.texture.format),
                i = o.convert(e.texture.type),
                s = w(e.texture.internalFormat, n, i),
                a = U(e);
              t.renderbufferStorageMultisample(36161, a, s, e.width, e.height),
                t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  r.__webglColorRenderbuffer
                ),
                t.bindRenderbuffer(36161, null),
                e.depthBuffer &&
                  ((r.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  N(r.__webglDepthRenderbuffer, e, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (l) {
            n.bindTexture(34067, c.__webglTexture), C(34067, e.texture, h);
            for (let t = 0; t < 6; t++)
              D(r.__webglFramebuffer[t], e, 36064, 34069 + t);
            x(e.texture, h) && b(34067, e.texture, e.width, e.height),
              n.bindTexture(34067, null);
          } else
            n.bindTexture(3553, c.__webglTexture),
              C(3553, e.texture, h),
              D(r.__webglFramebuffer, e, 36064, 3553),
              x(e.texture, h) && b(3553, e.texture, e.width, e.height),
              n.bindTexture(3553, null);
          e.depthBuffer && k(e);
        }),
        (this.updateRenderTargetMipmap = function (t) {
          const e = t.texture;
          if (x(e, y(t) || a)) {
            const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
              o = i.get(e).__webglTexture;
            n.bindTexture(r, o),
              b(r, e, t.width, t.height),
              n.bindTexture(r, null);
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (e.isWebGLMultisampleRenderTarget)
            if (a) {
              const n = i.get(e);
              t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, n.__webglFramebuffer);
              const r = e.width,
                o = e.height;
              let s = 16384;
              e.depthBuffer && (s |= 256),
                e.stencilBuffer && (s |= 1024),
                t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728),
                t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.safeSetTexture2D = function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === z &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (z = !0)),
            (t = t.texture)),
            E(t, e);
        }),
        (this.safeSetTextureCube = function (t, e) {
          t &&
            t.isWebGLCubeRenderTarget &&
            (!1 === B &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (B = !0)),
            (t = t.texture)),
            (t && t.isCubeTexture) ||
            (Array.isArray(t.image) && 6 === t.image.length)
              ? A(t, e)
              : L(t, e);
        });
    }
    function tr(t, e, n) {
      const i = n.isWebGL2;
      return {
        convert: function (t) {
          let n;
          if (1009 === t) return 5121;
          if (1017 === t) return 32819;
          if (1018 === t) return 32820;
          if (1019 === t) return 33635;
          if (1010 === t) return 5120;
          if (1011 === t) return 5122;
          if (1012 === t) return 5123;
          if (1013 === t) return 5124;
          if (1014 === t) return 5125;
          if (1015 === t) return 5126;
          if (1016 === t)
            return i
              ? 5131
              : ((n = e.get("OES_texture_half_float")),
                null !== n ? n.HALF_FLOAT_OES : null);
          if (1021 === t) return 6406;
          if (1022 === t) return 6407;
          if (1023 === t) return 6408;
          if (1024 === t) return 6409;
          if (1025 === t) return 6410;
          if (1026 === t) return 6402;
          if (1027 === t) return 34041;
          if (1028 === t) return 6403;
          if (1029 === t) return 36244;
          if (1030 === t) return 33319;
          if (1031 === t) return 33320;
          if (1032 === t) return 36248;
          if (1033 === t) return 36249;
          if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
            if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
              return null;
            if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
            if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
              return null;
            if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === t)
            return (
              (n = e.get("WEBGL_compressed_texture_etc1")),
              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (37492 === t || 37496 === t) &&
            ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
          ) {
            if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
            if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return 37808 === t ||
            37809 === t ||
            37810 === t ||
            37811 === t ||
            37812 === t ||
            37813 === t ||
            37814 === t ||
            37815 === t ||
            37816 === t ||
            37817 === t ||
            37818 === t ||
            37819 === t ||
            37820 === t ||
            37821 === t ||
            37840 === t ||
            37841 === t ||
            37842 === t ||
            37843 === t ||
            37844 === t ||
            37845 === t ||
            37846 === t ||
            37847 === t ||
            37848 === t ||
            37849 === t ||
            37850 === t ||
            37851 === t ||
            37852 === t ||
            37853 === t
            ? ((n = e.get("WEBGL_compressed_texture_astc")),
              null !== n ? t : null)
            : 36492 === t
            ? ((n = e.get("EXT_texture_compression_bptc")),
              null !== n ? t : null)
            : 1020 === t
            ? i
              ? 34042
              : ((n = e.get("WEBGL_depth_texture")),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        },
      };
    }
    function er(t) {
      We.call(this), (this.cameras = t || []);
    }
    function nr() {
      X.call(this), (this.type = "Group");
    }
    function ir() {
      (this._targetRay = null), (this._grip = null);
    }
    function rr(t, e) {
      const n = this;
      let i = null,
        r = 1,
        o = null,
        s = "local-floor",
        a = null;
      const c = [],
        l = new Map(),
        u = new We();
      u.layers.enable(1), (u.viewport = new m());
      const h = new We();
      h.layers.enable(2), (h.viewport = new m());
      const p = [u, h],
        d = new er();
      d.layers.enable(1), d.layers.enable(2);
      let f = null,
        g = null;
      function v(t) {
        const e = l.get(t.inputSource);
        e && e.dispatchEvent({ type: t.type });
      }
      function y() {
        l.forEach(function (t, e) {
          t.disconnect(e);
        }),
          l.clear(),
          t.setFramebuffer(null),
          t.setRenderTarget(t.getRenderTarget()),
          E.stop(),
          (n.isPresenting = !1),
          n.dispatchEvent({ type: "sessionend" });
      }
      function x(t) {
        (o = t),
          E.setContext(i),
          E.start(),
          (n.isPresenting = !0),
          n.dispatchEvent({ type: "sessionstart" });
      }
      function b(t) {
        const e = i.inputSources;
        for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
        for (let e = 0; e < t.removed.length; e++) {
          const n = t.removed[e],
            i = l.get(n);
          i &&
            (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n));
        }
        for (let e = 0; e < t.added.length; e++) {
          const n = t.added[e],
            i = l.get(n);
          i && i.dispatchEvent({ type: "connected", data: n });
        }
      }
      (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          let e = c[t];
          return (
            void 0 === e && ((e = new ir()), (c[t] = e)), e.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (t) {
          let e = c[t];
          return void 0 === e && ((e = new ir()), (c[t] = e)), e.getGripSpace();
        }),
        (this.setFramebufferScaleFactor = function (t) {
          (r = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
        (this.setReferenceSpaceType = function (t) {
          (s = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return o;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = function (t) {
          if (((i = t), null !== i)) {
            i.addEventListener("select", v),
              i.addEventListener("selectstart", v),
              i.addEventListener("selectend", v),
              i.addEventListener("squeeze", v),
              i.addEventListener("squeezestart", v),
              i.addEventListener("squeezeend", v),
              i.addEventListener("end", y);
            const t = e.getContextAttributes();
            !0 !== t.xrCompatible && e.makeXRCompatible();
            const n = {
                antialias: t.antialias,
                alpha: t.alpha,
                depth: t.depth,
                stencil: t.stencil,
                framebufferScaleFactor: r,
              },
              o = new XRWebGLLayer(i, e, n);
            i.updateRenderState({ baseLayer: o }),
              i.requestReferenceSpace(s).then(x),
              i.addEventListener("inputsourceschange", b);
          }
        });
      const _ = new w(),
        M = new w();
      function S(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.getInverse(t.matrixWorld);
      }
      this.getCamera = function (t) {
        (d.near = h.near = u.near = t.near),
          (d.far = h.far = u.far = t.far),
          (f === d.near && g === d.far) ||
            (i.updateRenderState({ depthNear: d.near, depthFar: d.far }),
            (f = d.near),
            (g = d.far));
        const e = t.parent,
          n = d.cameras;
        S(d, e);
        for (let t = 0; t < n.length; t++) S(n[t], e);
        t.matrixWorld.copy(d.matrixWorld);
        const r = t.children;
        for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
        return (
          2 === n.length
            ? (function (t, e, n) {
                _.setFromMatrixPosition(e.matrixWorld),
                  M.setFromMatrixPosition(n.matrixWorld);
                const i = _.distanceTo(M),
                  r = e.projectionMatrix.elements,
                  o = n.projectionMatrix.elements,
                  s = r[14] / (r[10] - 1),
                  a = r[14] / (r[10] + 1),
                  c = (r[9] + 1) / r[5],
                  l = (r[9] - 1) / r[5],
                  u = (r[8] - 1) / r[0],
                  h = (o[8] + 1) / o[0],
                  p = s * u,
                  d = s * h,
                  f = i / (-u + h),
                  m = f * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                  t.translateX(m),
                  t.translateZ(f),
                  t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                  t.matrixWorldInverse.getInverse(t.matrixWorld);
                const g = s + f,
                  v = a + f,
                  y = p - m,
                  x = d + (i - m),
                  b = ((c * a) / v) * g,
                  w = ((l * a) / v) * g;
                t.projectionMatrix.makePerspective(y, x, b, w, g, v);
              })(d, u, h)
            : d.projectionMatrix.copy(u.projectionMatrix),
          d
        );
      };
      let T = null;
      const E = new Qe();
      E.setAnimationLoop(function (e, n) {
        if (((a = n.getViewerPose(o)), null !== a)) {
          const e = a.views,
            n = i.renderState.baseLayer;
          t.setFramebuffer(n.framebuffer);
          let r = !1;
          e.length !== d.cameras.length && ((d.cameras.length = 0), (r = !0));
          for (let t = 0; t < e.length; t++) {
            const i = e[t],
              o = n.getViewport(i),
              s = p[t];
            s.matrix.fromArray(i.transform.matrix),
              s.projectionMatrix.fromArray(i.projectionMatrix),
              s.viewport.set(o.x, o.y, o.width, o.height),
              0 === t && d.matrix.copy(s.matrix),
              !0 === r && d.cameras.push(s);
          }
        }
        const r = i.inputSources;
        for (let t = 0; t < c.length; t++) {
          const e = c[t],
            i = r[t];
          e.update(i, n, o);
        }
        T && T(e, n);
      }),
        (this.setAnimationLoop = function (t) {
          T = t;
        }),
        (this.dispose = function () {});
    }
    function or(t) {
      function e(e, n, i) {
        (e.opacity.value = n.opacity),
          n.color && e.diffuse.value.copy(n.color),
          n.emissive &&
            e.emissive.value
              .copy(n.emissive)
              .multiplyScalar(n.emissiveIntensity),
          n.map && (e.map.value = n.map),
          n.alphaMap && (e.alphaMap.value = n.alphaMap),
          n.specularMap && (e.specularMap.value = n.specularMap);
        const r = n.envMap || i;
        let o, s;
        r &&
          ((e.envMap.value = r),
          (e.flipEnvMap.value = r.isCubeTexture ? -1 : 1),
          (e.reflectivity.value = n.reflectivity),
          (e.refractionRatio.value = n.refractionRatio),
          (e.maxMipLevel.value = t.get(r).__maxMipLevel)),
          n.lightMap &&
            ((e.lightMap.value = n.lightMap),
            (e.lightMapIntensity.value = n.lightMapIntensity)),
          n.aoMap &&
            ((e.aoMap.value = n.aoMap),
            (e.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (o = n.map)
            : n.specularMap
            ? (o = n.specularMap)
            : n.displacementMap
            ? (o = n.displacementMap)
            : n.normalMap
            ? (o = n.normalMap)
            : n.bumpMap
            ? (o = n.bumpMap)
            : n.roughnessMap
            ? (o = n.roughnessMap)
            : n.metalnessMap
            ? (o = n.metalnessMap)
            : n.alphaMap
            ? (o = n.alphaMap)
            : n.emissiveMap && (o = n.emissiveMap),
          void 0 !== o &&
            (o.isWebGLRenderTarget && (o = o.texture),
            !0 === o.matrixAutoUpdate && o.updateMatrix(),
            e.uvTransform.value.copy(o.matrix)),
          n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
          void 0 !== s &&
            (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            e.uv2Transform.value.copy(s.matrix));
      }
      function n(t, e, n) {
        (t.roughness.value = e.roughness),
          (t.metalness.value = e.metalness),
          e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
          e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            1 === e.side && (t.bumpScale.value *= -1)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale),
            1 === e.side && t.normalScale.value.negate()),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
          (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (t, e) {
          t.fogColor.value.copy(e.color),
            e.isFog
              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
              : e.isFogExp2 && (t.fogDensity.value = e.density);
        },
        refreshMaterialUniforms: function (t, i, r, o, s) {
          i.isMeshBasicMaterial
            ? e(t, i)
            : i.isMeshLambertMaterial
            ? (e(t, i),
              (function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
              })(t, i))
            : i.isMeshToonMaterial
            ? (e(t, i),
              (function (t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshPhongMaterial
            ? (e(t, i),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshStandardMaterial
            ? (e(t, i, r),
              i.isMeshPhysicalMaterial
                ? (function (t, e, i) {
                    n(t, e, i),
                      (t.reflectivity.value = e.reflectivity),
                      (t.clearcoat.value = e.clearcoat),
                      (t.clearcoatRoughness.value = e.clearcoatRoughness),
                      e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap &&
                      (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap &&
                      (t.clearcoatNormalScale.value.copy(
                        e.clearcoatNormalScale
                      ),
                      (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                      1 === e.side && t.clearcoatNormalScale.value.negate());
                    t.transparency.value = e.transparency;
                  })(t, i, r)
                : n(t, i, r))
            : i.isMeshMatcapMaterial
            ? (e(t, i),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshDepthMaterial
            ? (e(t, i),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshDistanceMaterial
            ? (e(t, i),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
                t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              })(t, i))
            : i.isMeshNormalMaterial
            ? (e(t, i),
              (function (t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isLineBasicMaterial
            ? ((function (t, e) {
                t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
              })(t, i),
              i.isLineDashedMaterial &&
                (function (t, e) {
                  (t.dashSize.value = e.dashSize),
                    (t.totalSize.value = e.dashSize + e.gapSize),
                    (t.scale.value = e.scale);
                })(t, i))
            : i.isPointsMaterial
            ? (function (t, e, n, i) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * n),
                  (t.scale.value = 0.5 * i),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                let r;
                e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
                void 0 !== r &&
                  (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                  t.uvTransform.value.copy(r.matrix));
              })(t, i, o, s)
            : i.isSpriteMaterial
            ? (function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                let n;
                e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  t.uvTransform.value.copy(n.matrix));
              })(t, i)
            : i.isShadowMaterial
            ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
        },
      };
    }
    function sr(t) {
      const e =
          void 0 !== (t = t || {}).canvas
            ? t.canvas
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              ),
        n = void 0 !== t.context ? t.context : null,
        i = void 0 !== t.alpha && t.alpha,
        r = void 0 === t.depth || t.depth,
        o = void 0 === t.stencil || t.stencil,
        s = void 0 !== t.antialias && t.antialias,
        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        h = void 0 !== t.powerPreference ? t.powerPreference : "default",
        p =
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat;
      let d = null,
        f = null;
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = 3e3),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4);
      const g = this;
      let v = !1,
        y = null,
        x = 0,
        b = 0,
        _ = null,
        M = null,
        S = -1,
        T = null,
        E = null;
      const A = new m(),
        L = new m();
      let P = null,
        C = e.width,
        O = e.height,
        I = 1,
        D = null,
        N = null;
      const k = new m(0, 0, C, O),
        U = new m(0, 0, C, O);
      let z = !1;
      const B = new Ke(),
        F = new un();
      let H = !1,
        G = !1;
      const j = new R(),
        V = new w(),
        W = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function q() {
        return null === _ ? I : 1;
      }
      let X,
        Y,
        Z,
        J,
        K,
        $,
        Q,
        tt,
        et,
        nt,
        it,
        rt,
        ot,
        st,
        at,
        ct,
        lt,
        ut,
        ht,
        pt = n;
      function dt(t, n) {
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            o = e.getContext(r, n);
          if (null !== o) return o;
        }
        return null;
      }
      try {
        const t = {
          alpha: i,
          depth: r,
          stencil: o,
          antialias: s,
          premultipliedAlpha: a,
          preserveDrawingBuffer: u,
          powerPreference: h,
          failIfMajorPerformanceCaveat: p,
        };
        if (
          (e.addEventListener("webglcontextlost", vt, !1),
          e.addEventListener("webglcontextrestored", yt, !1),
          null === pt)
        ) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === g.isWebGL1Renderer && e.shift(),
            (pt = dt(e, t)),
            null === pt)
          )
            throw dt(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === pt.getShaderPrecisionFormat &&
          (pt.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function ft() {
        (X = new hn(pt)),
          (Y = new ln(pt, X, t)),
          !1 === Y.isWebGL2 &&
            (X.get("WEBGL_depth_texture"),
            X.get("OES_texture_float"),
            X.get("OES_texture_half_float"),
            X.get("OES_texture_half_float_linear"),
            X.get("OES_standard_derivatives"),
            X.get("OES_element_index_uint"),
            X.get("OES_vertex_array_object"),
            X.get("ANGLE_instanced_arrays")),
          X.get("OES_texture_float_linear"),
          (ut = new tr(pt, X, Y)),
          (Z = new $i(pt, X, Y)),
          Z.scissor(L.copy(U).multiplyScalar(I).floor()),
          Z.viewport(A.copy(k).multiplyScalar(I).floor()),
          (J = new fn(pt)),
          (K = new zi()),
          ($ = new Qi(pt, X, Z, K, Y, ut, J)),
          (Q = new tn(pt, Y)),
          (ht = new an(pt, X, Q, Y)),
          (tt = new pn(pt, Q, J, ht)),
          (et = new yn(pt, tt, Q, J)),
          (at = new vn(pt)),
          (nt = new Ui(g, X, Y, ht)),
          (it = new or(K)),
          (rt = new Gi()),
          (ot = new Yi()),
          (st = new sn(g, Z, et, a)),
          (ct = new cn(pt, X, J, Y)),
          (lt = new dn(pt, X, J, Y)),
          (J.programs = nt.programs),
          (g.capabilities = Y),
          (g.extensions = X),
          (g.properties = K),
          (g.renderLists = rt),
          (g.state = Z),
          (g.info = J);
      }
      ft();
      const mt = new rr(g, pt);
      this.xr = mt;
      const gt = new Ki(g, et, Y.maxTextureSize);
      function vt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (v = !0);
      }
      function yt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (v = !1), ft();
      }
      function xt(t) {
        const e = t.target;
        e.removeEventListener("dispose", xt),
          (function (t) {
            bt(t), K.remove(t);
          })(e);
      }
      function bt(t) {
        const e = K.get(t).program;
        (t.program = void 0), void 0 !== e && nt.releaseProgram(e);
      }
      (this.shadowMap = gt),
        (this.getContext = function () {
          return pt;
        }),
        (this.getContextAttributes = function () {
          return pt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = X.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = X.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return I;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((I = t), this.setSize(C, O, !1));
        }),
        (this.getSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
              ),
              (t = new l())),
            t.set(C, O)
          );
        }),
        (this.setSize = function (t, n, i) {
          mt.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((C = t),
              (O = n),
              (e.width = Math.floor(t * I)),
              (e.height = Math.floor(n * I)),
              !1 !== i &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
              ),
              (t = new l())),
            t.set(C * I, O * I).floor()
          );
        }),
        (this.setDrawingBufferSize = function (t, n, i) {
          (C = t),
            (O = n),
            (I = i),
            (e.width = Math.floor(t * i)),
            (e.height = Math.floor(n * i)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
              ),
              (t = new m())),
            t.copy(A)
          );
        }),
        (this.getViewport = function (t) {
          return t.copy(k);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, i),
            Z.viewport(A.copy(k).multiplyScalar(I).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(U);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, n, i),
            Z.scissor(L.copy(U).multiplyScalar(I).floor());
        }),
        (this.getScissorTest = function () {
          return z;
        }),
        (this.setScissorTest = function (t) {
          Z.setScissorTest((z = t));
        }),
        (this.setOpaqueSort = function (t) {
          D = t;
        }),
        (this.setTransparentSort = function (t) {
          N = t;
        }),
        (this.getClearColor = function () {
          return st.getClearColor();
        }),
        (this.setClearColor = function () {
          st.setClearColor.apply(st, arguments);
        }),
        (this.getClearAlpha = function () {
          return st.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          st.setClearAlpha.apply(st, arguments);
        }),
        (this.clear = function (t, e, n) {
          let i = 0;
          (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            pt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", vt, !1),
            e.removeEventListener("webglcontextrestored", yt, !1),
            rt.dispose(),
            ot.dispose(),
            K.dispose(),
            et.dispose(),
            ht.dispose(),
            mt.dispose(),
            _t.stop();
        }),
        (this.renderBufferImmediate = function (t, e) {
          ht.initAttributes();
          const n = K.get(t);
          t.hasPositions && !n.position && (n.position = pt.createBuffer()),
            t.hasNormals && !n.normal && (n.normal = pt.createBuffer()),
            t.hasUvs && !n.uv && (n.uv = pt.createBuffer()),
            t.hasColors && !n.color && (n.color = pt.createBuffer());
          const i = e.getAttributes();
          t.hasPositions &&
            (pt.bindBuffer(34962, n.position),
            pt.bufferData(34962, t.positionArray, 35048),
            ht.enableAttribute(i.position),
            pt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            t.hasNormals &&
              (pt.bindBuffer(34962, n.normal),
              pt.bufferData(34962, t.normalArray, 35048),
              ht.enableAttribute(i.normal),
              pt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs &&
              (pt.bindBuffer(34962, n.uv),
              pt.bufferData(34962, t.uvArray, 35048),
              ht.enableAttribute(i.uv),
              pt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            t.hasColors &&
              (pt.bindBuffer(34962, n.color),
              pt.bufferData(34962, t.colorArray, 35048),
              ht.enableAttribute(i.color),
              pt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            ht.disableUnusedAttributes(),
            pt.drawArrays(4, 0, t.count),
            (t.count = 0);
        }),
        (this.renderBufferDirect = function (t, e, n, i, r, o) {
          null === e && (e = W);
          const s = r.isMesh && r.matrixWorld.determinant() < 0,
            a = At(t, e, i, r);
          Z.setMaterial(i, s);
          let c = n.index;
          const l = n.attributes.position;
          if (null === c) {
            if (void 0 === l || 0 === l.count) return;
          } else if (0 === c.count) return;
          let u,
            h = 1;
          !0 === i.wireframe && ((c = tt.getWireframeAttribute(n)), (h = 2)),
            (i.morphTargets || i.morphNormals) && at.update(r, n, i, a),
            ht.setup(r, i, a, n, c);
          let p = ct;
          null !== c && ((u = Q.get(c)), (p = lt), p.setIndex(u));
          const d = null !== c ? c.count : l.count,
            f = n.drawRange.start * h,
            m = n.drawRange.count * h,
            g = null !== o ? o.start * h : 0,
            v = null !== o ? o.count * h : 1 / 0,
            y = Math.max(f, g),
            x = Math.min(d, f + m, g + v) - 1,
            b = Math.max(0, x - y + 1);
          if (0 !== b) {
            if (r.isMesh)
              !0 === i.wireframe
                ? (Z.setLineWidth(i.wireframeLinewidth * q()), p.setMode(1))
                : p.setMode(4);
            else if (r.isLine) {
              let t = i.linewidth;
              void 0 === t && (t = 1),
                Z.setLineWidth(t * q()),
                r.isLineSegments
                  ? p.setMode(1)
                  : r.isLineLoop
                  ? p.setMode(2)
                  : p.setMode(3);
            } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
            if (r.isInstancedMesh) p.renderInstances(n, y, b, r.count);
            else if (n.isInstancedBufferGeometry) {
              const t = Math.min(n.instanceCount, n._maxInstanceCount);
              p.renderInstances(n, y, b, t);
            } else p.render(y, b);
          }
        }),
        (this.compile = function (t, e) {
          (f = ot.get(t, e)),
            f.init(),
            t.traverse(function (t) {
              t.isLight && (f.pushLight(t), t.castShadow && f.pushShadow(t));
            }),
            f.setupLights(e);
          const n = new WeakMap();
          t.traverse(function (e) {
            let i = e.material;
            if (i)
              if (Array.isArray(i))
                for (let r = 0; r < i.length; r++) {
                  let o = i[r];
                  !1 === n.has(o) && (Et(o, t, e), n.set(o));
                }
              else !1 === n.has(i) && (Et(i, t, e), n.set(i));
          });
        });
      let wt = null;
      const _t = new Qe();
      function Mt(t, e, n, i) {
        if (!1 === t.visible) return;
        if (t.layers.test(e.layers))
          if (t.isGroup) n = t.renderOrder;
          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
          else if (t.isLight) f.pushLight(t), t.castShadow && f.pushShadow(t);
          else if (t.isSprite) {
            if (!t.frustumCulled || B.intersectsSprite(t)) {
              i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
              const e = et.update(t),
                r = t.material;
              r.visible && d.push(t, e, r, n, V.z, null);
            }
          } else if (t.isImmediateRenderObject)
            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j),
              d.push(t, null, t.material, n, V.z, null);
          else if (
            (t.isMesh || t.isLine || t.isPoints) &&
            (t.isSkinnedMesh &&
              t.skeleton.frame !== J.render.frame &&
              (t.skeleton.update(), (t.skeleton.frame = J.render.frame)),
            !t.frustumCulled || B.intersectsObject(t))
          ) {
            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
            const e = et.update(t),
              r = t.material;
            if (Array.isArray(r)) {
              const i = e.groups;
              for (let o = 0, s = i.length; o < s; o++) {
                const s = i[o],
                  a = r[s.materialIndex];
                a && a.visible && d.push(t, e, a, n, V.z, s);
              }
            } else r.visible && d.push(t, e, r, n, V.z, null);
          }
        const r = t.children;
        for (let t = 0, o = r.length; t < o; t++) Mt(r[t], e, n, i);
      }
      function St(t, e, n) {
        const i = !0 === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, o = t.length; r < o; r++) {
          const o = t[r],
            s = o.object,
            a = o.geometry,
            c = null === i ? o.material : i,
            l = o.group;
          if (n.isArrayCamera) {
            E = n;
            const t = n.cameras;
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              s.layers.test(i.layers) &&
                (Z.viewport(A.copy(i.viewport)),
                f.setupLights(i),
                Tt(s, e, i, a, c, l));
            }
          } else (E = null), Tt(s, e, n, a, c, l);
        }
      }
      function Tt(t, e, n, i, r, o) {
        if (
          (t.onBeforeRender(g, e, n, i, r, o),
          (f = ot.get(e, E || n)),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          t.isImmediateRenderObject)
        ) {
          const i = At(n, e, r, t);
          Z.setMaterial(r),
            ht.reset(),
            (function (t, e) {
              t.render(function (t) {
                g.renderBufferImmediate(t, e);
              });
            })(t, i);
        } else g.renderBufferDirect(n, e, i, r, t, o);
        t.onAfterRender(g, e, n, i, r, o), (f = ot.get(e, E || n));
      }
      function Et(t, e, n) {
        !0 !== e.isScene && (e = W);
        const i = K.get(t),
          r = f.state.lights,
          o = f.state.shadowsArray,
          s = r.state.version,
          a = nt.getParameters(
            t,
            r.state,
            o,
            e,
            F.numPlanes,
            F.numIntersection,
            n
          ),
          c = nt.getProgramCacheKey(a);
        let l = i.program,
          u = !0;
        if (void 0 === l) t.addEventListener("dispose", xt);
        else if (l.cacheKey !== c) bt(t);
        else if (i.lightsStateVersion !== s)
          (i.lightsStateVersion = s), (u = !1);
        else {
          if (void 0 !== a.shaderID) return;
          u = !1;
        }
        u &&
          ((l = nt.acquireProgram(a, c)),
          (i.program = l),
          (i.uniforms = a.uniforms),
          (i.outputEncoding = a.outputEncoding),
          (t.program = l));
        const h = l.getAttributes();
        if (t.morphTargets) {
          t.numSupportedMorphTargets = 0;
          for (let e = 0; e < g.maxMorphTargets; e++)
            h["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++;
        }
        if (t.morphNormals) {
          t.numSupportedMorphNormals = 0;
          for (let e = 0; e < g.maxMorphNormals; e++)
            h["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++;
        }
        const p = i.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          ((i.numClippingPlanes = F.numPlanes),
          (i.numIntersection = F.numIntersection),
          (p.clippingPlanes = F.uniform)),
          (i.environment = t.isMeshStandardMaterial ? e.environment : null),
          (i.fog = e.fog),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = s),
          i.needsLights &&
            ((p.ambientLightColor.value = r.state.ambient),
            (p.lightProbe.value = r.state.probe),
            (p.directionalLights.value = r.state.directional),
            (p.directionalLightShadows.value = r.state.directionalShadow),
            (p.spotLights.value = r.state.spot),
            (p.spotLightShadows.value = r.state.spotShadow),
            (p.rectAreaLights.value = r.state.rectArea),
            (p.pointLights.value = r.state.point),
            (p.pointLightShadows.value = r.state.pointShadow),
            (p.hemisphereLights.value = r.state.hemi),
            (p.directionalShadowMap.value = r.state.directionalShadowMap),
            (p.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (p.spotShadowMap.value = r.state.spotShadowMap),
            (p.spotShadowMatrix.value = r.state.spotShadowMatrix),
            (p.pointShadowMap.value = r.state.pointShadowMap),
            (p.pointShadowMatrix.value = r.state.pointShadowMatrix));
        const d = i.program.getUniforms(),
          m = gi.seqWithValue(d.seq, p);
        i.uniformsList = m;
      }
      function At(t, e, n, i) {
        !0 !== e.isScene && (e = W), $.resetTextureUnits();
        const r = e.fog,
          o = n.isMeshStandardMaterial ? e.environment : null,
          s = null === _ ? g.outputEncoding : _.texture.encoding,
          a = K.get(n),
          l = f.state.lights;
        if (!0 === H && (!0 === G || t !== T)) {
          const e = t === T && n.id === S;
          F.setState(
            n.clippingPlanes,
            n.clipIntersection,
            n.clipShadows,
            t,
            a,
            e
          );
        }
        n.version === a.__version
          ? void 0 === a.program ||
            (n.fog && a.fog !== r) ||
            a.environment !== o ||
            (a.needsLights && a.lightsStateVersion !== l.state.version)
            ? Et(n, e, i)
            : void 0 === a.numClippingPlanes ||
              (a.numClippingPlanes === F.numPlanes &&
                a.numIntersection === F.numIntersection)
            ? a.outputEncoding !== s && Et(n, e, i)
            : Et(n, e, i)
          : (Et(n, e, i), (a.__version = n.version));
        let u = !1,
          h = !1,
          p = !1;
        const d = a.program,
          m = d.getUniforms(),
          v = a.uniforms;
        if (
          (Z.useProgram(d.program) && ((u = !0), (h = !0), (p = !0)),
          n.id !== S && ((S = n.id), (h = !0)),
          u || T !== t)
        ) {
          if (
            (m.setValue(pt, "projectionMatrix", t.projectionMatrix),
            Y.logarithmicDepthBuffer &&
              m.setValue(
                pt,
                "logDepthBufFC",
                2 / (Math.log(t.far + 1) / Math.LN2)
              ),
            T !== t && ((T = t), (h = !0), (p = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            const e = m.map.cameraPosition;
            void 0 !== e &&
              e.setValue(pt, V.setFromMatrixPosition(t.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial) &&
            m.setValue(pt, "isOrthographic", !0 === t.isOrthographicCamera),
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial ||
              n.isShadowMaterial ||
              n.skinning) &&
              m.setValue(pt, "viewMatrix", t.matrixWorldInverse);
        }
        if (n.skinning) {
          m.setOptional(pt, i, "bindMatrix"),
            m.setOptional(pt, i, "bindMatrixInverse");
          const t = i.skeleton;
          if (t) {
            const e = t.bones;
            if (Y.floatVertexTextures) {
              if (void 0 === t.boneTexture) {
                let n = Math.sqrt(4 * e.length);
                (n = c.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
                const i = new Float32Array(n * n * 4);
                i.set(t.boneMatrices);
                const r = new Ye(i, n, n, 1023, 1015);
                (t.boneMatrices = i),
                  (t.boneTexture = r),
                  (t.boneTextureSize = n);
              }
              m.setValue(pt, "boneTexture", t.boneTexture, $),
                m.setValue(pt, "boneTextureSize", t.boneTextureSize);
            } else m.setOptional(pt, t, "boneMatrices");
          }
        }
        var y, x;
        return (
          (h || a.receiveShadow !== i.receiveShadow) &&
            ((a.receiveShadow = i.receiveShadow),
            m.setValue(pt, "receiveShadow", i.receiveShadow)),
          h &&
            (m.setValue(pt, "toneMappingExposure", g.toneMappingExposure),
            a.needsLights &&
              ((x = p),
              ((y = v).ambientLightColor.needsUpdate = x),
              (y.lightProbe.needsUpdate = x),
              (y.directionalLights.needsUpdate = x),
              (y.directionalLightShadows.needsUpdate = x),
              (y.pointLights.needsUpdate = x),
              (y.pointLightShadows.needsUpdate = x),
              (y.spotLights.needsUpdate = x),
              (y.spotLightShadows.needsUpdate = x),
              (y.rectAreaLights.needsUpdate = x),
              (y.hemisphereLights.needsUpdate = x)),
            r && n.fog && it.refreshFogUniforms(v, r),
            it.refreshMaterialUniforms(v, n, o, I, O),
            void 0 !== v.ltc_1 && (v.ltc_1.value = $e.LTC_1),
            void 0 !== v.ltc_2 && (v.ltc_2.value = $e.LTC_2),
            gi.upload(pt, a.uniformsList, v, $)),
          n.isShaderMaterial &&
            !0 === n.uniformsNeedUpdate &&
            (gi.upload(pt, a.uniformsList, v, $), (n.uniformsNeedUpdate = !1)),
          n.isSpriteMaterial && m.setValue(pt, "center", i.center),
          m.setValue(pt, "modelViewMatrix", i.modelViewMatrix),
          m.setValue(pt, "normalMatrix", i.normalMatrix),
          m.setValue(pt, "modelMatrix", i.matrixWorld),
          d
        );
      }
      _t.setAnimationLoop(function (t) {
        mt.isPresenting || (wt && wt(t));
      }),
        "undefined" != typeof window && _t.setContext(window),
        (this.setAnimationLoop = function (t) {
          (wt = t), mt.setAnimationLoop(t), null === t ? _t.stop() : _t.start();
        }),
        (this.render = function (t, e) {
          let n, i;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              ),
              (n = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
              ),
              (i = arguments[3])),
            void 0 !== e && !0 !== e.isCamera)
          )
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === v) return;
          ht.resetDefaultState(),
            (S = -1),
            (T = null),
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === mt.enabled &&
              !0 === mt.isPresenting &&
              (e = mt.getCamera(e)),
            !0 === t.isScene && t.onBeforeRender(g, t, e, n || _),
            (f = ot.get(t, e)),
            f.init(),
            j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            B.setFromProjectionMatrix(j),
            (G = this.localClippingEnabled),
            (H = F.init(this.clippingPlanes, G, e)),
            (d = rt.get(t, e)),
            d.init(),
            Mt(t, e, 0, g.sortObjects),
            d.finish(),
            !0 === g.sortObjects && d.sort(D, N),
            !0 === H && F.beginShadows();
          const r = f.state.shadowsArray;
          gt.render(r, t, e),
            f.setupLights(e),
            !0 === H && F.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== n && this.setRenderTarget(n),
            st.render(d, t, e, i);
          const o = d.opaque,
            s = d.transparent;
          o.length > 0 && St(o, t, e),
            s.length > 0 && St(s, t, e),
            !0 === t.isScene && t.onAfterRender(g, t, e),
            null !== _ &&
              ($.updateRenderTargetMipmap(_),
              $.updateMultisampleRenderTarget(_)),
            Z.buffers.depth.setTest(!0),
            Z.buffers.depth.setMask(!0),
            Z.buffers.color.setMask(!0),
            Z.setPolygonOffset(!1),
            (d = null),
            (f = null);
        }),
        (this.setFramebuffer = function (t) {
          y !== t && null === _ && pt.bindFramebuffer(36160, t), (y = t);
        }),
        (this.getActiveCubeFace = function () {
          return x;
        }),
        (this.getActiveMipmapLevel = function () {
          return b;
        }),
        (this.getRenderTarget = function () {
          return _;
        }),
        (this.setRenderTarget = function (t, e, n) {
          (_ = t),
            (x = e),
            (b = n),
            t &&
              void 0 === K.get(t).__webglFramebuffer &&
              $.setupRenderTarget(t);
          let i = y,
            r = !1;
          if (t) {
            const n = K.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((i = n[e || 0]), (r = !0))
              : (i = t.isWebGLMultisampleRenderTarget
                  ? K.get(t).__webglMultisampledFramebuffer
                  : n),
              A.copy(t.viewport),
              L.copy(t.scissor),
              (P = t.scissorTest);
          } else
            A.copy(k).multiplyScalar(I).floor(),
              L.copy(U).multiplyScalar(I).floor(),
              (P = z);
          if (
            (M !== i && (pt.bindFramebuffer(36160, i), (M = i)),
            Z.viewport(A),
            Z.scissor(L),
            Z.setScissorTest(P),
            r)
          ) {
            const i = K.get(t.texture);
            pt.framebufferTexture2D(
              36160,
              36064,
              34069 + (e || 0),
              i.__webglTexture,
              n || 0
            );
          }
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let a = K.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
            let s = !1;
            a !== M && (pt.bindFramebuffer(36160, a), (s = !0));
            try {
              const a = t.texture,
                c = a.format,
                l = a.type;
              if (1023 !== c && ut.convert(c) !== pt.getParameter(35739))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              if (
                !(
                  1009 === l ||
                  ut.convert(l) === pt.getParameter(35738) ||
                  (1015 === l &&
                    (Y.isWebGL2 ||
                      X.get("OES_texture_float") ||
                      X.get("WEBGL_color_buffer_float"))) ||
                  (1016 === l &&
                    (Y.isWebGL2
                      ? X.get("EXT_color_buffer_float")
                      : X.get("EXT_color_buffer_half_float")))
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              36053 === pt.checkFramebufferStatus(36160)
                ? e >= 0 &&
                  e <= t.width - i &&
                  n >= 0 &&
                  n <= t.height - r &&
                  pt.readPixels(e, n, i, r, ut.convert(c), ut.convert(l), o)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  );
            } finally {
              s && pt.bindFramebuffer(36160, M);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, n) {
          void 0 === n && (n = 0);
          const i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            o = Math.floor(e.image.height * i),
            s = ut.convert(e.format);
          $.setTexture2D(e, 0),
            pt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
            Z.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i) {
          void 0 === i && (i = 0);
          const r = e.image.width,
            o = e.image.height,
            s = ut.convert(n.format),
            a = ut.convert(n.type);
          $.setTexture2D(n, 0),
            pt.pixelStorei(37440, n.flipY),
            pt.pixelStorei(37441, n.premultiplyAlpha),
            pt.pixelStorei(3317, n.unpackAlignment),
            e.isDataTexture
              ? pt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data)
              : e.isCompressedTexture
              ? pt.compressedTexSubImage2D(
                  3553,
                  i,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  s,
                  e.mipmaps[0].data
                )
              : pt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
            0 === i && n.generateMipmaps && pt.generateMipmap(3553),
            Z.unbindTexture();
        }),
        (this.initTexture = function (t) {
          $.setTexture2D(t, 0), Z.unbindTexture();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    function ar(t) {
      sr.call(this, t);
    }
    function cr(t, e) {
      (this.name = ""),
        (this.color = new zt(t)),
        (this.density = void 0 !== e ? e : 25e-5);
    }
    function lr(t, e, n) {
      (this.name = ""),
        (this.color = new zt(t)),
        (this.near = void 0 !== e ? e : 1),
        (this.far = void 0 !== n ? n : 1e3);
    }
    function ur(t, e) {
      (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = 35044),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = c.generateUUID());
    }
    (er.prototype = Object.assign(Object.create(We.prototype), {
      constructor: er,
      isArrayCamera: !0,
    })),
      (nr.prototype = Object.assign(Object.create(X.prototype), {
        constructor: nr,
        isGroup: !0,
      })),
      Object.assign(ir.prototype, {
        constructor: ir,
        getTargetRaySpace: function () {
          return (
            null === this._targetRay &&
              ((this._targetRay = new nr()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1)),
            this._targetRay
          );
        },
        getGripSpace: function () {
          return (
            null === this._grip &&
              ((this._grip = new nr()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1)),
            this._grip
          );
        },
        dispatchEvent: function (t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            this
          );
        },
        disconnect: function (t) {
          return (
            this.dispatchEvent({ type: "disconnected", data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            this
          );
        },
        update: function (t, e, n) {
          let i = null,
            r = null;
          const o = this._targetRay,
            s = this._grip;
          return (
            t &&
              (null !== o &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null !== i &&
                  (o.matrix.fromArray(i.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale))),
              null !== s &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, n)),
                null !== r &&
                  (s.matrix.fromArray(r.transform.matrix),
                  s.matrix.decompose(s.position, s.rotation, s.scale)))),
            null !== o && (o.visible = null !== i),
            null !== s && (s.visible = null !== r),
            this
          );
        },
      }),
      Object.assign(rr.prototype, s.prototype),
      (ar.prototype = Object.assign(Object.create(sr.prototype), {
        constructor: ar,
        isWebGL1Renderer: !0,
      })),
      Object.assign(cr.prototype, {
        isFogExp2: !0,
        clone: function () {
          return new cr(this.color, this.density);
        },
        toJSON: function () {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        },
      }),
      Object.assign(lr.prototype, {
        isFog: !0,
        clone: function () {
          return new lr(this.color, this.near, this.far);
        },
        toJSON: function () {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        },
      }),
      Object.defineProperty(ur.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(ur.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
          return (this.usage = t), this;
        },
        copy: function (t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        clone: function (t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = c.generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const e = new ur(
            new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            this.stride
          );
          return e.setUsage(this.usage), e;
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        toJSON: function (t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = c.generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        },
      });
    const hr = new w();
    function pr(t, e, n, i) {
      (this.name = ""),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = !0 === i);
    }
    function dr(t) {
      Vt.call(this),
        (this.type = "SpriteMaterial"),
        (this.color = new zt(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.rotation = 0),
        (this.sizeAttenuation = !0),
        (this.transparent = !0),
        this.setValues(t);
    }
    let fr;
    Object.defineProperties(pr.prototype, {
      count: {
        get: function () {
          return this.data.count;
        },
      },
      array: {
        get: function () {
          return this.data.array;
        },
      },
    }),
      Object.assign(pr.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function (t) {
          for (let e = 0, n = this.data.count; e < n; e++)
            (hr.x = this.getX(e)),
              (hr.y = this.getY(e)),
              (hr.z = this.getZ(e)),
              hr.applyMatrix4(t),
              this.setXYZ(e, hr.x, hr.y, hr.z);
          return this;
        },
        setX: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        },
        setY: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        },
        setZ: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        },
        setW: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        },
        getX: function (t) {
          return this.data.array[t * this.data.stride + this.offset];
        },
        getY: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        },
        getZ: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        },
        getW: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        },
        setXY: function (t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          );
        },
        clone: function (t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return new Yt(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new pr(
              t.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        },
        toJSON: function (t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        },
      }),
      (dr.prototype = Object.create(Vt.prototype)),
      (dr.prototype.constructor = dr),
      (dr.prototype.isSpriteMaterial = !0),
      (dr.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.rotation = t.rotation),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      });
    const mr = new w(),
      gr = new w(),
      vr = new w(),
      yr = new l(),
      xr = new l(),
      br = new R(),
      wr = new w(),
      _r = new w(),
      Mr = new w(),
      Sr = new l(),
      Tr = new l(),
      Er = new l();
    function Ar(t) {
      if ((X.call(this), (this.type = "Sprite"), void 0 === fr)) {
        fr = new de();
        const t = new ur(
          new Float32Array([
            -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
            0.5, 0, 0, 1,
          ]),
          5
        );
        fr.setIndex([0, 1, 2, 0, 2, 3]),
          fr.setAttribute("position", new pr(t, 3, 0, !1)),
          fr.setAttribute("uv", new pr(t, 2, 3, !1));
      }
      (this.geometry = fr),
        (this.material = void 0 !== t ? t : new dr()),
        (this.center = new l(0.5, 0.5));
    }
    function Lr(t, e, n, i, r, o) {
      yr.subVectors(t, n).addScalar(0.5).multiply(i),
        void 0 !== r
          ? ((xr.x = o * yr.x - r * yr.y), (xr.y = r * yr.x + o * yr.y))
          : xr.copy(yr),
        t.copy(e),
        (t.x += xr.x),
        (t.y += xr.y),
        t.applyMatrix4(br);
    }
    Ar.prototype = Object.assign(Object.create(X.prototype), {
      constructor: Ar,
      isSprite: !0,
      raycast: function (t, e) {
        null === t.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          gr.setFromMatrixScale(this.matrixWorld),
          br.copy(t.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            t.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          vr.setFromMatrixPosition(this.modelViewMatrix),
          t.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            gr.multiplyScalar(-vr.z);
        const n = this.material.rotation;
        let i, r;
        0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
        const o = this.center;
        Lr(wr.set(-0.5, -0.5, 0), vr, o, gr, i, r),
          Lr(_r.set(0.5, -0.5, 0), vr, o, gr, i, r),
          Lr(Mr.set(0.5, 0.5, 0), vr, o, gr, i, r),
          Sr.set(0, 0),
          Tr.set(1, 0),
          Er.set(1, 1);
        let s = t.ray.intersectTriangle(wr, _r, Mr, !1, mr);
        if (
          null === s &&
          (Lr(_r.set(-0.5, 0.5, 0), vr, o, gr, i, r),
          Tr.set(0, 1),
          (s = t.ray.intersectTriangle(wr, Mr, _r, !1, mr)),
          null === s)
        )
          return;
        const a = t.ray.origin.distanceTo(mr);
        a < t.near ||
          a > t.far ||
          e.push({
            distance: a,
            point: mr.clone(),
            uv: Dt.getUV(mr, wr, _r, Mr, Sr, Tr, Er, new l()),
            face: null,
            object: this,
          });
      },
      copy: function (t) {
        return (
          X.prototype.copy.call(this, t),
          void 0 !== t.center && this.center.copy(t.center),
          (this.material = t.material),
          this
        );
      },
    });
    const Rr = new w(),
      Pr = new w();
    function Cr() {
      X.call(this),
        (this._currentLevel = 0),
        (this.type = "LOD"),
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
        }),
        (this.autoUpdate = !0);
    }
    function Or(t, e) {
      t &&
        t.isGeometry &&
        console.error(
          "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        ),
        Ce.call(this, t, e),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new R()),
        (this.bindMatrixInverse = new R());
    }
    (Cr.prototype = Object.assign(Object.create(X.prototype), {
      constructor: Cr,
      isLOD: !0,
      copy: function (t) {
        X.prototype.copy.call(this, t, !1);
        const e = t.levels;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t];
          this.addLevel(n.object.clone(), n.distance);
        }
        return (this.autoUpdate = t.autoUpdate), this;
      },
      addLevel: function (t, e) {
        void 0 === e && (e = 0), (e = Math.abs(e));
        const n = this.levels;
        let i;
        for (i = 0; i < n.length && !(e < n[i].distance); i++);
        return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
      },
      getCurrentLevel: function () {
        return this._currentLevel;
      },
      getObjectForDistance: function (t) {
        const e = this.levels;
        if (e.length > 0) {
          let n, i;
          for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
          return e[n - 1].object;
        }
        return null;
      },
      raycast: function (t, e) {
        if (this.levels.length > 0) {
          Rr.setFromMatrixPosition(this.matrixWorld);
          const n = t.ray.origin.distanceTo(Rr);
          this.getObjectForDistance(n).raycast(t, e);
        }
      },
      update: function (t) {
        const e = this.levels;
        if (e.length > 1) {
          Rr.setFromMatrixPosition(t.matrixWorld),
            Pr.setFromMatrixPosition(this.matrixWorld);
          const n = Rr.distanceTo(Pr) / t.zoom;
          let i, r;
          for (
            e[0].object.visible = !0, i = 1, r = e.length;
            i < r && n >= e[i].distance;
            i++
          )
            (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
          for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
        }
      },
      toJSON: function (t) {
        const e = X.prototype.toJSON.call(this, t);
        !1 === this.autoUpdate && (e.object.autoUpdate = !1),
          (e.object.levels = []);
        const n = this.levels;
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          e.object.levels.push({ object: i.object.uuid, distance: i.distance });
        }
        return e;
      },
    })),
      (Or.prototype = Object.assign(Object.create(Ce.prototype), {
        constructor: Or,
        isSkinnedMesh: !0,
        copy: function (t) {
          return (
            Ce.prototype.copy.call(this, t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          );
        },
        bind: function (t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e);
        },
        pose: function () {
          this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
          const t = new m(),
            e = this.geometry.attributes.skinWeight;
          for (let n = 0, i = e.count; n < i; n++) {
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n));
            const i = 1 / t.manhattanLength();
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w);
          }
        },
        updateMatrixWorld: function (t) {
          Ce.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.matrixWorld)
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        },
        boneTransform: (function () {
          const t = new w(),
            e = new m(),
            n = new m(),
            i = new w(),
            r = new R();
          return function (o, s) {
            const a = this.skeleton,
              c = this.geometry;
            e.fromBufferAttribute(c.attributes.skinIndex, o),
              n.fromBufferAttribute(c.attributes.skinWeight, o),
              t
                .fromBufferAttribute(c.attributes.position, o)
                .applyMatrix4(this.bindMatrix),
              s.set(0, 0, 0);
            for (let o = 0; o < 4; o++) {
              const c = n.getComponent(o);
              if (0 !== c) {
                const n = e.getComponent(o);
                r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]),
                  s.addScaledVector(i.copy(t).applyMatrix4(r), c);
              }
            }
            return s.applyMatrix4(this.bindMatrixInverse);
          };
        })(),
      }));
    const Ir = new R(),
      Dr = new R();
    function Nr(t, e) {
      if (
        ((t = t || []),
        (this.bones = t.slice(0)),
        (this.boneMatrices = new Float32Array(16 * this.bones.length)),
        (this.frame = -1),
        void 0 === e)
      )
        this.calculateInverses();
      else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
      else {
        console.warn("THREE.Skeleton boneInverses is the wrong length."),
          (this.boneInverses = []);
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new R());
      }
    }
    function kr() {
      X.call(this), (this.type = "Bone");
    }
    Object.assign(Nr.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = new R();
          this.bones[t] && e.getInverse(this.bones[t].matrixWorld),
            this.boneInverses.push(e);
        }
      },
      pose: function () {
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = this.bones[t];
          e && e.matrixWorld.getInverse(this.boneInverses[t]);
        }
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = this.bones[t];
          e &&
            (e.parent && e.parent.isBone
              ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld))
              : e.matrix.copy(e.matrixWorld),
            e.matrix.decompose(e.position, e.quaternion, e.scale));
        }
      },
      update: function () {
        const t = this.bones,
          e = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture;
        for (let i = 0, r = t.length; i < r; i++) {
          const r = t[i] ? t[i].matrixWorld : Dr;
          Ir.multiplyMatrices(r, e[i]), Ir.toArray(n, 16 * i);
        }
        void 0 !== i && (i.needsUpdate = !0);
      },
      clone: function () {
        return new Nr(this.bones, this.boneInverses);
      },
      getBoneByName: function (t) {
        for (let e = 0, n = this.bones.length; e < n; e++) {
          const n = this.bones[e];
          if (n.name === t) return n;
        }
      },
      dispose: function () {
        this.boneTexture &&
          (this.boneTexture.dispose(), (this.boneTexture = void 0));
      },
    }),
      (kr.prototype = Object.assign(Object.create(X.prototype), {
        constructor: kr,
        isBone: !0,
      }));
    const Ur = new R(),
      zr = new R(),
      Br = [],
      Fr = new Ce();
    function Hr(t, e, n) {
      Ce.call(this, t, e),
        (this.instanceMatrix = new Yt(new Float32Array(16 * n), 16)),
        (this.count = n),
        (this.frustumCulled = !1);
    }
    function Gr(t) {
      Vt.call(this),
        (this.type = "LineBasicMaterial"),
        (this.color = new zt(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (Hr.prototype = Object.assign(Object.create(Ce.prototype), {
      constructor: Hr,
      isInstancedMesh: !0,
      copy: function (t) {
        return (
          Ce.prototype.copy.call(this, t),
          this.instanceMatrix.copy(t.instanceMatrix),
          (this.count = t.count),
          this
        );
      },
      getMatrixAt: function (t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t);
      },
      raycast: function (t, e) {
        const n = this.matrixWorld,
          i = this.count;
        if (
          ((Fr.geometry = this.geometry),
          (Fr.material = this.material),
          void 0 !== Fr.material)
        )
          for (let r = 0; r < i; r++) {
            this.getMatrixAt(r, Ur),
              zr.multiplyMatrices(n, Ur),
              (Fr.matrixWorld = zr),
              Fr.raycast(t, Br);
            for (let t = 0, n = Br.length; t < n; t++) {
              const n = Br[t];
              (n.instanceId = r), (n.object = this), e.push(n);
            }
            Br.length = 0;
          }
      },
      setMatrixAt: function (t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t);
      },
      updateMorphTargets: function () {},
    })),
      (Gr.prototype = Object.create(Vt.prototype)),
      (Gr.prototype.constructor = Gr),
      (Gr.prototype.isLineBasicMaterial = !0),
      (Gr.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.linewidth = t.linewidth),
          (this.linecap = t.linecap),
          (this.linejoin = t.linejoin),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    const jr = new w(),
      Vr = new w(),
      Wr = new R(),
      qr = new xt(),
      Xr = new ht();
    function Yr(t, e, n) {
      1 === n &&
        console.error(
          "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
        ),
        X.call(this),
        (this.type = "Line"),
        (this.geometry = void 0 !== t ? t : new de()),
        (this.material = void 0 !== e ? e : new Gr()),
        this.updateMorphTargets();
    }
    Yr.prototype = Object.assign(Object.create(X.prototype), {
      constructor: Yr,
      isLine: !0,
      copy: function (t) {
        return (
          X.prototype.copy.call(this, t),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      },
      computeLineDistances: function () {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [0];
            for (let t = 1, i = e.count; t < i; t++)
              jr.fromBufferAttribute(e, t - 1),
                Vr.fromBufferAttribute(e, t),
                (n[t] = n[t - 1]),
                (n[t] += jr.distanceTo(Vr));
            t.setAttribute("lineDistance", new ne(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          const e = t.vertices,
            n = t.lineDistances;
          n[0] = 0;
          for (let t = 1, i = e.length; t < i; t++)
            (n[t] = n[t - 1]), (n[t] += e[t - 1].distanceTo(e[t]));
        }
        return this;
      },
      raycast: function (t, e) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Line.threshold;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Xr.copy(n.boundingSphere),
          Xr.applyMatrix4(i),
          (Xr.radius += r),
          !1 === t.ray.intersectsSphere(Xr))
        )
          return;
        Wr.getInverse(i), qr.copy(t.ray).applyMatrix4(Wr);
        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o,
          a = new w(),
          c = new w(),
          l = new w(),
          u = new w(),
          h = this && this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const i = n.index,
            r = n.attributes.position.array;
          if (null !== i) {
            const n = i.array;
            for (let i = 0, o = n.length - 1; i < o; i += h) {
              const o = n[i],
                h = n[i + 1];
              a.fromArray(r, 3 * o), c.fromArray(r, 3 * h);
              if (qr.distanceSqToSegment(a, c, u, l) > s) continue;
              u.applyMatrix4(this.matrixWorld);
              const p = t.ray.origin.distanceTo(u);
              p < t.near ||
                p > t.far ||
                e.push({
                  distance: p,
                  point: l.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          } else
            for (let n = 0, i = r.length / 3 - 1; n < i; n += h) {
              a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3);
              if (qr.distanceSqToSegment(a, c, u, l) > s) continue;
              u.applyMatrix4(this.matrixWorld);
              const i = t.ray.origin.distanceTo(u);
              i < t.near ||
                i > t.far ||
                e.push({
                  distance: i,
                  point: l.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
        } else if (n.isGeometry) {
          const i = n.vertices,
            r = i.length;
          for (let n = 0; n < r - 1; n += h) {
            if (qr.distanceSqToSegment(i[n], i[n + 1], u, l) > s) continue;
            u.applyMatrix4(this.matrixWorld);
            const r = t.ray.origin.distanceTo(u);
            r < t.near ||
              r > t.far ||
              e.push({
                distance: r,
                point: l.clone().applyMatrix4(this.matrixWorld),
                index: n,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        }
      },
      updateMorphTargets: function () {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
    });
    const Zr = new w(),
      Jr = new w();
    function Kr(t, e) {
      Yr.call(this, t, e), (this.type = "LineSegments");
    }
    function $r(t, e) {
      Yr.call(this, t, e), (this.type = "LineLoop");
    }
    function Qr(t) {
      Vt.call(this),
        (this.type = "PointsMaterial"),
        (this.color = new zt(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (Kr.prototype = Object.assign(Object.create(Yr.prototype), {
      constructor: Kr,
      isLineSegments: !0,
      computeLineDistances: function () {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [];
            for (let t = 0, i = e.count; t < i; t += 2)
              Zr.fromBufferAttribute(e, t),
                Jr.fromBufferAttribute(e, t + 1),
                (n[t] = 0 === t ? 0 : n[t - 1]),
                (n[t + 1] = n[t] + Zr.distanceTo(Jr));
            t.setAttribute("lineDistance", new ne(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          const e = t.vertices,
            n = t.lineDistances;
          for (let t = 0, i = e.length; t < i; t += 2)
            Zr.copy(e[t]),
              Jr.copy(e[t + 1]),
              (n[t] = 0 === t ? 0 : n[t - 1]),
              (n[t + 1] = n[t] + Zr.distanceTo(Jr));
        }
        return this;
      },
    })),
      ($r.prototype = Object.assign(Object.create(Yr.prototype), {
        constructor: $r,
        isLineLoop: !0,
      })),
      (Qr.prototype = Object.create(Vt.prototype)),
      (Qr.prototype.constructor = Qr),
      (Qr.prototype.isPointsMaterial = !0),
      (Qr.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.size = t.size),
          (this.sizeAttenuation = t.sizeAttenuation),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    const to = new R(),
      eo = new xt(),
      no = new ht(),
      io = new w();
    function ro(t, e) {
      X.call(this),
        (this.type = "Points"),
        (this.geometry = void 0 !== t ? t : new de()),
        (this.material = void 0 !== e ? e : new Qr()),
        this.updateMorphTargets();
    }
    function oo(t, e, n, i, r, o, s) {
      const a = eo.distanceSqToPoint(t);
      if (a < n) {
        const n = new w();
        eo.closestPointToPoint(t, n), n.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(n);
        if (c < r.near || c > r.far) return;
        o.push({
          distance: c,
          distanceToRay: Math.sqrt(a),
          point: n,
          index: e,
          face: null,
          object: s,
        });
      }
    }
    function so(t, e, n, i, r, o, s, a, c) {
      f.call(this, t, e, n, i, r, o, s, a, c),
        (this.format = void 0 !== s ? s : 1022),
        (this.minFilter = void 0 !== o ? o : 1006),
        (this.magFilter = void 0 !== r ? r : 1006),
        (this.generateMipmaps = !1);
    }
    function ao(t, e, n, i, r, o, s, a, c, l, u, h) {
      f.call(this, null, o, s, a, c, l, i, r, u, h),
        (this.image = { width: e, height: n }),
        (this.mipmaps = t),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function co(t, e, n, i, r, o, s, a, c) {
      f.call(this, t, e, n, i, r, o, s, a, c), (this.needsUpdate = !0);
    }
    function lo(t, e, n, i, r, o, s, a, c, l) {
      if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && 1026 === l && (n = 1012),
        void 0 === n && 1027 === l && (n = 1020),
        f.call(this, null, i, r, o, s, a, l, n, c),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== s ? s : 1003),
        (this.minFilter = void 0 !== a ? a : 1003),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function uo(t) {
      de.call(this), (this.type = "WireframeGeometry");
      const e = [],
        n = [0, 0],
        i = {},
        r = ["a", "b", "c"];
      if (t && t.isGeometry) {
        const o = t.faces;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t];
          for (let t = 0; t < 3; t++) {
            const o = e[r[t]],
              s = e[r[(t + 1) % 3]];
            (n[0] = Math.min(o, s)), (n[1] = Math.max(o, s));
            const a = n[0] + "," + n[1];
            void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
          }
        }
        for (const n in i) {
          const r = i[n];
          let o = t.vertices[r.index1];
          e.push(o.x, o.y, o.z),
            (o = t.vertices[r.index2]),
            e.push(o.x, o.y, o.z);
        }
      } else if (t && t.isBufferGeometry) {
        let r = new w();
        if (null !== t.index) {
          const o = t.attributes.position,
            s = t.index;
          let a = t.groups;
          0 === a.length &&
            (a = [{ start: 0, count: s.count, materialIndex: 0 }]);
          for (let t = 0, e = a.length; t < e; ++t) {
            const e = a[t],
              r = e.start;
            for (let t = r, o = r + e.count; t < o; t += 3)
              for (let e = 0; e < 3; e++) {
                const r = s.getX(t + e),
                  o = s.getX(t + ((e + 1) % 3));
                (n[0] = Math.min(r, o)), (n[1] = Math.max(r, o));
                const a = n[0] + "," + n[1];
                void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
              }
          }
          for (const t in i) {
            const n = i[t];
            r.fromBufferAttribute(o, n.index1),
              e.push(r.x, r.y, r.z),
              r.fromBufferAttribute(o, n.index2),
              e.push(r.x, r.y, r.z);
          }
        } else {
          const n = t.attributes.position;
          for (let t = 0, i = n.count / 3; t < i; t++)
            for (let i = 0; i < 3; i++) {
              const o = 3 * t + i;
              r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
              const s = 3 * t + ((i + 1) % 3);
              r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
            }
        }
      }
      this.setAttribute("position", new ne(e, 3));
    }
    function ho(t, e, n) {
      ze.call(this),
        (this.type = "ParametricGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n }),
        this.fromBufferGeometry(new po(t, e, n)),
        this.mergeVertices();
    }
    function po(t, e, n) {
      de.call(this),
        (this.type = "ParametricBufferGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n });
      const i = [],
        r = [],
        o = [],
        s = [],
        a = 1e-5,
        c = new w(),
        l = new w(),
        u = new w(),
        h = new w(),
        p = new w();
      t.length < 3 &&
        console.error(
          "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
        );
      const d = e + 1;
      for (let i = 0; i <= n; i++) {
        const d = i / n;
        for (let n = 0; n <= e; n++) {
          const i = n / e;
          t(i, d, l),
            r.push(l.x, l.y, l.z),
            i - a >= 0
              ? (t(i - a, d, u), h.subVectors(l, u))
              : (t(i + a, d, u), h.subVectors(u, l)),
            d - a >= 0
              ? (t(i, d - a, u), p.subVectors(l, u))
              : (t(i, d + a, u), p.subVectors(u, l)),
            c.crossVectors(h, p).normalize(),
            o.push(c.x, c.y, c.z),
            s.push(i, d);
        }
      }
      for (let t = 0; t < n; t++)
        for (let n = 0; n < e; n++) {
          const e = t * d + n,
            r = t * d + n + 1,
            o = (t + 1) * d + n + 1,
            s = (t + 1) * d + n;
          i.push(e, r, s), i.push(r, o, s);
        }
      this.setIndex(i),
        this.setAttribute("position", new ne(r, 3)),
        this.setAttribute("normal", new ne(o, 3)),
        this.setAttribute("uv", new ne(s, 2));
    }
    function fo(t, e, n, i) {
      ze.call(this),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
        this.fromBufferGeometry(new mo(t, e, n, i)),
        this.mergeVertices();
    }
    function mo(t, e, n, i) {
      de.call(this),
        (this.type = "PolyhedronBufferGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
        (n = n || 1);
      const r = [],
        o = [];
      function s(t, e, n, i) {
        const r = Math.pow(2, i),
          o = [];
        for (let i = 0; i <= r; i++) {
          o[i] = [];
          const s = t.clone().lerp(n, i / r),
            a = e.clone().lerp(n, i / r),
            c = r - i;
          for (let t = 0; t <= c; t++)
            o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c);
        }
        for (let t = 0; t < r; t++)
          for (let e = 0; e < 2 * (r - t) - 1; e++) {
            const n = Math.floor(e / 2);
            e % 2 == 0
              ? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n]))
              : (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n]));
          }
      }
      function a(t) {
        r.push(t.x, t.y, t.z);
      }
      function c(e, n) {
        const i = 3 * e;
        (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
      }
      function u(t, e, n, i) {
        i < 0 && 1 === t.x && (o[e] = t.x - 1),
          0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
      }
      function h(t) {
        return Math.atan2(t.z, -t.x);
      }
      !(function (t) {
        const n = new w(),
          i = new w(),
          r = new w();
        for (let o = 0; o < e.length; o += 3)
          c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t);
      })((i = i || 0)),
        (function (t) {
          const e = new w();
          for (let n = 0; n < r.length; n += 3)
            (e.x = r[n + 0]),
              (e.y = r[n + 1]),
              (e.z = r[n + 2]),
              e.normalize().multiplyScalar(t),
              (r[n + 0] = e.x),
              (r[n + 1] = e.y),
              (r[n + 2] = e.z);
        })(n),
        (function () {
          const t = new w();
          for (let n = 0; n < r.length; n += 3) {
            (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
            const i = h(t) / 2 / Math.PI + 0.5,
              s =
                ((e = t),
                Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
                  0.5);
            o.push(i, 1 - s);
          }
          var e;
          (function () {
            const t = new w(),
              e = new w(),
              n = new w(),
              i = new w(),
              s = new l(),
              a = new l(),
              c = new l();
            for (let l = 0, p = 0; l < r.length; l += 9, p += 6) {
              t.set(r[l + 0], r[l + 1], r[l + 2]),
                e.set(r[l + 3], r[l + 4], r[l + 5]),
                n.set(r[l + 6], r[l + 7], r[l + 8]),
                s.set(o[p + 0], o[p + 1]),
                a.set(o[p + 2], o[p + 3]),
                c.set(o[p + 4], o[p + 5]),
                i.copy(t).add(e).add(n).divideScalar(3);
              const d = h(i);
              u(s, p + 0, t, d), u(a, p + 2, e, d), u(c, p + 4, n, d);
            }
          })(),
            (function () {
              for (let t = 0; t < o.length; t += 6) {
                const e = o[t + 0],
                  n = o[t + 2],
                  i = o[t + 4],
                  r = Math.max(e, n, i),
                  s = Math.min(e, n, i);
                r > 0.9 &&
                  s < 0.1 &&
                  (e < 0.2 && (o[t + 0] += 1),
                  n < 0.2 && (o[t + 2] += 1),
                  i < 0.2 && (o[t + 4] += 1));
              }
            })();
        })(),
        this.setAttribute("position", new ne(r, 3)),
        this.setAttribute("normal", new ne(r.slice(), 3)),
        this.setAttribute("uv", new ne(o, 2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function go(t, e) {
      ze.call(this),
        (this.type = "TetrahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new vo(t, e)),
        this.mergeVertices();
    }
    function vo(t, e) {
      mo.call(
        this,
        [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
        t,
        e
      ),
        (this.type = "TetrahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function yo(t, e) {
      ze.call(this),
        (this.type = "OctahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new xo(t, e)),
        this.mergeVertices();
    }
    function xo(t, e) {
      mo.call(
        this,
        [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        [
          0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
          2,
        ],
        t,
        e
      ),
        (this.type = "OctahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function bo(t, e) {
      ze.call(this),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new wo(t, e)),
        this.mergeVertices();
    }
    function wo(t, e) {
      const n = (1 + Math.sqrt(5)) / 2,
        i = [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1,
        ];
      mo.call(
        this,
        i,
        [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        t,
        e
      ),
        (this.type = "IcosahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function _o(t, e) {
      ze.call(this),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Mo(t, e)),
        this.mergeVertices();
    }
    function Mo(t, e) {
      const n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n,
        r = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          0,
          -n,
          0,
          -i,
          n,
          0,
          -i,
          -n,
          0,
          i,
          n,
          0,
          i,
        ];
      mo.call(
        this,
        r,
        [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        t,
        e
      ),
        (this.type = "DodecahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function So(t, e, n, i, r, o) {
      ze.call(this),
        (this.type = "TubeGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r,
        }),
        void 0 !== o &&
          console.warn("THREE.TubeGeometry: taper has been removed.");
      const s = new To(t, e, n, i, r);
      (this.tangents = s.tangents),
        (this.normals = s.normals),
        (this.binormals = s.binormals),
        this.fromBufferGeometry(s),
        this.mergeVertices();
    }
    function To(t, e, n, i, r) {
      de.call(this),
        (this.type = "TubeBufferGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r,
        }),
        (e = e || 64),
        (n = n || 1),
        (i = i || 8),
        (r = r || !1);
      const o = t.computeFrenetFrames(e, r);
      (this.tangents = o.tangents),
        (this.normals = o.normals),
        (this.binormals = o.binormals);
      const s = new w(),
        a = new w(),
        c = new l();
      let u = new w();
      const h = [],
        p = [],
        d = [],
        f = [];
      function m(r) {
        u = t.getPointAt(r / e, u);
        const c = o.normals[r],
          l = o.binormals[r];
        for (let t = 0; t <= i; t++) {
          const e = (t / i) * Math.PI * 2,
            r = Math.sin(e),
            o = -Math.cos(e);
          (a.x = o * c.x + r * l.x),
            (a.y = o * c.y + r * l.y),
            (a.z = o * c.z + r * l.z),
            a.normalize(),
            p.push(a.x, a.y, a.z),
            (s.x = u.x + n * a.x),
            (s.y = u.y + n * a.y),
            (s.z = u.z + n * a.z),
            h.push(s.x, s.y, s.z);
        }
      }
      !(function () {
        for (let t = 0; t < e; t++) m(t);
        m(!1 === r ? e : 0),
          (function () {
            for (let t = 0; t <= e; t++)
              for (let n = 0; n <= i; n++)
                (c.x = t / e), (c.y = n / i), d.push(c.x, c.y);
          })(),
          (function () {
            for (let t = 1; t <= e; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  o = (i + 1) * t + e,
                  s = (i + 1) * (t - 1) + e;
                f.push(n, r, s), f.push(r, o, s);
              }
          })();
      })(),
        this.setIndex(f),
        this.setAttribute("position", new ne(h, 3)),
        this.setAttribute("normal", new ne(p, 3)),
        this.setAttribute("uv", new ne(d, 2));
    }
    function Eo(t, e, n, i, r, o, s) {
      ze.call(this),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: o,
        }),
        void 0 !== s &&
          console.warn(
            "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
          ),
        this.fromBufferGeometry(new Ao(t, e, n, i, r, o)),
        this.mergeVertices();
    }
    function Ao(t, e, n, i, r, o) {
      de.call(this),
        (this.type = "TorusKnotBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: o,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 64),
        (i = Math.floor(i) || 8),
        (r = r || 2),
        (o = o || 3);
      const s = [],
        a = [],
        c = [],
        l = [],
        u = new w(),
        h = new w(),
        p = new w(),
        d = new w(),
        f = new w(),
        m = new w(),
        g = new w();
      for (let s = 0; s <= n; ++s) {
        const y = (s / n) * r * Math.PI * 2;
        v(y, r, o, t, p),
          v(y + 0.01, r, o, t, d),
          m.subVectors(d, p),
          g.addVectors(d, p),
          f.crossVectors(m, g),
          g.crossVectors(f, m),
          f.normalize(),
          g.normalize();
        for (let t = 0; t <= i; ++t) {
          const r = (t / i) * Math.PI * 2,
            o = -e * Math.cos(r),
            d = e * Math.sin(r);
          (u.x = p.x + (o * g.x + d * f.x)),
            (u.y = p.y + (o * g.y + d * f.y)),
            (u.z = p.z + (o * g.z + d * f.z)),
            a.push(u.x, u.y, u.z),
            h.subVectors(u, p).normalize(),
            c.push(h.x, h.y, h.z),
            l.push(s / n),
            l.push(t / i);
        }
      }
      for (let t = 1; t <= n; t++)
        for (let e = 1; e <= i; e++) {
          const n = (i + 1) * (t - 1) + (e - 1),
            r = (i + 1) * t + (e - 1),
            o = (i + 1) * t + e,
            a = (i + 1) * (t - 1) + e;
          s.push(n, r, a), s.push(r, o, a);
        }
      function v(t, e, n, i, r) {
        const o = Math.cos(t),
          s = Math.sin(t),
          a = (n / e) * t,
          c = Math.cos(a);
        (r.x = i * (2 + c) * 0.5 * o),
          (r.y = i * (2 + c) * s * 0.5),
          (r.z = i * Math.sin(a) * 0.5);
      }
      this.setIndex(s),
        this.setAttribute("position", new ne(a, 3)),
        this.setAttribute("normal", new ne(c, 3)),
        this.setAttribute("uv", new ne(l, 2));
    }
    function Lo(t, e, n, i, r) {
      ze.call(this),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r,
        }),
        this.fromBufferGeometry(new Ro(t, e, n, i, r)),
        this.mergeVertices();
    }
    function Ro(t, e, n, i, r) {
      de.call(this),
        (this.type = "TorusBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 8),
        (i = Math.floor(i) || 6),
        (r = r || 2 * Math.PI);
      const o = [],
        s = [],
        a = [],
        c = [],
        l = new w(),
        u = new w(),
        h = new w();
      for (let o = 0; o <= n; o++)
        for (let p = 0; p <= i; p++) {
          const d = (p / i) * r,
            f = (o / n) * Math.PI * 2;
          (u.x = (t + e * Math.cos(f)) * Math.cos(d)),
            (u.y = (t + e * Math.cos(f)) * Math.sin(d)),
            (u.z = e * Math.sin(f)),
            s.push(u.x, u.y, u.z),
            (l.x = t * Math.cos(d)),
            (l.y = t * Math.sin(d)),
            h.subVectors(u, l).normalize(),
            a.push(h.x, h.y, h.z),
            c.push(p / i),
            c.push(o / n);
        }
      for (let t = 1; t <= n; t++)
        for (let e = 1; e <= i; e++) {
          const n = (i + 1) * t + e - 1,
            r = (i + 1) * (t - 1) + e - 1,
            s = (i + 1) * (t - 1) + e,
            a = (i + 1) * t + e;
          o.push(n, r, a), o.push(r, s, a);
        }
      this.setIndex(o),
        this.setAttribute("position", new ne(s, 3)),
        this.setAttribute("normal", new ne(a, 3)),
        this.setAttribute("uv", new ne(c, 2));
    }
    (ro.prototype = Object.assign(Object.create(X.prototype), {
      constructor: ro,
      isPoints: !0,
      copy: function (t) {
        return (
          X.prototype.copy.call(this, t),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      },
      raycast: function (t, e) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Points.threshold;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          no.copy(n.boundingSphere),
          no.applyMatrix4(i),
          (no.radius += r),
          !1 === t.ray.intersectsSphere(no))
        )
          return;
        to.getInverse(i), eo.copy(t.ray).applyMatrix4(to);
        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o;
        if (n.isBufferGeometry) {
          const r = n.index,
            o = n.attributes.position.array;
          if (null !== r) {
            const n = r.array;
            for (let r = 0, a = n.length; r < a; r++) {
              const a = n[r];
              io.fromArray(o, 3 * a), oo(io, a, s, i, t, e, this);
            }
          } else
            for (let n = 0, r = o.length / 3; n < r; n++)
              io.fromArray(o, 3 * n), oo(io, n, s, i, t, e, this);
        } else {
          const r = n.vertices;
          for (let n = 0, o = r.length; n < o; n++)
            oo(r[n], n, s, i, t, e, this);
        }
      },
      updateMorphTargets: function () {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
    })),
      (so.prototype = Object.assign(Object.create(f.prototype), {
        constructor: so,
        isVideoTexture: !0,
        update: function () {
          const t = this.image;
          t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        },
      })),
      (ao.prototype = Object.create(f.prototype)),
      (ao.prototype.constructor = ao),
      (ao.prototype.isCompressedTexture = !0),
      (co.prototype = Object.create(f.prototype)),
      (co.prototype.constructor = co),
      (co.prototype.isCanvasTexture = !0),
      (lo.prototype = Object.create(f.prototype)),
      (lo.prototype.constructor = lo),
      (lo.prototype.isDepthTexture = !0),
      (uo.prototype = Object.create(de.prototype)),
      (uo.prototype.constructor = uo),
      (ho.prototype = Object.create(ze.prototype)),
      (ho.prototype.constructor = ho),
      (po.prototype = Object.create(de.prototype)),
      (po.prototype.constructor = po),
      (fo.prototype = Object.create(ze.prototype)),
      (fo.prototype.constructor = fo),
      (mo.prototype = Object.create(de.prototype)),
      (mo.prototype.constructor = mo),
      (go.prototype = Object.create(ze.prototype)),
      (go.prototype.constructor = go),
      (vo.prototype = Object.create(mo.prototype)),
      (vo.prototype.constructor = vo),
      (yo.prototype = Object.create(ze.prototype)),
      (yo.prototype.constructor = yo),
      (xo.prototype = Object.create(mo.prototype)),
      (xo.prototype.constructor = xo),
      (bo.prototype = Object.create(ze.prototype)),
      (bo.prototype.constructor = bo),
      (wo.prototype = Object.create(mo.prototype)),
      (wo.prototype.constructor = wo),
      (_o.prototype = Object.create(ze.prototype)),
      (_o.prototype.constructor = _o),
      (Mo.prototype = Object.create(mo.prototype)),
      (Mo.prototype.constructor = Mo),
      (So.prototype = Object.create(ze.prototype)),
      (So.prototype.constructor = So),
      (To.prototype = Object.create(de.prototype)),
      (To.prototype.constructor = To),
      (To.prototype.toJSON = function () {
        const t = de.prototype.toJSON.call(this);
        return (t.path = this.parameters.path.toJSON()), t;
      }),
      (Eo.prototype = Object.create(ze.prototype)),
      (Eo.prototype.constructor = Eo),
      (Ao.prototype = Object.create(de.prototype)),
      (Ao.prototype.constructor = Ao),
      (Lo.prototype = Object.create(ze.prototype)),
      (Lo.prototype.constructor = Lo),
      (Ro.prototype = Object.create(de.prototype)),
      (Ro.prototype.constructor = Ro);
    const Po = function (t, e, n) {
      n = n || 2;
      let i,
        r,
        o,
        s,
        a,
        c,
        l,
        u = e && e.length,
        h = u ? e[0] * n : t.length,
        p = Co(t, 0, h, n, !0),
        d = [];
      if (!p || p.next === p.prev) return d;
      if (
        (u &&
          (p = (function (t, e, n, i) {
            let r,
              o,
              s,
              a,
              c,
              l = [];
            for (r = 0, o = e.length; r < o; r++)
              (s = e[r] * i),
                (a = r < o - 1 ? e[r + 1] * i : t.length),
                (c = Co(t, s, a, i, !1)),
                c === c.next && (c.steiner = !0),
                l.push(Go(c));
            for (l.sort(zo), r = 0; r < l.length; r++)
              Bo(l[r], n), (n = Oo(n, n.next));
            return n;
          })(t, e, p, n)),
        t.length > 80 * n)
      ) {
        (i = o = t[0]), (r = s = t[1]);
        for (let e = n; e < h; e += n)
          (a = t[e]),
            (c = t[e + 1]),
            a < i && (i = a),
            c < r && (r = c),
            a > o && (o = a),
            c > s && (s = c);
        (l = Math.max(o - i, s - r)), (l = 0 !== l ? 1 / l : 0);
      }
      return Io(p, d, n, i, r, l), d;
    };
    function Co(t, e, n, i, r) {
      let o, s;
      if (
        r ===
        (function (t, e, n, i) {
          let r = 0;
          for (let o = e, s = n - i; o < n; o += i)
            (r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
          return r;
        })(t, e, n, i) >
          0
      )
        for (o = e; o < n; o += i) s = $o(o, t[o], t[o + 1], s);
      else for (o = n - i; o >= e; o -= i) s = $o(o, t[o], t[o + 1], s);
      return s && qo(s, s.next) && (Qo(s), (s = s.next)), s;
    }
    function Oo(t, e) {
      if (!t) return t;
      e || (e = t);
      let n,
        i = t;
      do {
        if (
          ((n = !1),
          i.steiner || (!qo(i, i.next) && 0 !== Wo(i.prev, i, i.next)))
        )
          i = i.next;
        else {
          if ((Qo(i), (i = e = i.prev), i === i.next)) break;
          n = !0;
        }
      } while (n || i !== e);
      return e;
    }
    function Io(t, e, n, i, r, o, s) {
      if (!t) return;
      !s &&
        o &&
        (function (t, e, n, i) {
          let r = t;
          do {
            null === r.z && (r.z = Ho(r.x, r.y, e, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== t);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              let e,
                n,
                i,
                r,
                o,
                s,
                a,
                c,
                l = 1;
              do {
                for (n = t, t = null, o = null, s = 0; n; ) {
                  for (
                    s++, i = n, a = 0, e = 0;
                    e < l && (a++, (i = i.nextZ), i);
                    e++
                  );
                  for (c = l; a > 0 || (c > 0 && i); )
                    0 !== a && (0 === c || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), a--)
                      : ((r = i), (i = i.nextZ), c--),
                      o ? (o.nextZ = r) : (t = r),
                      (r.prevZ = o),
                      (o = r);
                  n = i;
                }
                (o.nextZ = null), (l *= 2);
              } while (s > 1);
            })(r);
        })(t, i, r, o);
      let a,
        c,
        l = t;
      for (; t.prev !== t.next; )
        if (((a = t.prev), (c = t.next), o ? No(t, i, r, o) : Do(t)))
          e.push(a.i / n),
            e.push(t.i / n),
            e.push(c.i / n),
            Qo(t),
            (t = c.next),
            (l = c.next);
        else if ((t = c) === l) {
          s
            ? 1 === s
              ? Io((t = ko(Oo(t), e, n)), e, n, i, r, o, 2)
              : 2 === s && Uo(t, e, n, i, r, o)
            : Io(Oo(t), e, n, i, r, o, 1);
          break;
        }
    }
    function Do(t) {
      let e = t.prev,
        n = t,
        i = t.next;
      if (Wo(e, n, i) >= 0) return !1;
      let r = t.next.next;
      for (; r !== t.prev; ) {
        if (
          jo(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
          Wo(r.prev, r, r.next) >= 0
        )
          return !1;
        r = r.next;
      }
      return !0;
    }
    function No(t, e, n, i) {
      let r = t.prev,
        o = t,
        s = t.next;
      if (Wo(r, o, s) >= 0) return !1;
      let a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
        c = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
        l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
        u = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
        h = Ho(a, c, e, n, i),
        p = Ho(l, u, e, n, i),
        d = t.prevZ,
        f = t.nextZ;
      for (; d && d.z >= h && f && f.z <= p; ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          jo(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) &&
          Wo(d.prev, d, d.next) >= 0
        )
          return !1;
        if (
          ((d = d.prevZ),
          f !== t.prev &&
            f !== t.next &&
            jo(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
            Wo(f.prev, f, f.next) >= 0)
        )
          return !1;
        f = f.nextZ;
      }
      for (; d && d.z >= h; ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          jo(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) &&
          Wo(d.prev, d, d.next) >= 0
        )
          return !1;
        d = d.prevZ;
      }
      for (; f && f.z <= p; ) {
        if (
          f !== t.prev &&
          f !== t.next &&
          jo(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
          Wo(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.nextZ;
      }
      return !0;
    }
    function ko(t, e, n) {
      let i = t;
      do {
        let r = i.prev,
          o = i.next.next;
        !qo(r, o) &&
          Xo(r, i, i.next, o) &&
          Jo(r, o) &&
          Jo(o, r) &&
          (e.push(r.i / n),
          e.push(i.i / n),
          e.push(o.i / n),
          Qo(i),
          Qo(i.next),
          (i = t = o)),
          (i = i.next);
      } while (i !== t);
      return Oo(i);
    }
    function Uo(t, e, n, i, r, o) {
      let s = t;
      do {
        let t = s.next.next;
        for (; t !== s.prev; ) {
          if (s.i !== t.i && Vo(s, t)) {
            let a = Ko(s, t);
            return (
              (s = Oo(s, s.next)),
              (a = Oo(a, a.next)),
              Io(s, e, n, i, r, o),
              void Io(a, e, n, i, r, o)
            );
          }
          t = t.next;
        }
        s = s.next;
      } while (s !== t);
    }
    function zo(t, e) {
      return t.x - e.x;
    }
    function Bo(t, e) {
      if (
        (e = (function (t, e) {
          let n,
            i = e,
            r = t.x,
            o = t.y,
            s = -1 / 0;
          do {
            if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
              let t = i.x + ((o - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (t <= r && t > s) {
                if (((s = t), t === r)) {
                  if (o === i.y) return i;
                  if (o === i.next.y) return i.next;
                }
                n = i.x < i.next.x ? i : i.next;
              }
            }
            i = i.next;
          } while (i !== e);
          if (!n) return null;
          if (r === s) return n;
          let a,
            c = n,
            l = n.x,
            u = n.y,
            h = 1 / 0;
          i = n;
          do {
            r >= i.x &&
              i.x >= l &&
              r !== i.x &&
              jo(o < u ? r : s, o, l, u, o < u ? s : r, o, i.x, i.y) &&
              ((a = Math.abs(o - i.y) / (r - i.x)),
              Jo(i, t) &&
                (a < h ||
                  (a === h && (i.x > n.x || (i.x === n.x && Fo(n, i))))) &&
                ((n = i), (h = a))),
              (i = i.next);
          } while (i !== c);
          return n;
        })(t, e))
      ) {
        const n = Ko(e, t);
        Oo(e, e.next), Oo(n, n.next);
      }
    }
    function Fo(t, e) {
      return Wo(t.prev, t, e.prev) < 0 && Wo(e.next, t, t.next) < 0;
    }
    function Ho(t, e, n, i, r) {
      return (
        (t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) |
        ((e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) <<
          1)
      );
    }
    function Go(t) {
      let e = t,
        n = t;
      do {
        (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
      } while (e !== t);
      return n;
    }
    function jo(t, e, n, i, r, o, s, a) {
      return (
        (r - s) * (e - a) - (t - s) * (o - a) >= 0 &&
        (t - s) * (i - a) - (n - s) * (e - a) >= 0 &&
        (n - s) * (o - a) - (r - s) * (i - a) >= 0
      );
    }
    function Vo(t, e) {
      return (
        t.next.i !== e.i &&
        t.prev.i !== e.i &&
        !(function (t, e) {
          let n = t;
          do {
            if (
              n.i !== t.i &&
              n.next.i !== t.i &&
              n.i !== e.i &&
              n.next.i !== e.i &&
              Xo(n, n.next, t, e)
            )
              return !0;
            n = n.next;
          } while (n !== t);
          return !1;
        })(t, e) &&
        ((Jo(t, e) &&
          Jo(e, t) &&
          (function (t, e) {
            let n = t,
              i = !1,
              r = (t.x + e.x) / 2,
              o = (t.y + e.y) / 2;
            do {
              n.y > o != n.next.y > o &&
                n.next.y !== n.y &&
                r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
                (i = !i),
                (n = n.next);
            } while (n !== t);
            return i;
          })(t, e) &&
          (Wo(t.prev, t, e.prev) || Wo(t, e.prev, e))) ||
          (qo(t, e) && Wo(t.prev, t, t.next) > 0 && Wo(e.prev, e, e.next) > 0))
      );
    }
    function Wo(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
    }
    function qo(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function Xo(t, e, n, i) {
      const r = Zo(Wo(t, e, n)),
        o = Zo(Wo(t, e, i)),
        s = Zo(Wo(n, i, t)),
        a = Zo(Wo(n, i, e));
      return (
        (r !== o && s !== a) ||
        !(0 !== r || !Yo(t, n, e)) ||
        !(0 !== o || !Yo(t, i, e)) ||
        !(0 !== s || !Yo(n, t, i)) ||
        !(0 !== a || !Yo(n, e, i))
      );
    }
    function Yo(t, e, n) {
      return (
        e.x <= Math.max(t.x, n.x) &&
        e.x >= Math.min(t.x, n.x) &&
        e.y <= Math.max(t.y, n.y) &&
        e.y >= Math.min(t.y, n.y)
      );
    }
    function Zo(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function Jo(t, e) {
      return Wo(t.prev, t, t.next) < 0
        ? Wo(t, e, t.next) >= 0 && Wo(t, t.prev, e) >= 0
        : Wo(t, e, t.prev) < 0 || Wo(t, t.next, e) < 0;
    }
    function Ko(t, e) {
      let n = new ts(t.i, t.x, t.y),
        i = new ts(e.i, e.x, e.y),
        r = t.next,
        o = e.prev;
      return (
        (t.next = e),
        (e.prev = t),
        (n.next = r),
        (r.prev = n),
        (i.next = n),
        (n.prev = i),
        (o.next = i),
        (i.prev = o),
        i
      );
    }
    function $o(t, e, n, i) {
      const r = new ts(t, e, n);
      return (
        i
          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function Qo(t) {
      (t.next.prev = t.prev),
        (t.prev.next = t.next),
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function ts(t, e, n) {
      (this.i = t),
        (this.x = e),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    const es = {
      area: function (t) {
        const e = t.length;
        let n = 0;
        for (let i = e - 1, r = 0; r < e; i = r++)
          n += t[i].x * t[r].y - t[r].x * t[i].y;
        return 0.5 * n;
      },
      isClockWise: function (t) {
        return es.area(t) < 0;
      },
      triangulateShape: function (t, e) {
        const n = [],
          i = [],
          r = [];
        ns(t), is(n, t);
        let o = t.length;
        e.forEach(ns);
        for (let t = 0; t < e.length; t++)
          i.push(o), (o += e[t].length), is(n, e[t]);
        const s = Po(n, i);
        for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
        return r;
      },
    };
    function ns(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function is(t, e) {
      for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
    }
    function rs(t, e) {
      ze.call(this),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: t, options: e }),
        this.fromBufferGeometry(new os(t, e)),
        this.mergeVertices();
    }
    function os(t, e) {
      de.call(this),
        (this.type = "ExtrudeBufferGeometry"),
        (this.parameters = { shapes: t, options: e }),
        (t = Array.isArray(t) ? t : [t]);
      const n = this,
        i = [],
        r = [];
      for (let e = 0, n = t.length; e < n; e++) {
        o(t[e]);
      }
      function o(t) {
        const o = [],
          s = void 0 !== e.curveSegments ? e.curveSegments : 12,
          a = void 0 !== e.steps ? e.steps : 1;
        let c = void 0 !== e.depth ? e.depth : 100,
          u = void 0 === e.bevelEnabled || e.bevelEnabled,
          h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
          p = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
          d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
          f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
        const m = e.extrudePath,
          g = void 0 !== e.UVGenerator ? e.UVGenerator : ss;
        void 0 !== e.amount &&
          (console.warn(
            "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
          ),
          (c = e.amount));
        let v,
          y,
          x,
          b,
          _,
          M = !1;
        m &&
          ((v = m.getSpacedPoints(a)),
          (M = !0),
          (u = !1),
          (y = m.computeFrenetFrames(a, !1)),
          (x = new w()),
          (b = new w()),
          (_ = new w())),
          u || ((f = 0), (h = 0), (p = 0), (d = 0));
        const S = t.extractPoints(s);
        let T = S.shape;
        const E = S.holes;
        if (!es.isClockWise(T)) {
          T = T.reverse();
          for (let t = 0, e = E.length; t < e; t++) {
            const e = E[t];
            es.isClockWise(e) && (E[t] = e.reverse());
          }
        }
        const A = es.triangulateShape(T, E),
          L = T;
        for (let t = 0, e = E.length; t < e; t++) {
          const e = E[t];
          T = T.concat(e);
        }
        function R(t, e, n) {
          return (
            e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(n).add(t)
          );
        }
        const P = T.length,
          C = A.length;
        function O(t, e, n) {
          let i, r, o;
          const s = t.x - e.x,
            a = t.y - e.y,
            c = n.x - t.x,
            u = n.y - t.y,
            h = s * s + a * a,
            p = s * u - a * c;
          if (Math.abs(p) > Number.EPSILON) {
            const p = Math.sqrt(h),
              d = Math.sqrt(c * c + u * u),
              f = e.x - a / p,
              m = e.y + s / p,
              g =
                ((n.x - u / d - f) * u - (n.y + c / d - m) * c) /
                (s * u - a * c);
            (i = f + s * g - t.x), (r = m + a * g - t.y);
            const v = i * i + r * r;
            if (v <= 2) return new l(i, r);
            o = Math.sqrt(v / 2);
          } else {
            let t = !1;
            s > Number.EPSILON
              ? c > Number.EPSILON && (t = !0)
              : s < -Number.EPSILON
              ? c < -Number.EPSILON && (t = !0)
              : Math.sign(a) === Math.sign(u) && (t = !0),
              t
                ? ((i = -a), (r = s), (o = Math.sqrt(h)))
                : ((i = s), (r = a), (o = Math.sqrt(h / 2)));
          }
          return new l(i / o, r / o);
        }
        const I = [];
        for (
          let t = 0, e = L.length, n = e - 1, i = t + 1;
          t < e;
          t++, n++, i++
        )
          n === e && (n = 0), i === e && (i = 0), (I[t] = O(L[t], L[n], L[i]));
        const D = [];
        let N,
          k = I.concat();
        for (let t = 0, e = E.length; t < e; t++) {
          const e = E[t];
          N = [];
          for (
            let t = 0, n = e.length, i = n - 1, r = t + 1;
            t < n;
            t++, i++, r++
          )
            i === n && (i = 0),
              r === n && (r = 0),
              (N[t] = O(e[t], e[i], e[r]));
          D.push(N), (k = k.concat(N));
        }
        for (let t = 0; t < f; t++) {
          const e = t / f,
            n = h * Math.cos((e * Math.PI) / 2),
            i = p * Math.sin((e * Math.PI) / 2) + d;
          for (let t = 0, e = L.length; t < e; t++) {
            const e = R(L[t], I[t], i);
            B(e.x, e.y, -n);
          }
          for (let t = 0, e = E.length; t < e; t++) {
            const e = E[t];
            N = D[t];
            for (let t = 0, r = e.length; t < r; t++) {
              const r = R(e[t], N[t], i);
              B(r.x, r.y, -n);
            }
          }
        }
        const U = p + d;
        for (let t = 0; t < P; t++) {
          const e = u ? R(T[t], k[t], U) : T[t];
          M
            ? (b.copy(y.normals[0]).multiplyScalar(e.x),
              x.copy(y.binormals[0]).multiplyScalar(e.y),
              _.copy(v[0]).add(b).add(x),
              B(_.x, _.y, _.z))
            : B(e.x, e.y, 0);
        }
        for (let t = 1; t <= a; t++)
          for (let e = 0; e < P; e++) {
            const n = u ? R(T[e], k[e], U) : T[e];
            M
              ? (b.copy(y.normals[t]).multiplyScalar(n.x),
                x.copy(y.binormals[t]).multiplyScalar(n.y),
                _.copy(v[t]).add(b).add(x),
                B(_.x, _.y, _.z))
              : B(n.x, n.y, (c / a) * t);
          }
        for (let t = f - 1; t >= 0; t--) {
          const e = t / f,
            n = h * Math.cos((e * Math.PI) / 2),
            i = p * Math.sin((e * Math.PI) / 2) + d;
          for (let t = 0, e = L.length; t < e; t++) {
            const e = R(L[t], I[t], i);
            B(e.x, e.y, c + n);
          }
          for (let t = 0, e = E.length; t < e; t++) {
            const e = E[t];
            N = D[t];
            for (let t = 0, r = e.length; t < r; t++) {
              const r = R(e[t], N[t], i);
              M ? B(r.x, r.y + v[a - 1].y, v[a - 1].x + n) : B(r.x, r.y, c + n);
            }
          }
        }
        function z(t, e) {
          let n = t.length;
          for (; --n >= 0; ) {
            const i = n;
            let r = n - 1;
            r < 0 && (r = t.length - 1);
            for (let t = 0, n = a + 2 * f; t < n; t++) {
              const n = P * t,
                o = P * (t + 1);
              H(e + i + n, e + r + n, e + r + o, e + i + o);
            }
          }
        }
        function B(t, e, n) {
          o.push(t), o.push(e), o.push(n);
        }
        function F(t, e, r) {
          G(t), G(e), G(r);
          const o = i.length / 3,
            s = g.generateTopUV(n, i, o - 3, o - 2, o - 1);
          j(s[0]), j(s[1]), j(s[2]);
        }
        function H(t, e, r, o) {
          G(t), G(e), G(o), G(e), G(r), G(o);
          const s = i.length / 3,
            a = g.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
          j(a[0]), j(a[1]), j(a[3]), j(a[1]), j(a[2]), j(a[3]);
        }
        function G(t) {
          i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]);
        }
        function j(t) {
          r.push(t.x), r.push(t.y);
        }
        !(function () {
          const t = i.length / 3;
          if (u) {
            let t = 0,
              e = P * t;
            for (let t = 0; t < C; t++) {
              const n = A[t];
              F(n[2] + e, n[1] + e, n[0] + e);
            }
            (t = a + 2 * f), (e = P * t);
            for (let t = 0; t < C; t++) {
              const n = A[t];
              F(n[0] + e, n[1] + e, n[2] + e);
            }
          } else {
            for (let t = 0; t < C; t++) {
              const e = A[t];
              F(e[2], e[1], e[0]);
            }
            for (let t = 0; t < C; t++) {
              const e = A[t];
              F(e[0] + P * a, e[1] + P * a, e[2] + P * a);
            }
          }
          n.addGroup(t, i.length / 3 - t, 0);
        })(),
          (function () {
            const t = i.length / 3;
            let e = 0;
            z(L, e), (e += L.length);
            for (let t = 0, n = E.length; t < n; t++) {
              const n = E[t];
              z(n, e), (e += n.length);
            }
            n.addGroup(t, i.length / 3 - t, 1);
          })();
      }
      this.setAttribute("position", new ne(i, 3)),
        this.setAttribute("uv", new ne(r, 2)),
        this.computeVertexNormals();
    }
    (rs.prototype = Object.create(ze.prototype)),
      (rs.prototype.constructor = rs),
      (rs.prototype.toJSON = function () {
        const t = ze.prototype.toJSON.call(this);
        return as(this.parameters.shapes, this.parameters.options, t);
      }),
      (os.prototype = Object.create(de.prototype)),
      (os.prototype.constructor = os),
      (os.prototype.toJSON = function () {
        const t = de.prototype.toJSON.call(this);
        return as(this.parameters.shapes, this.parameters.options, t);
      });
    const ss = {
      generateTopUV: function (t, e, n, i, r) {
        const o = e[3 * n],
          s = e[3 * n + 1],
          a = e[3 * i],
          c = e[3 * i + 1],
          u = e[3 * r],
          h = e[3 * r + 1];
        return [new l(o, s), new l(a, c), new l(u, h)];
      },
      generateSideWallUV: function (t, e, n, i, r, o) {
        const s = e[3 * n],
          a = e[3 * n + 1],
          c = e[3 * n + 2],
          u = e[3 * i],
          h = e[3 * i + 1],
          p = e[3 * i + 2],
          d = e[3 * r],
          f = e[3 * r + 1],
          m = e[3 * r + 2],
          g = e[3 * o],
          v = e[3 * o + 1],
          y = e[3 * o + 2];
        return Math.abs(a - h) < 0.01
          ? [new l(s, 1 - c), new l(u, 1 - p), new l(d, 1 - m), new l(g, 1 - y)]
          : [
              new l(a, 1 - c),
              new l(h, 1 - p),
              new l(f, 1 - m),
              new l(v, 1 - y),
            ];
      },
    };
    function as(t, e, n) {
      if (((n.shapes = []), Array.isArray(t)))
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e];
          n.shapes.push(i.uuid);
        }
      else n.shapes.push(t.uuid);
      return (
        void 0 !== e.extrudePath &&
          (n.options.extrudePath = e.extrudePath.toJSON()),
        n
      );
    }
    function cs(t, e) {
      ze.call(this),
        (this.type = "TextGeometry"),
        (this.parameters = { text: t, parameters: e }),
        this.fromBufferGeometry(new ls(t, e)),
        this.mergeVertices();
    }
    function ls(t, e) {
      const n = (e = e || {}).font;
      if (!n || !n.isFont)
        return (
          console.error(
            "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
          ),
          new ze()
        );
      const i = n.generateShapes(t, e.size);
      (e.depth = void 0 !== e.height ? e.height : 50),
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        os.call(this, i, e),
        (this.type = "TextBufferGeometry");
    }
    function us(t, e, n, i, r, o, s) {
      ze.call(this),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: o,
          thetaLength: s,
        }),
        this.fromBufferGeometry(new hs(t, e, n, i, r, o, s)),
        this.mergeVertices();
    }
    function hs(t, e, n, i, r, o, s) {
      de.call(this),
        (this.type = "SphereBufferGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: o,
          thetaLength: s,
        }),
        (t = t || 1),
        (e = Math.max(3, Math.floor(e) || 8)),
        (n = Math.max(2, Math.floor(n) || 6)),
        (i = void 0 !== i ? i : 0),
        (r = void 0 !== r ? r : 2 * Math.PI),
        (o = void 0 !== o ? o : 0),
        (s = void 0 !== s ? s : Math.PI);
      const a = Math.min(o + s, Math.PI);
      let c = 0;
      const l = [],
        u = new w(),
        h = new w(),
        p = [],
        d = [],
        f = [],
        m = [];
      for (let p = 0; p <= n; p++) {
        const g = [],
          v = p / n;
        let y = 0;
        0 == p && 0 == o
          ? (y = 0.5 / e)
          : p == n && a == Math.PI && (y = -0.5 / e);
        for (let n = 0; n <= e; n++) {
          const a = n / e;
          (u.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s)),
            (u.y = t * Math.cos(o + v * s)),
            (u.z = t * Math.sin(i + a * r) * Math.sin(o + v * s)),
            d.push(u.x, u.y, u.z),
            h.copy(u).normalize(),
            f.push(h.x, h.y, h.z),
            m.push(a + y, 1 - v),
            g.push(c++);
        }
        l.push(g);
      }
      for (let t = 0; t < n; t++)
        for (let i = 0; i < e; i++) {
          const e = l[t][i + 1],
            r = l[t][i],
            s = l[t + 1][i],
            c = l[t + 1][i + 1];
          (0 !== t || o > 0) && p.push(e, r, c),
            (t !== n - 1 || a < Math.PI) && p.push(r, s, c);
        }
      this.setIndex(p),
        this.setAttribute("position", new ne(d, 3)),
        this.setAttribute("normal", new ne(f, 3)),
        this.setAttribute("uv", new ne(m, 2));
    }
    function ps(t, e, n, i, r, o) {
      ze.call(this),
        (this.type = "RingGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: o,
        }),
        this.fromBufferGeometry(new ds(t, e, n, i, r, o)),
        this.mergeVertices();
    }
    function ds(t, e, n, i, r, o) {
      de.call(this),
        (this.type = "RingBufferGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: o,
        }),
        (t = t || 0.5),
        (e = e || 1),
        (r = void 0 !== r ? r : 0),
        (o = void 0 !== o ? o : 2 * Math.PI),
        (n = void 0 !== n ? Math.max(3, n) : 8);
      const s = [],
        a = [],
        c = [],
        u = [];
      let h = t;
      const p = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
        d = new w(),
        f = new l();
      for (let t = 0; t <= i; t++) {
        for (let t = 0; t <= n; t++) {
          const i = r + (t / n) * o;
          (d.x = h * Math.cos(i)),
            (d.y = h * Math.sin(i)),
            a.push(d.x, d.y, d.z),
            c.push(0, 0, 1),
            (f.x = (d.x / e + 1) / 2),
            (f.y = (d.y / e + 1) / 2),
            u.push(f.x, f.y);
        }
        h += p;
      }
      for (let t = 0; t < i; t++) {
        const e = t * (n + 1);
        for (let t = 0; t < n; t++) {
          const i = t + e,
            r = i,
            o = i + n + 1,
            a = i + n + 2,
            c = i + 1;
          s.push(r, o, c), s.push(o, a, c);
        }
      }
      this.setIndex(s),
        this.setAttribute("position", new ne(a, 3)),
        this.setAttribute("normal", new ne(c, 3)),
        this.setAttribute("uv", new ne(u, 2));
    }
    function fs(t, e, n, i) {
      ze.call(this),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i,
        }),
        this.fromBufferGeometry(new ms(t, e, n, i)),
        this.mergeVertices();
    }
    function ms(t, e, n, i) {
      de.call(this),
        (this.type = "LatheBufferGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i,
        }),
        (e = Math.floor(e) || 12),
        (n = n || 0),
        (i = i || 2 * Math.PI),
        (i = c.clamp(i, 0, 2 * Math.PI));
      const r = [],
        o = [],
        s = [],
        a = 1 / e,
        u = new w(),
        h = new l();
      for (let r = 0; r <= e; r++) {
        const c = n + r * a * i,
          l = Math.sin(c),
          p = Math.cos(c);
        for (let n = 0; n <= t.length - 1; n++)
          (u.x = t[n].x * l),
            (u.y = t[n].y),
            (u.z = t[n].x * p),
            o.push(u.x, u.y, u.z),
            (h.x = r / e),
            (h.y = n / (t.length - 1)),
            s.push(h.x, h.y);
      }
      for (let n = 0; n < e; n++)
        for (let e = 0; e < t.length - 1; e++) {
          const i = e + n * t.length,
            o = i,
            s = i + t.length,
            a = i + t.length + 1,
            c = i + 1;
          r.push(o, s, c), r.push(s, a, c);
        }
      if (
        (this.setIndex(r),
        this.setAttribute("position", new ne(o, 3)),
        this.setAttribute("uv", new ne(s, 2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI)
      ) {
        const n = this.attributes.normal.array,
          i = new w(),
          r = new w(),
          o = new w(),
          s = e * t.length * 3;
        for (let e = 0, a = 0; e < t.length; e++, a += 3)
          (i.x = n[a + 0]),
            (i.y = n[a + 1]),
            (i.z = n[a + 2]),
            (r.x = n[s + a + 0]),
            (r.y = n[s + a + 1]),
            (r.z = n[s + a + 2]),
            o.addVectors(i, r).normalize(),
            (n[a + 0] = n[s + a + 0] = o.x),
            (n[a + 1] = n[s + a + 1] = o.y),
            (n[a + 2] = n[s + a + 2] = o.z);
      }
    }
    function gs(t, e) {
      ze.call(this),
        (this.type = "ShapeGeometry"),
        "object" == typeof e &&
          (console.warn(
            "THREE.ShapeGeometry: Options parameter has been removed."
          ),
          (e = e.curveSegments)),
        (this.parameters = { shapes: t, curveSegments: e }),
        this.fromBufferGeometry(new vs(t, e)),
        this.mergeVertices();
    }
    function vs(t, e) {
      de.call(this),
        (this.type = "ShapeBufferGeometry"),
        (this.parameters = { shapes: t, curveSegments: e }),
        (e = e || 12);
      const n = [],
        i = [],
        r = [],
        o = [];
      let s = 0,
        a = 0;
      if (!1 === Array.isArray(t)) c(t);
      else
        for (let e = 0; e < t.length; e++)
          c(t[e]), this.addGroup(s, a, e), (s += a), (a = 0);
      function c(t) {
        const s = i.length / 3,
          c = t.extractPoints(e);
        let l = c.shape;
        const u = c.holes;
        !1 === es.isClockWise(l) && (l = l.reverse());
        for (let t = 0, e = u.length; t < e; t++) {
          const e = u[t];
          !0 === es.isClockWise(e) && (u[t] = e.reverse());
        }
        const h = es.triangulateShape(l, u);
        for (let t = 0, e = u.length; t < e; t++) {
          const e = u[t];
          l = l.concat(e);
        }
        for (let t = 0, e = l.length; t < e; t++) {
          const e = l[t];
          i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
        }
        for (let t = 0, e = h.length; t < e; t++) {
          const e = h[t],
            i = e[0] + s,
            r = e[1] + s,
            o = e[2] + s;
          n.push(i, r, o), (a += 3);
        }
      }
      this.setIndex(n),
        this.setAttribute("position", new ne(i, 3)),
        this.setAttribute("normal", new ne(r, 3)),
        this.setAttribute("uv", new ne(o, 2));
    }
    function ys(t, e) {
      if (((e.shapes = []), Array.isArray(t)))
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          e.shapes.push(i.uuid);
        }
      else e.shapes.push(t.uuid);
      return e;
    }
    function xs(t, e) {
      de.call(this),
        (this.type = "EdgesGeometry"),
        (this.parameters = { thresholdAngle: e }),
        (e = void 0 !== e ? e : 1);
      const n = [],
        i = Math.cos(c.DEG2RAD * e),
        r = [0, 0],
        o = {};
      let s, a, l;
      const u = ["a", "b", "c"];
      let h;
      t.isBufferGeometry
        ? ((h = new ze()), h.fromBufferGeometry(t))
        : (h = t.clone()),
        h.mergeVertices(),
        h.computeFaceNormals();
      const p = h.vertices,
        d = h.faces;
      for (let t = 0, e = d.length; t < e; t++) {
        const e = d[t];
        for (let n = 0; n < 3; n++)
          (s = e[u[n]]),
            (a = e[u[(n + 1) % 3]]),
            (r[0] = Math.min(s, a)),
            (r[1] = Math.max(s, a)),
            (l = r[0] + "," + r[1]),
            void 0 === o[l]
              ? (o[l] = { index1: r[0], index2: r[1], face1: t, face2: void 0 })
              : (o[l].face2 = t);
      }
      for (l in o) {
        const t = o[l];
        if (
          void 0 === t.face2 ||
          d[t.face1].normal.dot(d[t.face2].normal) <= i
        ) {
          let e = p[t.index1];
          n.push(e.x, e.y, e.z), (e = p[t.index2]), n.push(e.x, e.y, e.z);
        }
      }
      this.setAttribute("position", new ne(n, 3));
    }
    function bs(t, e, n, i, r, o, s, a) {
      ze.call(this),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: o,
          thetaStart: s,
          thetaLength: a,
        }),
        this.fromBufferGeometry(new ws(t, e, n, i, r, o, s, a)),
        this.mergeVertices();
    }
    function ws(t, e, n, i, r, o, s, a) {
      de.call(this),
        (this.type = "CylinderBufferGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: o,
          thetaStart: s,
          thetaLength: a,
        });
      const c = this;
      (t = void 0 !== t ? t : 1),
        (e = void 0 !== e ? e : 1),
        (n = n || 1),
        (i = Math.floor(i) || 8),
        (r = Math.floor(r) || 1),
        (o = void 0 !== o && o),
        (s = void 0 !== s ? s : 0),
        (a = void 0 !== a ? a : 2 * Math.PI);
      const u = [],
        h = [],
        p = [],
        d = [];
      let f = 0;
      const m = [],
        g = n / 2;
      let v = 0;
      function y(n) {
        let r, o;
        const m = new l(),
          y = new w();
        let x = 0;
        const b = !0 === n ? t : e,
          _ = !0 === n ? 1 : -1;
        r = f;
        for (let t = 1; t <= i; t++)
          h.push(0, g * _, 0), p.push(0, _, 0), d.push(0.5, 0.5), f++;
        o = f;
        for (let t = 0; t <= i; t++) {
          const e = (t / i) * a + s,
            n = Math.cos(e),
            r = Math.sin(e);
          (y.x = b * r),
            (y.y = g * _),
            (y.z = b * n),
            h.push(y.x, y.y, y.z),
            p.push(0, _, 0),
            (m.x = 0.5 * n + 0.5),
            (m.y = 0.5 * r * _ + 0.5),
            d.push(m.x, m.y),
            f++;
        }
        for (let t = 0; t < i; t++) {
          const e = r + t,
            i = o + t;
          !0 === n ? u.push(i, i + 1, e) : u.push(i + 1, i, e), (x += 3);
        }
        c.addGroup(v, x, !0 === n ? 1 : 2), (v += x);
      }
      !(function () {
        const o = new w(),
          l = new w();
        let y = 0;
        const x = (e - t) / n;
        for (let c = 0; c <= r; c++) {
          const u = [],
            v = c / r,
            y = v * (e - t) + t;
          for (let t = 0; t <= i; t++) {
            const e = t / i,
              r = e * a + s,
              c = Math.sin(r),
              m = Math.cos(r);
            (l.x = y * c),
              (l.y = -v * n + g),
              (l.z = y * m),
              h.push(l.x, l.y, l.z),
              o.set(c, x, m).normalize(),
              p.push(o.x, o.y, o.z),
              d.push(e, 1 - v),
              u.push(f++);
          }
          m.push(u);
        }
        for (let t = 0; t < i; t++)
          for (let e = 0; e < r; e++) {
            const n = m[e][t],
              i = m[e + 1][t],
              r = m[e + 1][t + 1],
              o = m[e][t + 1];
            u.push(n, i, o), u.push(i, r, o), (y += 6);
          }
        c.addGroup(v, y, 0), (v += y);
      })(),
        !1 === o && (t > 0 && y(!0), e > 0 && y(!1)),
        this.setIndex(u),
        this.setAttribute("position", new ne(h, 3)),
        this.setAttribute("normal", new ne(p, 3)),
        this.setAttribute("uv", new ne(d, 2));
    }
    function _s(t, e, n, i, r, o, s) {
      bs.call(this, 0, t, e, n, i, r, o, s),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: o,
          thetaLength: s,
        });
    }
    function Ms(t, e, n, i, r, o, s) {
      ws.call(this, 0, t, e, n, i, r, o, s),
        (this.type = "ConeBufferGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: o,
          thetaLength: s,
        });
    }
    function Ss(t, e, n, i) {
      ze.call(this),
        (this.type = "CircleGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i,
        }),
        this.fromBufferGeometry(new Ts(t, e, n, i)),
        this.mergeVertices();
    }
    function Ts(t, e, n, i) {
      de.call(this),
        (this.type = "CircleBufferGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i,
        }),
        (t = t || 1),
        (e = void 0 !== e ? Math.max(3, e) : 8),
        (n = void 0 !== n ? n : 0),
        (i = void 0 !== i ? i : 2 * Math.PI);
      const r = [],
        o = [],
        s = [],
        a = [],
        c = new w(),
        u = new l();
      o.push(0, 0, 0), s.push(0, 0, 1), a.push(0.5, 0.5);
      for (let r = 0, l = 3; r <= e; r++, l += 3) {
        const h = n + (r / e) * i;
        (c.x = t * Math.cos(h)),
          (c.y = t * Math.sin(h)),
          o.push(c.x, c.y, c.z),
          s.push(0, 0, 1),
          (u.x = (o[l] / t + 1) / 2),
          (u.y = (o[l + 1] / t + 1) / 2),
          a.push(u.x, u.y);
      }
      for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
      this.setIndex(r),
        this.setAttribute("position", new ne(o, 3)),
        this.setAttribute("normal", new ne(s, 3)),
        this.setAttribute("uv", new ne(a, 2));
    }
    (cs.prototype = Object.create(ze.prototype)),
      (cs.prototype.constructor = cs),
      (ls.prototype = Object.create(os.prototype)),
      (ls.prototype.constructor = ls),
      (us.prototype = Object.create(ze.prototype)),
      (us.prototype.constructor = us),
      (hs.prototype = Object.create(de.prototype)),
      (hs.prototype.constructor = hs),
      (ps.prototype = Object.create(ze.prototype)),
      (ps.prototype.constructor = ps),
      (ds.prototype = Object.create(de.prototype)),
      (ds.prototype.constructor = ds),
      (fs.prototype = Object.create(ze.prototype)),
      (fs.prototype.constructor = fs),
      (ms.prototype = Object.create(de.prototype)),
      (ms.prototype.constructor = ms),
      (gs.prototype = Object.create(ze.prototype)),
      (gs.prototype.constructor = gs),
      (gs.prototype.toJSON = function () {
        const t = ze.prototype.toJSON.call(this);
        return ys(this.parameters.shapes, t);
      }),
      (vs.prototype = Object.create(de.prototype)),
      (vs.prototype.constructor = vs),
      (vs.prototype.toJSON = function () {
        const t = de.prototype.toJSON.call(this);
        return ys(this.parameters.shapes, t);
      }),
      (xs.prototype = Object.create(de.prototype)),
      (xs.prototype.constructor = xs),
      (bs.prototype = Object.create(ze.prototype)),
      (bs.prototype.constructor = bs),
      (ws.prototype = Object.create(de.prototype)),
      (ws.prototype.constructor = ws),
      (_s.prototype = Object.create(bs.prototype)),
      (_s.prototype.constructor = _s),
      (Ms.prototype = Object.create(ws.prototype)),
      (Ms.prototype.constructor = Ms),
      (Ss.prototype = Object.create(ze.prototype)),
      (Ss.prototype.constructor = Ss),
      (Ts.prototype = Object.create(de.prototype)),
      (Ts.prototype.constructor = Ts);
    var Es = Object.freeze({
      __proto__: null,
      WireframeGeometry: uo,
      ParametricGeometry: ho,
      ParametricBufferGeometry: po,
      TetrahedronGeometry: go,
      TetrahedronBufferGeometry: vo,
      OctahedronGeometry: yo,
      OctahedronBufferGeometry: xo,
      IcosahedronGeometry: bo,
      IcosahedronBufferGeometry: wo,
      DodecahedronGeometry: _o,
      DodecahedronBufferGeometry: Mo,
      PolyhedronGeometry: fo,
      PolyhedronBufferGeometry: mo,
      TubeGeometry: So,
      TubeBufferGeometry: To,
      TorusKnotGeometry: Eo,
      TorusKnotBufferGeometry: Ao,
      TorusGeometry: Lo,
      TorusBufferGeometry: Ro,
      TextGeometry: cs,
      TextBufferGeometry: ls,
      SphereGeometry: us,
      SphereBufferGeometry: hs,
      RingGeometry: ps,
      RingBufferGeometry: ds,
      PlaneGeometry: en,
      PlaneBufferGeometry: nn,
      LatheGeometry: fs,
      LatheBufferGeometry: ms,
      ShapeGeometry: gs,
      ShapeBufferGeometry: vs,
      ExtrudeGeometry: rs,
      ExtrudeBufferGeometry: os,
      EdgesGeometry: xs,
      ConeGeometry: _s,
      ConeBufferGeometry: Ms,
      CylinderGeometry: bs,
      CylinderBufferGeometry: ws,
      CircleGeometry: Ss,
      CircleBufferGeometry: Ts,
      BoxGeometry: class extends ze {
        constructor(t, e, n, i, r, o) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            }),
            this.fromBufferGeometry(new Be(t, e, n, i, r, o)),
            this.mergeVertices();
        }
      },
      BoxBufferGeometry: Be,
    });
    function As(t) {
      Vt.call(this),
        (this.type = "ShadowMaterial"),
        (this.color = new zt(0)),
        (this.transparent = !0),
        this.setValues(t);
    }
    function Ls(t) {
      je.call(this, t), (this.type = "RawShaderMaterial");
    }
    function Rs(t) {
      Vt.call(this),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new zt(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new zt(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new l(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.vertexTangents = !1),
        this.setValues(t);
    }
    function Ps(t) {
      Rs.call(this),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.clearcoat = 0),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new l(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.reflectivity = 0.5),
        (this.sheen = null),
        (this.transparency = 0),
        this.setValues(t);
    }
    function Cs(t) {
      Vt.call(this),
        (this.type = "MeshPhongMaterial"),
        (this.color = new zt(16777215)),
        (this.specular = new zt(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new zt(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new l(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Os(t) {
      Vt.call(this),
        (this.defines = { TOON: "" }),
        (this.type = "MeshToonMaterial"),
        (this.color = new zt(16777215)),
        (this.map = null),
        (this.gradientMap = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new zt(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new l(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Is(t) {
      Vt.call(this),
        (this.type = "MeshNormalMaterial"),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new l(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Ds(t) {
      Vt.call(this),
        (this.type = "MeshLambertMaterial"),
        (this.color = new zt(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new zt(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Ns(t) {
      Vt.call(this),
        (this.defines = { MATCAP: "" }),
        (this.type = "MeshMatcapMaterial"),
        (this.color = new zt(16777215)),
        (this.matcap = null),
        (this.map = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new l(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function ks(t) {
      Gr.call(this),
        (this.type = "LineDashedMaterial"),
        (this.scale = 1),
        (this.dashSize = 3),
        (this.gapSize = 1),
        this.setValues(t);
    }
    (As.prototype = Object.create(Vt.prototype)),
      (As.prototype.constructor = As),
      (As.prototype.isShadowMaterial = !0),
      (As.prototype.copy = function (t) {
        return Vt.prototype.copy.call(this, t), this.color.copy(t.color), this;
      }),
      (Ls.prototype = Object.create(je.prototype)),
      (Ls.prototype.constructor = Ls),
      (Ls.prototype.isRawShaderMaterial = !0),
      (Rs.prototype = Object.create(Vt.prototype)),
      (Rs.prototype.constructor = Rs),
      (Rs.prototype.isMeshStandardMaterial = !0),
      (Rs.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "" }),
          this.color.copy(t.color),
          (this.roughness = t.roughness),
          (this.metalness = t.metalness),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.roughnessMap = t.roughnessMap),
          (this.metalnessMap = t.metalnessMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.envMapIntensity = t.envMapIntensity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.vertexTangents = t.vertexTangents),
          this
        );
      }),
      (Ps.prototype = Object.create(Rs.prototype)),
      (Ps.prototype.constructor = Ps),
      (Ps.prototype.isMeshPhysicalMaterial = !0),
      (Ps.prototype.copy = function (t) {
        return (
          Rs.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.clearcoat = t.clearcoat),
          (this.clearcoatMap = t.clearcoatMap),
          (this.clearcoatRoughness = t.clearcoatRoughness),
          (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = t.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
          (this.reflectivity = t.reflectivity),
          t.sheen
            ? (this.sheen = (this.sheen || new zt()).copy(t.sheen))
            : (this.sheen = null),
          (this.transparency = t.transparency),
          this
        );
      }),
      (Cs.prototype = Object.create(Vt.prototype)),
      (Cs.prototype.constructor = Cs),
      (Cs.prototype.isMeshPhongMaterial = !0),
      (Cs.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Os.prototype = Object.create(Vt.prototype)),
      (Os.prototype.constructor = Os),
      (Os.prototype.isMeshToonMaterial = !0),
      (Os.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.gradientMap = t.gradientMap),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Is.prototype = Object.create(Vt.prototype)),
      (Is.prototype.constructor = Is),
      (Is.prototype.isMeshNormalMaterial = !0),
      (Is.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Ds.prototype = Object.create(Vt.prototype)),
      (Ds.prototype.constructor = Ds),
      (Ds.prototype.isMeshLambertMaterial = !0),
      (Ds.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Ns.prototype = Object.create(Vt.prototype)),
      (Ns.prototype.constructor = Ns),
      (Ns.prototype.isMeshMatcapMaterial = !0),
      (Ns.prototype.copy = function (t) {
        return (
          Vt.prototype.copy.call(this, t),
          (this.defines = { MATCAP: "" }),
          this.color.copy(t.color),
          (this.matcap = t.matcap),
          (this.map = t.map),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (ks.prototype = Object.create(Gr.prototype)),
      (ks.prototype.constructor = ks),
      (ks.prototype.isLineDashedMaterial = !0),
      (ks.prototype.copy = function (t) {
        return (
          Gr.prototype.copy.call(this, t),
          (this.scale = t.scale),
          (this.dashSize = t.dashSize),
          (this.gapSize = t.gapSize),
          this
        );
      });
    var Us = Object.freeze({
      __proto__: null,
      ShadowMaterial: As,
      SpriteMaterial: dr,
      RawShaderMaterial: Ls,
      ShaderMaterial: je,
      PointsMaterial: Qr,
      MeshPhysicalMaterial: Ps,
      MeshStandardMaterial: Rs,
      MeshPhongMaterial: Cs,
      MeshToonMaterial: Os,
      MeshNormalMaterial: Is,
      MeshLambertMaterial: Ds,
      MeshDepthMaterial: Zi,
      MeshDistanceMaterial: Ji,
      MeshBasicMaterial: Wt,
      MeshMatcapMaterial: Ns,
      LineDashedMaterial: ks,
      LineBasicMaterial: Gr,
      Material: Vt,
    });
    const zs = {
      arraySlice: function (t, e, n) {
        return zs.isTypedArray(t)
          ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
          : t.slice(e, n);
      },
      convertArray: function (t, e, n) {
        return !t || (!n && t.constructor === e)
          ? t
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      },
      isTypedArray: function (t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      },
      getKeyframeOrder: function (t) {
        const e = t.length,
          n = new Array(e);
        for (let t = 0; t !== e; ++t) n[t] = t;
        return (
          n.sort(function (e, n) {
            return t[e] - t[n];
          }),
          n
        );
      },
      sortedArray: function (t, e, n) {
        const i = t.length,
          r = new t.constructor(i);
        for (let o = 0, s = 0; s !== i; ++o) {
          const i = n[o] * e;
          for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
        }
        return r;
      },
      flattenJSON: function (t, e, n, i) {
        let r = 1,
          o = t[0];
        for (; void 0 !== o && void 0 === o[i]; ) o = t[r++];
        if (void 0 === o) return;
        let s = o[i];
        if (void 0 !== s)
          if (Array.isArray(s))
            do {
              (s = o[i]),
                void 0 !== s && (e.push(o.time), n.push.apply(n, s)),
                (o = t[r++]);
            } while (void 0 !== o);
          else if (void 0 !== s.toArray)
            do {
              (s = o[i]),
                void 0 !== s && (e.push(o.time), s.toArray(n, n.length)),
                (o = t[r++]);
            } while (void 0 !== o);
          else
            do {
              (s = o[i]),
                void 0 !== s && (e.push(o.time), n.push(s)),
                (o = t[r++]);
            } while (void 0 !== o);
      },
      subclip: function (t, e, n, i, r) {
        r = r || 30;
        const o = t.clone();
        o.name = e;
        const s = [];
        for (let t = 0; t < o.tracks.length; ++t) {
          const e = o.tracks[t],
            a = e.getValueSize(),
            c = [],
            l = [];
          for (let t = 0; t < e.times.length; ++t) {
            const o = e.times[t] * r;
            if (!(o < n || o >= i)) {
              c.push(e.times[t]);
              for (let n = 0; n < a; ++n) l.push(e.values[t * a + n]);
            }
          }
          0 !== c.length &&
            ((e.times = zs.convertArray(c, e.times.constructor)),
            (e.values = zs.convertArray(l, e.values.constructor)),
            s.push(e));
        }
        o.tracks = s;
        let a = 1 / 0;
        for (let t = 0; t < o.tracks.length; ++t)
          a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
        for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
        return o.resetDuration(), o;
      },
      makeClipAdditive: function (t, e, n, i) {
        void 0 === e && (e = 0),
          void 0 === n && (n = t),
          (void 0 === i || i <= 0) && (i = 30);
        const r = t.tracks.length,
          o = e / i;
        for (let e = 0; e < r; ++e) {
          const i = n.tracks[e],
            r = i.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const s = t.tracks.find(function (t) {
            return t.name === i.name && t.ValueTypeName === r;
          });
          if (void 0 === s) continue;
          const a = i.getValueSize(),
            c = i.times.length - 1;
          let l;
          if (o <= i.times[0]) l = zs.arraySlice(i.values, 0, i.valueSize);
          else if (o >= i.times[c]) {
            const t = c * a;
            l = zs.arraySlice(i.values, t);
          } else {
            const t = i.createInterpolant();
            t.evaluate(o), (l = t.resultBuffer);
          }
          if ("quaternion" === r) {
            new y(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l);
          }
          const u = s.times.length;
          for (let t = 0; t < u; ++t) {
            const e = t * a;
            if ("quaternion" === r)
              y.multiplyQuaternionsFlat(s.values, e, l, 0, s.values, e);
            else for (let t = 0; t < a; ++t) s.values[e + t] -= l[t];
          }
        }
        return (t.blendMode = 2501), t;
      },
    };
    function Bs(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n);
    }
    function Fs(t, e, n, i) {
      Bs.call(this, t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0);
    }
    function Hs(t, e, n, i) {
      Bs.call(this, t, e, n, i);
    }
    function Gs(t, e, n, i) {
      Bs.call(this, t, e, n, i);
    }
    function js(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = zs.convertArray(e, this.TimeBufferType)),
        (this.values = zs.convertArray(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    function Vs(t, e, n) {
      js.call(this, t, e, n);
    }
    function Ws(t, e, n, i) {
      js.call(this, t, e, n, i);
    }
    function qs(t, e, n, i) {
      js.call(this, t, e, n, i);
    }
    function Xs(t, e, n, i) {
      Bs.call(this, t, e, n, i);
    }
    function Ys(t, e, n, i) {
      js.call(this, t, e, n, i);
    }
    function Zs(t, e, n, i) {
      js.call(this, t, e, n, i);
    }
    function Js(t, e, n, i) {
      js.call(this, t, e, n, i);
    }
    function Ks(t, e, n, i) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = void 0 !== e ? e : -1),
        (this.blendMode = void 0 !== i ? i : 2500),
        (this.uuid = c.generateUUID()),
        this.duration < 0 && this.resetDuration();
    }
    function $s(t) {
      if (void 0 === t.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      const e = (function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return qs;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Js;
          case "color":
            return Ws;
          case "quaternion":
            return Ys;
          case "bool":
          case "boolean":
            return Vs;
          case "string":
            return Zs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      })(t.type);
      if (void 0 === t.times) {
        const e = [],
          n = [];
        zs.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
      }
      return void 0 !== e.parse
        ? e.parse(t)
        : new e(t.name, t.times, t.values, t.interpolation);
    }
    Object.assign(Bs.prototype, {
      evaluate: function (t) {
        let e = this.parameterPositions,
          n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];
        t: {
          e: {
            let o;
            n: {
              i: if (!(t < i)) {
                for (let o = n + 2; ; ) {
                  if (void 0 === i) {
                    if (t < r) break i;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, t, r)
                    );
                  }
                  if (n === o) break;
                  if (((r = i), (i = e[++n]), t < i)) break e;
                }
                o = e.length;
                break n;
              }
              if (t >= r) break t;
              {
                const s = e[1];
                t < s && ((n = 2), (r = s));
                for (let o = n - 2; ; ) {
                  if (void 0 === r)
                    return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                  if (n === o) break;
                  if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                }
                (o = n), (n = 0);
              }
            }
            for (; n < o; ) {
              const i = (n + o) >>> 1;
              t < e[i] ? (o = i) : (n = i + 1);
            }
            if (((i = e[n]), (r = e[n - 1]), void 0 === r))
              return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
            if (void 0 === i)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, t)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, t, i);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function () {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function (t) {
        const e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i;
        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
        return e;
      },
      interpolate_: function () {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function () {},
    }),
      Object.assign(Bs.prototype, {
        beforeStart_: Bs.prototype.copySampleValue_,
        afterEnd_: Bs.prototype.copySampleValue_,
      }),
      (Fs.prototype = Object.assign(Object.create(Bs.prototype), {
        constructor: Fs,
        DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
        intervalChanged_: function (t, e, n) {
          let i = this.parameterPositions,
            r = t - 2,
            o = t + 1,
            s = i[r],
            a = i[o];
          if (void 0 === s)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (r = t), (s = 2 * e - n);
                break;
              case 2402:
                (r = i.length - 2), (s = e + i[r] - i[r + 1]);
                break;
              default:
                (r = t), (s = n);
            }
          if (void 0 === a)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (o = t), (a = 2 * n - e);
                break;
              case 2402:
                (o = 1), (a = n + i[1] - i[0]);
                break;
              default:
                (o = t - 1), (a = e);
            }
          const c = 0.5 * (n - e),
            l = this.valueSize;
          (this._weightPrev = c / (e - s)),
            (this._weightNext = c / (a - n)),
            (this._offsetPrev = r * l),
            (this._offsetNext = o * l);
        },
        interpolate_: function (t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            c = a - s,
            l = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            p = this._weightNext,
            d = (n - e) / (i - e),
            f = d * d,
            m = f * d,
            g = -h * m + 2 * h * f - h * d,
            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * d + 1,
            y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
            x = p * m - p * f;
          for (let t = 0; t !== s; ++t)
            r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + x * o[u + t];
          return r;
        },
      })),
      (Hs.prototype = Object.assign(Object.create(Bs.prototype), {
        constructor: Hs,
        interpolate_: function (t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            c = a - s,
            l = (n - e) / (i - e),
            u = 1 - l;
          for (let t = 0; t !== s; ++t) r[t] = o[c + t] * u + o[a + t] * l;
          return r;
        },
      })),
      (Gs.prototype = Object.assign(Object.create(Bs.prototype), {
        constructor: Gs,
        interpolate_: function (t) {
          return this.copySampleValue_(t - 1);
        },
      })),
      Object.assign(js, {
        toJSON: function (t) {
          const e = t.constructor;
          let n;
          if (void 0 !== e.toJSON) n = e.toJSON(t);
          else {
            n = {
              name: t.name,
              times: zs.convertArray(t.times, Array),
              values: zs.convertArray(t.values, Array),
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (n.interpolation = e);
          }
          return (n.type = t.ValueTypeName), n;
        },
      }),
      Object.assign(js.prototype, {
        constructor: js,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (t) {
          return new Gs(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodLinear: function (t) {
          return new Hs(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: function (t) {
          return new Fs(this.times, this.values, this.getValueSize(), t);
        },
        setInterpolation: function (t) {
          let e;
          switch (t) {
            case 2300:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            const e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        },
        getInterpolation: function () {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        },
        getValueSize: function () {
          return this.values.length / this.times.length;
        },
        shift: function (t) {
          if (0 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
          }
          return this;
        },
        scale: function (t) {
          if (1 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
          }
          return this;
        },
        trim: function (t, e) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < t; ) ++r;
          for (; -1 !== o && n[o] > e; ) --o;
          if ((++o, 0 !== r || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const t = this.getValueSize();
            (this.times = zs.arraySlice(n, r, o)),
              (this.values = zs.arraySlice(this.values, r * t, o * t));
          }
          return this;
        },
        validate: function () {
          let t = !0;
          const e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let o = null;
          for (let e = 0; e !== r; e++) {
            const i = n[e];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                e,
                i
              ),
                (t = !1);
              break;
            }
            if (null !== o && o > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                e,
                i,
                o
              ),
                (t = !1);
              break;
            }
            o = i;
          }
          if (void 0 !== i && zs.isTypedArray(i))
            for (let e = 0, n = i.length; e !== n; ++e) {
              const n = i[e];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  e,
                  n
                ),
                  (t = !1);
                break;
              }
            }
          return t;
        },
        optimize: function () {
          const t = zs.arraySlice(this.times),
            e = zs.arraySlice(this.values),
            n = this.getValueSize(),
            i = 2302 === this.getInterpolation(),
            r = t.length - 1;
          let o = 1;
          for (let s = 1; s < r; ++s) {
            let r = !1;
            const a = t[s];
            if (a !== t[s + 1] && (1 !== s || a !== a[0]))
              if (i) r = !0;
              else {
                const t = s * n,
                  i = t - n,
                  o = t + n;
                for (let s = 0; s !== n; ++s) {
                  const n = e[t + s];
                  if (n !== e[i + s] || n !== e[o + s]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (s !== o) {
                t[o] = t[s];
                const i = s * n,
                  r = o * n;
                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
              }
              ++o;
            }
          }
          if (r > 0) {
            t[o] = t[r];
            for (let t = r * n, i = o * n, s = 0; s !== n; ++s)
              e[i + s] = e[t + s];
            ++o;
          }
          return (
            o !== t.length
              ? ((this.times = zs.arraySlice(t, 0, o)),
                (this.values = zs.arraySlice(e, 0, o * n)))
              : ((this.times = t), (this.values = e)),
            this
          );
        },
        clone: function () {
          const t = zs.arraySlice(this.times, 0),
            e = zs.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, t, e);
          return (n.createInterpolant = this.createInterpolant), n;
        },
      }),
      (Vs.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Vs,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (Ws.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Ws,
        ValueTypeName: "color",
      })),
      (qs.prototype = Object.assign(Object.create(js.prototype), {
        constructor: qs,
        ValueTypeName: "number",
      })),
      (Xs.prototype = Object.assign(Object.create(Bs.prototype), {
        constructor: Xs,
        interpolate_: function (t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = (n - e) / (i - e);
          let c = t * s;
          for (let t = c + s; c !== t; c += 4)
            y.slerpFlat(r, 0, o, c - s, o, c, a);
          return r;
        },
      })),
      (Ys.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Ys,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
          return new Xs(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (Zs.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Zs,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (Js.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Js,
        ValueTypeName: "vector",
      })),
      Object.assign(Ks, {
        parse: function (t) {
          const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1);
          for (let t = 0, r = n.length; t !== r; ++t) e.push($s(n[t]).scale(i));
          return new Ks(t.name, t.duration, e, t.blendMode);
        },
        toJSON: function (t) {
          const e = [],
            n = t.tracks,
            i = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            };
          for (let t = 0, i = n.length; t !== i; ++t) e.push(js.toJSON(n[t]));
          return i;
        },
        CreateFromMorphTargetSequence: function (t, e, n, i) {
          const r = e.length,
            o = [];
          for (let t = 0; t < r; t++) {
            let s = [],
              a = [];
            s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
            const c = zs.getKeyframeOrder(s);
            (s = zs.sortedArray(s, 1, c)),
              (a = zs.sortedArray(a, 1, c)),
              i || 0 !== s[0] || (s.push(r), a.push(a[0])),
              o.push(
                new qs(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(
                  1 / n
                )
              );
          }
          return new Ks(t, -1, o);
        },
        findByName: function (t, e) {
          let n = t;
          if (!Array.isArray(t)) {
            const e = t;
            n = (e.geometry && e.geometry.animations) || e.animations;
          }
          for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
          return null;
        },
        CreateClipsFromMorphTargetSequences: function (t, e, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e],
              o = n.name.match(r);
            if (o && o.length > 1) {
              const t = o[1];
              let e = i[t];
              e || (i[t] = e = []), e.push(n);
            }
          }
          const o = [];
          for (const t in i)
            o.push(Ks.CreateFromMorphTargetSequence(t, i[t], e, n));
          return o;
        },
        parseAnimation: function (t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (t, e, n, i, r) {
              if (0 !== n.length) {
                const o = [],
                  s = [];
                zs.flattenJSON(n, o, s, i),
                  0 !== o.length && r.push(new t(e, o, s));
              }
            },
            i = [],
            r = t.name || "default",
            o = t.fps || 30,
            s = t.blendMode;
          let a = t.length || -1;
          const c = t.hierarchy || [];
          for (let t = 0; t < c.length; t++) {
            const r = c[t].keys;
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const t = {};
                let e;
                for (e = 0; e < r.length; e++)
                  if (r[e].morphTargets)
                    for (let n = 0; n < r[e].morphTargets.length; n++)
                      t[r[e].morphTargets[n]] = -1;
                for (const n in t) {
                  const t = [],
                    o = [];
                  for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                    const i = r[e];
                    t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
                  }
                  i.push(new qs(".morphTargetInfluence[" + n + "]", t, o));
                }
                a = t.length * (o || 1);
              } else {
                const o = ".bones[" + e[t].name + "]";
                n(Js, o + ".position", r, "pos", i),
                  n(Ys, o + ".quaternion", r, "rot", i),
                  n(Js, o + ".scale", r, "scl", i);
              }
          }
          if (0 === i.length) return null;
          return new Ks(r, a, i, s);
        },
      }),
      Object.assign(Ks.prototype, {
        resetDuration: function () {
          let t = 0;
          for (let e = 0, n = this.tracks.length; e !== n; ++e) {
            const n = this.tracks[e];
            t = Math.max(t, n.times[n.times.length - 1]);
          }
          return (this.duration = t), this;
        },
        trim: function () {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        },
        validate: function () {
          let t = !0;
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        },
        optimize: function () {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        },
        clone: function () {
          const t = [];
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new Ks(this.name, this.duration, t, this.blendMode);
        },
      });
    const Qs = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      },
    };
    function ta(t, e, n) {
      const i = this;
      let r = !1,
        o = 0,
        s = 0,
        a = void 0;
      const c = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), (r = !0);
        }),
        (this.itemEnd = function (t) {
          o++,
            void 0 !== i.onProgress && i.onProgress(t, o, s),
            o === s && ((r = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return a ? a(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (a = t), this;
        }),
        (this.addHandler = function (t, e) {
          return c.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          const e = c.indexOf(t);
          return -1 !== e && c.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (let e = 0, n = c.length; e < n; e += 2) {
            const n = c[e],
              i = c[e + 1];
            if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
          }
          return null;
        });
    }
    const ea = new ta();
    function na(t) {
      (this.manager = void 0 !== t ? t : ea),
        (this.crossOrigin = "anonymous"),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    Object.assign(na.prototype, {
      load: function () {},
      loadAsync: function (t, e) {
        const n = this;
        return new Promise(function (i, r) {
          n.load(t, i, e, r);
        });
      },
      parse: function () {},
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      },
      setResourcePath: function (t) {
        return (this.resourcePath = t), this;
      },
      setRequestHeader: function (t) {
        return (this.requestHeader = t), this;
      },
    });
    const ia = {};
    function ra(t) {
      na.call(this, t);
    }
    function oa(t) {
      na.call(this, t);
    }
    function sa(t) {
      na.call(this, t);
    }
    function aa(t) {
      na.call(this, t);
    }
    function ca(t) {
      na.call(this, t);
    }
    function la(t) {
      na.call(this, t);
    }
    function ua(t) {
      na.call(this, t);
    }
    function ha() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    function pa(t, e, n, i, r, o, s, a) {
      ha.call(this),
        (this.type = "EllipseCurve"),
        (this.aX = t || 0),
        (this.aY = e || 0),
        (this.xRadius = n || 1),
        (this.yRadius = i || 1),
        (this.aStartAngle = r || 0),
        (this.aEndAngle = o || 2 * Math.PI),
        (this.aClockwise = s || !1),
        (this.aRotation = a || 0);
    }
    function da(t, e, n, i, r, o) {
      pa.call(this, t, e, n, n, i, r, o), (this.type = "ArcCurve");
    }
    function fa() {
      let t = 0,
        e = 0,
        n = 0,
        i = 0;
      function r(r, o, s, a) {
        (t = r),
          (e = s),
          (n = -3 * r + 3 * o - 2 * s - a),
          (i = 2 * r - 2 * o + s + a);
      }
      return {
        initCatmullRom: function (t, e, n, i, o) {
          r(e, n, o * (n - t), o * (i - e));
        },
        initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
          let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
            l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
          (c *= s), (l *= s), r(e, n, c, l);
        },
        calc: function (r) {
          const o = r * r;
          return t + e * r + n * o + i * (o * r);
        },
      };
    }
    (ra.prototype = Object.assign(Object.create(na.prototype), {
      constructor: ra,
      load: function (t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        const r = this,
          o = Qs.get(t);
        if (void 0 !== o)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), r.manager.itemEnd(t);
            }, 0),
            o
          );
        if (void 0 !== ia[t])
          return void ia[t].push({ onLoad: e, onProgress: n, onError: i });
        const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        let a;
        if (s) {
          const n = s[1],
            o = !!s[2];
          let a = s[3];
          (a = decodeURIComponent(a)), o && (a = atob(a));
          try {
            let i;
            const o = (this.responseType || "").toLowerCase();
            switch (o) {
              case "arraybuffer":
              case "blob":
                const t = new Uint8Array(a.length);
                for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                i = "blob" === o ? new Blob([t.buffer], { type: n }) : t.buffer;
                break;
              case "document":
                const e = new DOMParser();
                i = e.parseFromString(a, n);
                break;
              case "json":
                i = JSON.parse(a);
                break;
              default:
                i = a;
            }
            setTimeout(function () {
              e && e(i), r.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }, 0);
          }
        } else {
          (ia[t] = []),
            ia[t].push({ onLoad: e, onProgress: n, onError: i }),
            (a = new XMLHttpRequest()),
            a.open("GET", t, !0),
            a.addEventListener(
              "load",
              function (e) {
                const n = this.response,
                  i = ia[t];
                if ((delete ia[t], 200 === this.status || 0 === this.status)) {
                  0 === this.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    Qs.add(t, n);
                  for (let t = 0, e = i.length; t < e; t++) {
                    const e = i[t];
                    e.onLoad && e.onLoad(n);
                  }
                  r.manager.itemEnd(t);
                } else {
                  for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    n.onError && n.onError(e);
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t);
                }
              },
              !1
            ),
            a.addEventListener(
              "progress",
              function (e) {
                const n = ia[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onProgress && i.onProgress(e);
                }
              },
              !1
            ),
            a.addEventListener(
              "error",
              function (e) {
                const n = ia[t];
                delete ia[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onError && i.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              },
              !1
            ),
            a.addEventListener(
              "abort",
              function (e) {
                const n = ia[t];
                delete ia[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onError && i.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              },
              !1
            ),
            void 0 !== this.responseType &&
              (a.responseType = this.responseType),
            void 0 !== this.withCredentials &&
              (a.withCredentials = this.withCredentials),
            a.overrideMimeType &&
              a.overrideMimeType(
                void 0 !== this.mimeType ? this.mimeType : "text/plain"
              );
          for (const t in this.requestHeader)
            a.setRequestHeader(t, this.requestHeader[t]);
          a.send(null);
        }
        return r.manager.itemStart(t), a;
      },
      setResponseType: function (t) {
        return (this.responseType = t), this;
      },
      setWithCredentials: function (t) {
        return (this.withCredentials = t), this;
      },
      setMimeType: function (t) {
        return (this.mimeType = t), this;
      },
    })),
      (oa.prototype = Object.assign(Object.create(na.prototype), {
        constructor: oa,
        load: function (t, e, n, i) {
          const r = this,
            o = new ra(r.manager);
          o.setPath(r.path),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        },
        parse: function (t) {
          const e = [];
          for (let n = 0; n < t.length; n++) {
            const i = Ks.parse(t[n]);
            e.push(i);
          }
          return e;
        },
      })),
      (sa.prototype = Object.assign(Object.create(na.prototype), {
        constructor: sa,
        load: function (t, e, n, i) {
          const r = this,
            o = [],
            s = new ao();
          s.image = o;
          const a = new ra(this.manager);
          a.setPath(this.path), a.setResponseType("arraybuffer");
          let c = 0;
          function l(l) {
            a.load(
              t[l],
              function (t) {
                const n = r.parse(t, !0);
                (o[l] = {
                  width: n.width,
                  height: n.height,
                  format: n.format,
                  mipmaps: n.mipmaps,
                }),
                  (c += 1),
                  6 === c &&
                    (1 === n.mipmapCount && (s.minFilter = 1006),
                    (s.format = n.format),
                    (s.needsUpdate = !0),
                    e && e(s));
              },
              n,
              i
            );
          }
          if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) l(e);
          else
            a.load(
              t,
              function (t) {
                const n = r.parse(t, !0);
                if (n.isCubemap) {
                  const t = n.mipmaps.length / n.mipmapCount;
                  for (let e = 0; e < t; e++) {
                    o[e] = { mipmaps: [] };
                    for (let t = 0; t < n.mipmapCount; t++)
                      o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                        (o[e].format = n.format),
                        (o[e].width = n.width),
                        (o[e].height = n.height);
                  }
                } else
                  (s.image.width = n.width),
                    (s.image.height = n.height),
                    (s.mipmaps = n.mipmaps);
                1 === n.mipmapCount && (s.minFilter = 1006),
                  (s.format = n.format),
                  (s.needsUpdate = !0),
                  e && e(s);
              },
              n,
              i
            );
          return s;
        },
      })),
      (aa.prototype = Object.assign(Object.create(na.prototype), {
        constructor: aa,
        load: function (t, e, n, i) {
          const r = this,
            o = new Ye(),
            s = new ra(this.manager);
          return (
            s.setResponseType("arraybuffer"),
            s.setPath(this.path),
            s.load(
              t,
              function (t) {
                const n = r.parse(t);
                n &&
                  (void 0 !== n.image
                    ? (o.image = n.image)
                    : void 0 !== n.data &&
                      ((o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.image.data = n.data)),
                  (o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001),
                  (o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001),
                  (o.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006),
                  (o.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
                  (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.format && (o.format = n.format),
                  void 0 !== n.type && (o.type = n.type),
                  void 0 !== n.mipmaps &&
                    ((o.mipmaps = n.mipmaps), (o.minFilter = 1008)),
                  1 === n.mipmapCount && (o.minFilter = 1006),
                  (o.needsUpdate = !0),
                  e && e(o, n));
              },
              n,
              i
            ),
            o
          );
        },
      })),
      (ca.prototype = Object.assign(Object.create(na.prototype), {
        constructor: ca,
        load: function (t, e, n, i) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            o = Qs.get(t);
          if (void 0 !== o)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), r.manager.itemEnd(t);
              }, 0),
              o
            );
          const s = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function a() {
            s.removeEventListener("load", a, !1),
              s.removeEventListener("error", c, !1),
              Qs.add(t, this),
              e && e(this),
              r.manager.itemEnd(t);
          }
          function c(e) {
            s.removeEventListener("load", a, !1),
              s.removeEventListener("error", c, !1),
              i && i(e),
              r.manager.itemError(t),
              r.manager.itemEnd(t);
          }
          return (
            s.addEventListener("load", a, !1),
            s.addEventListener("error", c, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (s.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (s.src = t),
            s
          );
        },
      })),
      (la.prototype = Object.assign(Object.create(na.prototype), {
        constructor: la,
        load: function (t, e, n, i) {
          const r = new xn(),
            o = new ca(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let s = 0;
          function a(n) {
            o.load(
              t[n],
              function (t) {
                (r.images[n] = t),
                  s++,
                  6 === s && ((r.needsUpdate = !0), e && e(r));
              },
              void 0,
              i
            );
          }
          for (let e = 0; e < t.length; ++e) a(e);
          return r;
        },
      })),
      (ua.prototype = Object.assign(Object.create(na.prototype), {
        constructor: ua,
        load: function (t, e, n, i) {
          const r = new f(),
            o = new ca(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              t,
              function (n) {
                r.image = n;
                const i =
                  t.search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/);
                (r.format = i ? 1022 : 1023),
                  (r.needsUpdate = !0),
                  void 0 !== e && e(r);
              },
              n,
              i
            ),
            r
          );
        },
      })),
      Object.assign(ha.prototype, {
        getPoint: function () {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        },
        getPointAt: function (t, e) {
          const n = this.getUtoTmapping(t);
          return this.getPoint(n, e);
        },
        getPoints: function (t) {
          void 0 === t && (t = 5);
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return e;
        },
        getSpacedPoints: function (t) {
          void 0 === t && (t = 5);
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
          return e;
        },
        getLength: function () {
          const t = this.getLengths();
          return t[t.length - 1];
        },
        getLengths: function (t) {
          if (
            (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate)
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const e = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          e.push(0);
          for (let o = 1; o <= t; o++)
            (n = this.getPoint(o / t)),
              (r += n.distanceTo(i)),
              e.push(r),
              (i = n);
          return (this.cacheArcLengths = e), e;
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0), this.getLengths();
        },
        getUtoTmapping: function (t, e) {
          const n = this.getLengths();
          let i,
            r = 0,
            o = n.length;
          i = e || t * n[o - 1];
          let s,
            a = 0,
            c = o - 1;
          for (; a <= c; )
            if (((r = Math.floor(a + (c - a) / 2)), (s = n[r] - i), s < 0))
              a = r + 1;
            else {
              if (!(s > 0)) {
                c = r;
                break;
              }
              c = r - 1;
            }
          if (((r = c), n[r] === i)) return r / (o - 1);
          const l = n[r];
          return (r + (i - l) / (n[r + 1] - l)) / (o - 1);
        },
        getTangent: function (t, e) {
          let n = t - 1e-4,
            i = t + 1e-4;
          n < 0 && (n = 0), i > 1 && (i = 1);
          const r = this.getPoint(n),
            o = this.getPoint(i),
            s = e || (r.isVector2 ? new l() : new w());
          return s.copy(o).sub(r).normalize(), s;
        },
        getTangentAt: function (t, e) {
          const n = this.getUtoTmapping(t);
          return this.getTangent(n, e);
        },
        computeFrenetFrames: function (t, e) {
          const n = new w(),
            i = [],
            r = [],
            o = [],
            s = new w(),
            a = new R();
          for (let e = 0; e <= t; e++) {
            const n = e / t;
            (i[e] = this.getTangentAt(n, new w())), i[e].normalize();
          }
          (r[0] = new w()), (o[0] = new w());
          let l = Number.MAX_VALUE;
          const u = Math.abs(i[0].x),
            h = Math.abs(i[0].y),
            p = Math.abs(i[0].z);
          u <= l && ((l = u), n.set(1, 0, 0)),
            h <= l && ((l = h), n.set(0, 1, 0)),
            p <= l && n.set(0, 0, 1),
            s.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], s),
            o[0].crossVectors(i[0], r[0]);
          for (let e = 1; e <= t; e++) {
            if (
              ((r[e] = r[e - 1].clone()),
              (o[e] = o[e - 1].clone()),
              s.crossVectors(i[e - 1], i[e]),
              s.length() > Number.EPSILON)
            ) {
              s.normalize();
              const t = Math.acos(c.clamp(i[e - 1].dot(i[e]), -1, 1));
              r[e].applyMatrix4(a.makeRotationAxis(s, t));
            }
            o[e].crossVectors(i[e], r[e]);
          }
          if (!0 === e) {
            let e = Math.acos(c.clamp(r[0].dot(r[t]), -1, 1));
            (e /= t), i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
            for (let n = 1; n <= t; n++)
              r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                o[n].crossVectors(i[n], r[n]);
          }
          return { tangents: i, normals: r, binormals: o };
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        },
        toJSON: function () {
          const t = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        },
        fromJSON: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        },
      }),
      (pa.prototype = Object.create(ha.prototype)),
      (pa.prototype.constructor = pa),
      (pa.prototype.isEllipseCurve = !0),
      (pa.prototype.getPoint = function (t, e) {
        const n = e || new l(),
          i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0; ) r += i;
        for (; r > i; ) r -= i;
        r < Number.EPSILON && (r = o ? 0 : i),
          !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
        const s = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(s),
          c = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
          const t = Math.cos(this.aRotation),
            e = Math.sin(this.aRotation),
            n = a - this.aX,
            i = c - this.aY;
          (a = n * t - i * e + this.aX), (c = n * e + i * t + this.aY);
        }
        return n.set(a, c);
      }),
      (pa.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (pa.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (
          (t.aX = this.aX),
          (t.aY = this.aY),
          (t.xRadius = this.xRadius),
          (t.yRadius = this.yRadius),
          (t.aStartAngle = this.aStartAngle),
          (t.aEndAngle = this.aEndAngle),
          (t.aClockwise = this.aClockwise),
          (t.aRotation = this.aRotation),
          t
        );
      }),
      (pa.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (da.prototype = Object.create(pa.prototype)),
      (da.prototype.constructor = da),
      (da.prototype.isArcCurve = !0);
    const ma = new w(),
      ga = new fa(),
      va = new fa(),
      ya = new fa();
    function xa(t, e, n, i) {
      ha.call(this),
        (this.type = "CatmullRomCurve3"),
        (this.points = t || []),
        (this.closed = e || !1),
        (this.curveType = n || "centripetal"),
        (this.tension = i || 0.5);
    }
    function ba(t, e, n, i, r) {
      const o = 0.5 * (i - e),
        s = 0.5 * (r - n),
        a = t * t;
      return (
        (2 * n - 2 * i + o + s) * (t * a) +
        (-3 * n + 3 * i - 2 * o - s) * a +
        o * t +
        n
      );
    }
    function wa(t, e, n, i) {
      return (
        (function (t, e) {
          const n = 1 - t;
          return n * n * e;
        })(t, e) +
        (function (t, e) {
          return 2 * (1 - t) * t * e;
        })(t, n) +
        (function (t, e) {
          return t * t * e;
        })(t, i)
      );
    }
    function _a(t, e, n, i, r) {
      return (
        (function (t, e) {
          const n = 1 - t;
          return n * n * n * e;
        })(t, e) +
        (function (t, e) {
          const n = 1 - t;
          return 3 * n * n * t * e;
        })(t, n) +
        (function (t, e) {
          return 3 * (1 - t) * t * t * e;
        })(t, i) +
        (function (t, e) {
          return t * t * t * e;
        })(t, r)
      );
    }
    function Ma(t, e, n, i) {
      ha.call(this),
        (this.type = "CubicBezierCurve"),
        (this.v0 = t || new l()),
        (this.v1 = e || new l()),
        (this.v2 = n || new l()),
        (this.v3 = i || new l());
    }
    function Sa(t, e, n, i) {
      ha.call(this),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = t || new w()),
        (this.v1 = e || new w()),
        (this.v2 = n || new w()),
        (this.v3 = i || new w());
    }
    function Ta(t, e) {
      ha.call(this),
        (this.type = "LineCurve"),
        (this.v1 = t || new l()),
        (this.v2 = e || new l());
    }
    function Ea(t, e) {
      ha.call(this),
        (this.type = "LineCurve3"),
        (this.v1 = t || new w()),
        (this.v2 = e || new w());
    }
    function Aa(t, e, n) {
      ha.call(this),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = t || new l()),
        (this.v1 = e || new l()),
        (this.v2 = n || new l());
    }
    function La(t, e, n) {
      ha.call(this),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = t || new w()),
        (this.v1 = e || new w()),
        (this.v2 = n || new w());
    }
    function Ra(t) {
      ha.call(this), (this.type = "SplineCurve"), (this.points = t || []);
    }
    (xa.prototype = Object.create(ha.prototype)),
      (xa.prototype.constructor = xa),
      (xa.prototype.isCatmullRomCurve3 = !0),
      (xa.prototype.getPoint = function (t, e) {
        const n = e || new w(),
          i = this.points,
          r = i.length,
          o = (r - (this.closed ? 0 : 1)) * t;
        let s,
          a,
          c,
          l,
          u = Math.floor(o),
          h = o - u;
        if (
          (this.closed
            ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r)
            : 0 === h && u === r - 1 && ((u = r - 2), (h = 1)),
          this.closed || u > 0
            ? (s = i[(u - 1) % r])
            : (ma.subVectors(i[0], i[1]).add(i[0]), (s = ma)),
          (a = i[u % r]),
          (c = i[(u + 1) % r]),
          this.closed || u + 2 < r
            ? (l = i[(u + 2) % r])
            : (ma.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (l = ma)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          const t = "chordal" === this.curveType ? 0.5 : 0.25;
          let e = Math.pow(s.distanceToSquared(a), t),
            n = Math.pow(a.distanceToSquared(c), t),
            i = Math.pow(c.distanceToSquared(l), t);
          n < 1e-4 && (n = 1),
            e < 1e-4 && (e = n),
            i < 1e-4 && (i = n),
            ga.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i),
            va.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i),
            ya.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i);
        } else
          "catmullrom" === this.curveType &&
            (ga.initCatmullRom(s.x, a.x, c.x, l.x, this.tension),
            va.initCatmullRom(s.y, a.y, c.y, l.y, this.tension),
            ya.initCatmullRom(s.z, a.z, c.z, l.z, this.tension));
        return n.set(ga.calc(h), va.calc(h), ya.calc(h)), n;
      }),
      (xa.prototype.copy = function (t) {
        ha.prototype.copy.call(this, t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone());
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (xa.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray());
        }
        return (
          (t.closed = this.closed),
          (t.curveType = this.curveType),
          (t.tension = this.tension),
          t
        );
      }),
      (xa.prototype.fromJSON = function (t) {
        ha.prototype.fromJSON.call(this, t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(new w().fromArray(n));
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (Ma.prototype = Object.create(ha.prototype)),
      (Ma.prototype.constructor = Ma),
      (Ma.prototype.isCubicBezierCurve = !0),
      (Ma.prototype.getPoint = function (t, e) {
        const n = e || new l(),
          i = this.v0,
          r = this.v1,
          o = this.v2,
          s = this.v3;
        return n.set(_a(t, i.x, r.x, o.x, s.x), _a(t, i.y, r.y, o.y, s.y)), n;
      }),
      (Ma.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Ma.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Ma.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Sa.prototype = Object.create(ha.prototype)),
      (Sa.prototype.constructor = Sa),
      (Sa.prototype.isCubicBezierCurve3 = !0),
      (Sa.prototype.getPoint = function (t, e) {
        const n = e || new w(),
          i = this.v0,
          r = this.v1,
          o = this.v2,
          s = this.v3;
        return (
          n.set(
            _a(t, i.x, r.x, o.x, s.x),
            _a(t, i.y, r.y, o.y, s.y),
            _a(t, i.z, r.z, o.z, s.z)
          ),
          n
        );
      }),
      (Sa.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Sa.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Sa.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Ta.prototype = Object.create(ha.prototype)),
      (Ta.prototype.constructor = Ta),
      (Ta.prototype.isLineCurve = !0),
      (Ta.prototype.getPoint = function (t, e) {
        const n = e || new l();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (Ta.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (Ta.prototype.getTangent = function (t, e) {
        const n = e || new l();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }),
      (Ta.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Ta.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      (Ta.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Ea.prototype = Object.create(ha.prototype)),
      (Ea.prototype.constructor = Ea),
      (Ea.prototype.isLineCurve3 = !0),
      (Ea.prototype.getPoint = function (t, e) {
        const n = e || new w();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (Ea.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (Ea.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Ea.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      (Ea.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Aa.prototype = Object.create(ha.prototype)),
      (Aa.prototype.constructor = Aa),
      (Aa.prototype.isQuadraticBezierCurve = !0),
      (Aa.prototype.getPoint = function (t, e) {
        const n = e || new l(),
          i = this.v0,
          r = this.v1,
          o = this.v2;
        return n.set(wa(t, i.x, r.x, o.x), wa(t, i.y, r.y, o.y)), n;
      }),
      (Aa.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Aa.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (Aa.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (La.prototype = Object.create(ha.prototype)),
      (La.prototype.constructor = La),
      (La.prototype.isQuadraticBezierCurve3 = !0),
      (La.prototype.getPoint = function (t, e) {
        const n = e || new w(),
          i = this.v0,
          r = this.v1,
          o = this.v2;
        return (
          n.set(
            wa(t, i.x, r.x, o.x),
            wa(t, i.y, r.y, o.y),
            wa(t, i.z, r.z, o.z)
          ),
          n
        );
      }),
      (La.prototype.copy = function (t) {
        return (
          ha.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (La.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (La.prototype.fromJSON = function (t) {
        return (
          ha.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Ra.prototype = Object.create(ha.prototype)),
      (Ra.prototype.constructor = Ra),
      (Ra.prototype.isSplineCurve = !0),
      (Ra.prototype.getPoint = function (t, e) {
        const n = e || new l(),
          i = this.points,
          r = (i.length - 1) * t,
          o = Math.floor(r),
          s = r - o,
          a = i[0 === o ? o : o - 1],
          c = i[o],
          u = i[o > i.length - 2 ? i.length - 1 : o + 1],
          h = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(ba(s, a.x, c.x, u.x, h.x), ba(s, a.y, c.y, u.y, h.y)), n;
      }),
      (Ra.prototype.copy = function (t) {
        ha.prototype.copy.call(this, t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone());
        }
        return this;
      }),
      (Ra.prototype.toJSON = function () {
        const t = ha.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray());
        }
        return t;
      }),
      (Ra.prototype.fromJSON = function (t) {
        ha.prototype.fromJSON.call(this, t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(new l().fromArray(n));
        }
        return this;
      });
    var Pa = Object.freeze({
      __proto__: null,
      ArcCurve: da,
      CatmullRomCurve3: xa,
      CubicBezierCurve: Ma,
      CubicBezierCurve3: Sa,
      EllipseCurve: pa,
      LineCurve: Ta,
      LineCurve3: Ea,
      QuadraticBezierCurve: Aa,
      QuadraticBezierCurve3: La,
      SplineCurve: Ra,
    });
    function Ca() {
      ha.call(this),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    function Oa(t) {
      Ca.call(this),
        (this.type = "Path"),
        (this.currentPoint = new l()),
        t && this.setFromPoints(t);
    }
    function Ia(t) {
      Oa.call(this, t),
        (this.uuid = c.generateUUID()),
        (this.type = "Shape"),
        (this.holes = []);
    }
    function Da(t, e) {
      X.call(this),
        (this.type = "Light"),
        (this.color = new zt(t)),
        (this.intensity = void 0 !== e ? e : 1),
        (this.receiveShadow = void 0);
    }
    function Na(t, e, n) {
      Da.call(this, t, n),
        (this.type = "HemisphereLight"),
        (this.castShadow = void 0),
        this.position.copy(X.DefaultUp),
        this.updateMatrix(),
        (this.groundColor = new zt(e));
    }
    function ka(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.mapSize = new l(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new R()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new Ke()),
        (this._frameExtents = new l(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new m(0, 0, 1, 1)]);
    }
    function Ua() {
      ka.call(this, new We(50, 1, 0.5, 500));
    }
    function za(t, e, n, i, r, o) {
      Da.call(this, t, e),
        (this.type = "SpotLight"),
        this.position.copy(X.DefaultUp),
        this.updateMatrix(),
        (this.target = new X()),
        Object.defineProperty(this, "power", {
          get: function () {
            return this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / Math.PI;
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.angle = void 0 !== i ? i : Math.PI / 3),
        (this.penumbra = void 0 !== r ? r : 0),
        (this.decay = void 0 !== o ? o : 1),
        (this.shadow = new Ua());
    }
    function Ba() {
      ka.call(this, new We(90, 1, 0.5, 500)),
        (this._frameExtents = new l(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new m(2, 1, 1, 1),
          new m(0, 1, 1, 1),
          new m(3, 1, 1, 1),
          new m(1, 1, 1, 1),
          new m(3, 0, 1, 1),
          new m(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new w(1, 0, 0),
          new w(-1, 0, 0),
          new w(0, 0, 1),
          new w(0, 0, -1),
          new w(0, 1, 0),
          new w(0, -1, 0),
        ]),
        (this._cubeUps = [
          new w(0, 1, 0),
          new w(0, 1, 0),
          new w(0, 1, 0),
          new w(0, 1, 0),
          new w(0, 0, 1),
          new w(0, 0, -1),
        ]);
    }
    function Fa(t, e, n, i) {
      Da.call(this, t, e),
        (this.type = "PointLight"),
        Object.defineProperty(this, "power", {
          get: function () {
            return 4 * this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / (4 * Math.PI);
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.decay = void 0 !== i ? i : 1),
        (this.shadow = new Ba());
    }
    function Ha(t, e, n, i, r, o) {
      Ve.call(this),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = void 0 !== t ? t : -1),
        (this.right = void 0 !== e ? e : 1),
        (this.top = void 0 !== n ? n : 1),
        (this.bottom = void 0 !== i ? i : -1),
        (this.near = void 0 !== r ? r : 0.1),
        (this.far = void 0 !== o ? o : 2e3),
        this.updateProjectionMatrix();
    }
    function Ga() {
      ka.call(this, new Ha(-5, 5, 5, -5, 0.5, 500));
    }
    function ja(t, e) {
      Da.call(this, t, e),
        (this.type = "DirectionalLight"),
        this.position.copy(X.DefaultUp),
        this.updateMatrix(),
        (this.target = new X()),
        (this.shadow = new Ga());
    }
    function Va(t, e) {
      Da.call(this, t, e),
        (this.type = "AmbientLight"),
        (this.castShadow = void 0);
    }
    function Wa(t, e, n, i) {
      Da.call(this, t, e),
        (this.type = "RectAreaLight"),
        (this.width = void 0 !== n ? n : 10),
        (this.height = void 0 !== i ? i : 10);
    }
    function qa() {
      this.coefficients = [];
      for (let t = 0; t < 9; t++) this.coefficients.push(new w());
    }
    function Xa(t, e) {
      Da.call(this, void 0, e),
        (this.type = "LightProbe"),
        (this.sh = void 0 !== t ? t : new qa());
    }
    function Ya(t) {
      na.call(this, t), (this.textures = {});
    }
    (Ca.prototype = Object.assign(Object.create(ha.prototype), {
      constructor: Ca,
      add: function (t) {
        this.curves.push(t);
      },
      closePath: function () {
        const t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new Ta(e, t));
      },
      getPoint: function (t) {
        const e = t * this.getLength(),
          n = this.getCurveLengths();
        let i = 0;
        for (; i < n.length; ) {
          if (n[i] >= e) {
            const t = n[i] - e,
              r = this.curves[i],
              o = r.getLength(),
              s = 0 === o ? 0 : 1 - t / o;
            return r.getPointAt(s);
          }
          i++;
        }
        return null;
      },
      getLength: function () {
        const t = this.getCurveLengths();
        return t[t.length - 1];
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      },
      getCurveLengths: function () {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
          (e += this.curves[n].getLength()), t.push(e);
        return (this.cacheLengths = t), t;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 40);
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e;
      },
      getPoints: function (t) {
        t = t || 12;
        const e = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
          const o = r[i],
            s =
              o && o.isEllipseCurve
                ? 2 * t
                : o && (o.isLineCurve || o.isLineCurve3)
                ? 1
                : o && o.isSplineCurve
                ? t * o.points.length
                : t,
            a = o.getPoints(s);
          for (let t = 0; t < a.length; t++) {
            const i = a[t];
            (n && n.equals(i)) || (e.push(i), (n = i));
          }
        }
        return (
          this.autoClose &&
            e.length > 1 &&
            !e[e.length - 1].equals(e[0]) &&
            e.push(e[0]),
          e
        );
      },
      copy: function (t) {
        ha.prototype.copy.call(this, t), (this.curves = []);
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push(n.clone());
        }
        return (this.autoClose = t.autoClose), this;
      },
      toJSON: function () {
        const t = ha.prototype.toJSON.call(this);
        (t.autoClose = this.autoClose), (t.curves = []);
        for (let e = 0, n = this.curves.length; e < n; e++) {
          const n = this.curves[e];
          t.curves.push(n.toJSON());
        }
        return t;
      },
      fromJSON: function (t) {
        ha.prototype.fromJSON.call(this, t),
          (this.autoClose = t.autoClose),
          (this.curves = []);
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push(new Pa[n.type]().fromJSON(n));
        }
        return this;
      },
    })),
      (Oa.prototype = Object.assign(Object.create(Ca.prototype), {
        constructor: Oa,
        setFromPoints: function (t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        },
        moveTo: function (t, e) {
          return this.currentPoint.set(t, e), this;
        },
        lineTo: function (t, e) {
          const n = new Ta(this.currentPoint.clone(), new l(t, e));
          return this.curves.push(n), this.currentPoint.set(t, e), this;
        },
        quadraticCurveTo: function (t, e, n, i) {
          const r = new Aa(this.currentPoint.clone(), new l(t, e), new l(n, i));
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        },
        bezierCurveTo: function (t, e, n, i, r, o) {
          const s = new Ma(
            this.currentPoint.clone(),
            new l(t, e),
            new l(n, i),
            new l(r, o)
          );
          return this.curves.push(s), this.currentPoint.set(r, o), this;
        },
        splineThru: function (t) {
          const e = new Ra([this.currentPoint.clone()].concat(t));
          return (
            this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
          );
        },
        arc: function (t, e, n, i, r, o) {
          const s = this.currentPoint.x,
            a = this.currentPoint.y;
          return this.absarc(t + s, e + a, n, i, r, o), this;
        },
        absarc: function (t, e, n, i, r, o) {
          return this.absellipse(t, e, n, n, i, r, o), this;
        },
        ellipse: function (t, e, n, i, r, o, s, a) {
          const c = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absellipse(t + c, e + l, n, i, r, o, s, a), this;
        },
        absellipse: function (t, e, n, i, r, o, s, a) {
          const c = new pa(t, e, n, i, r, o, s, a);
          if (this.curves.length > 0) {
            const t = c.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
          }
          this.curves.push(c);
          const l = c.getPoint(1);
          return this.currentPoint.copy(l), this;
        },
        copy: function (t) {
          return (
            Ca.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
          );
        },
        toJSON: function () {
          const t = Ca.prototype.toJSON.call(this);
          return (t.currentPoint = this.currentPoint.toArray()), t;
        },
        fromJSON: function (t) {
          return (
            Ca.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
          );
        },
      })),
      (Ia.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Ia,
        getPointsHoles: function (t) {
          const e = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        },
        extractPoints: function (t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        },
        copy: function (t) {
          Oa.prototype.copy.call(this, t), (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(n.clone());
          }
          return this;
        },
        toJSON: function () {
          const t = Oa.prototype.toJSON.call(this);
          (t.uuid = this.uuid), (t.holes = []);
          for (let e = 0, n = this.holes.length; e < n; e++) {
            const n = this.holes[e];
            t.holes.push(n.toJSON());
          }
          return t;
        },
        fromJSON: function (t) {
          Oa.prototype.fromJSON.call(this, t),
            (this.uuid = t.uuid),
            (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(new Oa().fromJSON(n));
          }
          return this;
        },
      })),
      (Da.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Da,
        isLight: !0,
        copy: function (t) {
          return (
            X.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          const e = X.prototype.toJSON.call(this, t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        },
      })),
      (Na.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: Na,
        isHemisphereLight: !0,
        copy: function (t) {
          return (
            Da.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        },
      })),
      Object.assign(ka.prototype, {
        _projScreenMatrix: new R(),
        _lightPositionWorld: new w(),
        _lookTarget: new w(),
        getViewportCount: function () {
          return this._viewportCount;
        },
        getFrustum: function () {
          return this._frustum;
        },
        updateMatrices: function (t) {
          const e = this.camera,
            n = this.matrix,
            i = this._projScreenMatrix,
            r = this._lookTarget,
            o = this._lightPositionWorld;
          o.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(o),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(r),
            e.updateMatrixWorld(),
            i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(i),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse);
        },
        getViewport: function (t) {
          return this._viewports[t];
        },
        getFrameExtents: function () {
          return this._frameExtents;
        },
        copy: function (t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          const t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        },
      }),
      (Ua.prototype = Object.assign(Object.create(ka.prototype), {
        constructor: Ua,
        isSpotLightShadow: !0,
        updateMatrices: function (t) {
          const e = this.camera,
            n = 2 * c.RAD2DEG * t.angle,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix()),
            ka.prototype.updateMatrices.call(this, t);
        },
      })),
      (za.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: za,
        isSpotLight: !0,
        copy: function (t) {
          return (
            Da.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (Ba.prototype = Object.assign(Object.create(ka.prototype), {
        constructor: Ba,
        isPointLightShadow: !0,
        updateMatrices: function (t, e) {
          void 0 === e && (e = 0);
          const n = this.camera,
            i = this.matrix,
            r = this._lightPositionWorld,
            o = this._lookTarget,
            s = this._projScreenMatrix;
          r.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(r),
            o.copy(n.position),
            o.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(o),
            n.updateMatrixWorld(),
            i.makeTranslation(-r.x, -r.y, -r.z),
            s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(s);
        },
      })),
      (Fa.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: Fa,
        isPointLight: !0,
        copy: function (t) {
          return (
            Da.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (Ha.prototype = Object.assign(Object.create(Ve.prototype), {
        constructor: Ha,
        isOrthographicCamera: !0,
        copy: function (t, e) {
          return (
            Ve.prototype.copy.call(this, t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        },
        setViewOffset: function (t, e, n, i, r, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - t,
            o = n + t,
            s = i + e,
            a = i - e;
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += t * this.view.offsetX),
              (o = r + t * this.view.width),
              (s -= e * this.view.offsetY),
              (a = s - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            s,
            a,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          const e = X.prototype.toJSON.call(this, t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        },
      })),
      (Ga.prototype = Object.assign(Object.create(ka.prototype), {
        constructor: Ga,
        isDirectionalLightShadow: !0,
        updateMatrices: function (t) {
          ka.prototype.updateMatrices.call(this, t);
        },
      })),
      (ja.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: ja,
        isDirectionalLight: !0,
        copy: function (t) {
          return (
            Da.prototype.copy.call(this, t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (Va.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: Va,
        isAmbientLight: !0,
      })),
      (Wa.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: Wa,
        isRectAreaLight: !0,
        copy: function (t) {
          return (
            Da.prototype.copy.call(this, t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        },
        toJSON: function (t) {
          const e = Da.prototype.toJSON.call(this, t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        },
      })),
      Object.assign(qa.prototype, {
        isSphericalHarmonics3: !0,
        set: function (t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        },
        zero: function () {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        },
        getAt: function (t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.282095),
            e.addScaledVector(o[1], 0.488603 * i),
            e.addScaledVector(o[2], 0.488603 * r),
            e.addScaledVector(o[3], 0.488603 * n),
            e.addScaledVector(o[4], n * i * 1.092548),
            e.addScaledVector(o[5], i * r * 1.092548),
            e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            e.addScaledVector(o[7], n * r * 1.092548),
            e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            e
          );
        },
        getIrradianceAt: function (t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.886227),
            e.addScaledVector(o[1], 1.023328 * i),
            e.addScaledVector(o[2], 1.023328 * r),
            e.addScaledVector(o[3], 1.023328 * n),
            e.addScaledVector(o[4], 0.858086 * n * i),
            e.addScaledVector(o[5], 0.858086 * i * r),
            e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            e.addScaledVector(o[7], 0.858086 * n * r),
            e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            e
          );
        },
        add: function (t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        },
        addScaledSH: function (t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(t.coefficients[n], e);
          return this;
        },
        scale: function (t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        },
        lerp: function (t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e);
          return this;
        },
        equals: function (t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        },
        copy: function (t) {
          return this.set(t.coefficients);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
          return t;
        },
      }),
      Object.assign(qa, {
        getBasisAt: function (t, e) {
          const n = t.x,
            i = t.y,
            r = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * i),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * i),
            (e[5] = 1.092548 * i * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * n * r),
            (e[8] = 0.546274 * (n * n - i * i));
        },
      }),
      (Xa.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: Xa,
        isLightProbe: !0,
        copy: function (t) {
          return Da.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
        },
        fromJSON: function (t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
        },
        toJSON: function (t) {
          const e = Da.prototype.toJSON.call(this, t);
          return (e.object.sh = this.sh.toArray()), e;
        },
      })),
      (Ya.prototype = Object.assign(Object.create(na.prototype), {
        constructor: Ya,
        load: function (t, e, n, i) {
          const r = this,
            o = new ra(r.manager);
          o.setPath(r.path),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        },
        parse: function (t) {
          const e = this.textures;
          function n(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          const i = new Us[t.type]();
          if (
            (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = new zt().setHex(t.sheen)),
            void 0 !== t.emissive && i.emissive.setHex(t.emissive),
            void 0 !== t.specular && i.specular.setHex(t.specular),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (i.skinning = t.skinning),
            void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
            void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.vertexTangents &&
              (i.vertexTangents = t.vertexTangents),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.vertexColors &&
              ("number" == typeof t.vertexColors
                ? (i.vertexColors = t.vertexColors > 0)
                : (i.vertexColors = t.vertexColors)),
            void 0 !== t.uniforms)
          )
            for (const e in t.uniforms) {
              const r = t.uniforms[e];
              switch (((i.uniforms[e] = {}), r.type)) {
                case "t":
                  i.uniforms[e].value = n(r.value);
                  break;
                case "c":
                  i.uniforms[e].value = new zt().setHex(r.value);
                  break;
                case "v2":
                  i.uniforms[e].value = new l().fromArray(r.value);
                  break;
                case "v3":
                  i.uniforms[e].value = new w().fromArray(r.value);
                  break;
                case "v4":
                  i.uniforms[e].value = new m().fromArray(r.value);
                  break;
                case "m3":
                  i.uniforms[e].value = new u().fromArray(r.value);
                case "m4":
                  i.uniforms[e].value = new R().fromArray(r.value);
                  break;
                default:
                  i.uniforms[e].value = r.value;
              }
            }
          if (
            (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (const e in t.extensions) i.extensions[e] = t.extensions[e];
          if (
            (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            let e = t.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]),
              (i.normalScale = new l().fromArray(e));
          }
          return (
            void 0 !== t.displacementMap &&
              (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap &&
              (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap &&
              (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (i.clearcoatNormalScale = new l().fromArray(
                t.clearcoatNormalScale
              )),
            i
          );
        },
        setTextures: function (t) {
          return (this.textures = t), this;
        },
      }));
    const Za = function (t) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(t);
        let e = "";
        for (let n = 0, i = t.length; n < i; n++)
          e += String.fromCharCode(t[n]);
        try {
          return decodeURIComponent(escape(e));
        } catch (t) {
          return e;
        }
      },
      Ja = function (t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1);
      };
    function Ka() {
      de.call(this),
        (this.type = "InstancedBufferGeometry"),
        (this.instanceCount = 1 / 0);
    }
    function $a(t, e, n, i) {
      "number" == typeof n &&
        ((i = n),
        (n = !1),
        console.error(
          "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
        )),
        Yt.call(this, t, e, n),
        (this.meshPerAttribute = i || 1);
    }
    function Qa(t) {
      na.call(this, t);
    }
    (Ka.prototype = Object.assign(Object.create(de.prototype), {
      constructor: Ka,
      isInstancedBufferGeometry: !0,
      copy: function (t) {
        return (
          de.prototype.copy.call(this, t),
          (this.instanceCount = t.instanceCount),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        const t = de.prototype.toJSON.call(this);
        return (
          (t.instanceCount = this.instanceCount),
          (t.isInstancedBufferGeometry = !0),
          t
        );
      },
    })),
      ($a.prototype = Object.assign(Object.create(Yt.prototype), {
        constructor: $a,
        isInstancedBufferAttribute: !0,
        copy: function (t) {
          return (
            Yt.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
        toJSON: function () {
          const t = Yt.prototype.toJSON.call(this);
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        },
      })),
      (Qa.prototype = Object.assign(Object.create(na.prototype), {
        constructor: Qa,
        load: function (t, e, n, i) {
          const r = this,
            o = new ra(r.manager);
          o.setPath(r.path),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        },
        parse: function (t) {
          const e = {},
            n = {};
          function i(t, i) {
            if (void 0 !== e[i]) return e[i];
            const r = t.interleavedBuffers[i],
              o = (function (t, e) {
                if (void 0 !== n[e]) return n[e];
                const i = t.arrayBuffers[e],
                  r = new Uint32Array(i).buffer;
                return (n[e] = r), r;
              })(t, r.buffer),
              s = new ur(new tc[r.type](o), r.stride);
            return (s.uuid = r.uuid), (e[i] = s), s;
          }
          const r = t.isInstancedBufferGeometry ? new Ka() : new de(),
            o = t.data.index;
          if (void 0 !== o) {
            const t = new tc[o.type](o.array);
            r.setIndex(new Yt(t, 1));
          }
          const s = t.data.attributes;
          for (const e in s) {
            const n = s[e];
            let o;
            if (n.isInterleavedBufferAttribute) {
              o = new pr(i(t.data, n.data), n.itemSize, n.offset, n.normalized);
            } else {
              const t = new tc[n.type](n.array);
              o = new (n.isInstancedBufferAttribute ? $a : Yt)(
                t,
                n.itemSize,
                n.normalized
              );
            }
            void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o);
          }
          const a = t.data.morphAttributes;
          if (a)
            for (const e in a) {
              const n = a[e],
                o = [];
              for (let e = 0, r = n.length; e < r; e++) {
                const r = n[e];
                let s;
                if (r.isInterleavedBufferAttribute) {
                  s = new pr(
                    i(t.data, r.data),
                    r.itemSize,
                    r.offset,
                    r.normalized
                  );
                } else {
                  s = new Yt(new tc[r.type](r.array), r.itemSize, r.normalized);
                }
                void 0 !== r.name && (s.name = r.name), o.push(s);
              }
              r.morphAttributes[e] = o;
            }
          t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
          const c = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== c)
            for (let t = 0, e = c.length; t !== e; ++t) {
              const e = c[t];
              r.addGroup(e.start, e.count, e.materialIndex);
            }
          const l = t.data.boundingSphere;
          if (void 0 !== l) {
            const t = new w();
            void 0 !== l.center && t.fromArray(l.center),
              (r.boundingSphere = new ht(t, l.radius));
          }
          return (
            t.name && (r.name = t.name),
            t.userData && (r.userData = t.userData),
            r
          );
        },
      }));
    const tc = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        "undefined" != typeof Uint8ClampedArray
          ? Uint8ClampedArray
          : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    };
    function ec(t) {
      na.call(this, t);
    }
    ec.prototype = Object.assign(Object.create(na.prototype), {
      constructor: ec,
      load: function (t, e, n, i) {
        const r = this,
          o = "" === this.path ? Ja(t) : this.path;
        this.resourcePath = this.resourcePath || o;
        const s = new ra(r.manager);
        s.setPath(this.path),
          s.load(
            t,
            function (n) {
              let o = null;
              try {
                o = JSON.parse(n);
              } catch (e) {
                return (
                  void 0 !== i && i(e),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + t + ".",
                    e.message
                  )
                );
              }
              const s = o.metadata;
              void 0 !== s &&
              void 0 !== s.type &&
              "geometry" !== s.type.toLowerCase()
                ? r.parse(o, e)
                : console.error("THREE.ObjectLoader: Can't load " + t);
            },
            n,
            i
          );
      },
      parse: function (t, e) {
        const n = this.parseShape(t.shapes),
          i = this.parseGeometries(t.geometries, n),
          r = this.parseImages(t.images, function () {
            void 0 !== e && e(a);
          }),
          o = this.parseTextures(t.textures, r),
          s = this.parseMaterials(t.materials, o),
          a = this.parseObject(t.object, i, s);
        return (
          t.animations && (a.animations = this.parseAnimations(t.animations)),
          (void 0 !== t.images && 0 !== t.images.length) ||
            (void 0 !== e && e(a)),
          a
        );
      },
      parseShape: function (t) {
        const e = {};
        if (void 0 !== t)
          for (let n = 0, i = t.length; n < i; n++) {
            const i = new Ia().fromJSON(t[n]);
            e[i.uuid] = i;
          }
        return e;
      },
      parseGeometries: function (t, e) {
        const n = {};
        let i;
        if (void 0 !== t) {
          const r = new Qa();
          for (let o = 0, s = t.length; o < s; o++) {
            let s;
            const a = t[o];
            switch (a.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                s = new Es[a.type](
                  a.width,
                  a.height,
                  a.widthSegments,
                  a.heightSegments
                );
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                s = new Es[a.type](
                  a.width,
                  a.height,
                  a.depth,
                  a.widthSegments,
                  a.heightSegments,
                  a.depthSegments
                );
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                s = new Es[a.type](
                  a.radius,
                  a.segments,
                  a.thetaStart,
                  a.thetaLength
                );
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                s = new Es[a.type](
                  a.radiusTop,
                  a.radiusBottom,
                  a.height,
                  a.radialSegments,
                  a.heightSegments,
                  a.openEnded,
                  a.thetaStart,
                  a.thetaLength
                );
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                s = new Es[a.type](
                  a.radius,
                  a.height,
                  a.radialSegments,
                  a.heightSegments,
                  a.openEnded,
                  a.thetaStart,
                  a.thetaLength
                );
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                s = new Es[a.type](
                  a.radius,
                  a.widthSegments,
                  a.heightSegments,
                  a.phiStart,
                  a.phiLength,
                  a.thetaStart,
                  a.thetaLength
                );
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                s = new Es[a.type](a.radius, a.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                s = new Es[a.type](
                  a.innerRadius,
                  a.outerRadius,
                  a.thetaSegments,
                  a.phiSegments,
                  a.thetaStart,
                  a.thetaLength
                );
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                s = new Es[a.type](
                  a.radius,
                  a.tube,
                  a.radialSegments,
                  a.tubularSegments,
                  a.arc
                );
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                s = new Es[a.type](
                  a.radius,
                  a.tube,
                  a.tubularSegments,
                  a.radialSegments,
                  a.p,
                  a.q
                );
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                s = new Es[a.type](
                  new Pa[a.path.type]().fromJSON(a.path),
                  a.tubularSegments,
                  a.radius,
                  a.radialSegments,
                  a.closed
                );
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                s = new Es[a.type](
                  a.points,
                  a.segments,
                  a.phiStart,
                  a.phiLength
                );
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                s = new Es[a.type](a.vertices, a.indices, a.radius, a.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                i = [];
                for (let t = 0, n = a.shapes.length; t < n; t++) {
                  const n = e[a.shapes[t]];
                  i.push(n);
                }
                s = new Es[a.type](i, a.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                i = [];
                for (let t = 0, n = a.shapes.length; t < n; t++) {
                  const n = e[a.shapes[t]];
                  i.push(n);
                }
                const t = a.options.extrudePath;
                void 0 !== t &&
                  (a.options.extrudePath = new Pa[t.type]().fromJSON(t)),
                  (s = new Es[a.type](i, a.options));
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                s = r.parse(a);
                break;
              case "Geometry":
                console.error(
                  'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
                );
                break;
              default:
                console.warn(
                  'THREE.ObjectLoader: Unsupported geometry type "' +
                    a.type +
                    '"'
                );
                continue;
            }
            (s.uuid = a.uuid),
              void 0 !== a.name && (s.name = a.name),
              !0 === s.isBufferGeometry &&
                void 0 !== a.userData &&
                (s.userData = a.userData),
              (n[a.uuid] = s);
          }
        }
        return n;
      },
      parseMaterials: function (t, e) {
        const n = {},
          i = {};
        if (void 0 !== t) {
          const r = new Ya();
          r.setTextures(e);
          for (let e = 0, o = t.length; e < o; e++) {
            const o = t[e];
            if ("MultiMaterial" === o.type) {
              const t = [];
              for (let e = 0; e < o.materials.length; e++) {
                const i = o.materials[e];
                void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
                  t.push(n[i.uuid]);
              }
              i[o.uuid] = t;
            } else
              void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)),
                (i[o.uuid] = n[o.uuid]);
          }
        }
        return i;
      },
      parseAnimations: function (t) {
        const e = [];
        for (let n = 0; n < t.length; n++) {
          const i = t[n],
            r = Ks.parse(i);
          void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
        }
        return e;
      },
      parseImages: function (t, e) {
        const n = this,
          i = {};
        let r;
        function o(t) {
          return (
            n.manager.itemStart(t),
            r.load(
              t,
              function () {
                n.manager.itemEnd(t);
              },
              void 0,
              function () {
                n.manager.itemError(t), n.manager.itemEnd(t);
              }
            )
          );
        }
        if (void 0 !== t && t.length > 0) {
          const s = new ta(e);
          (r = new ca(s)), r.setCrossOrigin(this.crossOrigin);
          for (let e = 0, r = t.length; e < r; e++) {
            const r = t[e],
              s = r.url;
            if (Array.isArray(s)) {
              i[r.uuid] = [];
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
                    ? e
                    : n.resourcePath + e;
                i[r.uuid].push(o(a));
              }
            } else {
              const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url)
                ? r.url
                : n.resourcePath + r.url;
              i[r.uuid] = o(t);
            }
          }
        }
        return i;
      },
      parseTextures: function (t, e) {
        function n(t, e) {
          return "number" == typeof t
            ? t
            : (console.warn(
                "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                t
              ),
              e[t]);
        }
        const i = {};
        if (void 0 !== t)
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r];
            let s;
            void 0 === o.image &&
              console.warn(
                'THREE.ObjectLoader: No "image" specified for',
                o.uuid
              ),
              void 0 === e[o.image] &&
                console.warn("THREE.ObjectLoader: Undefined image", o.image),
              (s = Array.isArray(e[o.image])
                ? new xn(e[o.image])
                : new f(e[o.image])),
              (s.needsUpdate = !0),
              (s.uuid = o.uuid),
              void 0 !== o.name && (s.name = o.name),
              void 0 !== o.mapping && (s.mapping = n(o.mapping, nc)),
              void 0 !== o.offset && s.offset.fromArray(o.offset),
              void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
              void 0 !== o.center && s.center.fromArray(o.center),
              void 0 !== o.rotation && (s.rotation = o.rotation),
              void 0 !== o.wrap &&
                ((s.wrapS = n(o.wrap[0], ic)), (s.wrapT = n(o.wrap[1], ic))),
              void 0 !== o.format && (s.format = o.format),
              void 0 !== o.type && (s.type = o.type),
              void 0 !== o.encoding && (s.encoding = o.encoding),
              void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, rc)),
              void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, rc)),
              void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
              void 0 !== o.flipY && (s.flipY = o.flipY),
              void 0 !== o.premultiplyAlpha &&
                (s.premultiplyAlpha = o.premultiplyAlpha),
              void 0 !== o.unpackAlignment &&
                (s.unpackAlignment = o.unpackAlignment),
              (i[o.uuid] = s);
          }
        return i;
      },
      parseObject: function (t, e, n) {
        let i, r, o;
        function s(t) {
          return (
            void 0 === e[t] &&
              console.warn("THREE.ObjectLoader: Undefined geometry", t),
            e[t]
          );
        }
        function a(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              const e = [];
              for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i];
                void 0 === n[r] &&
                  console.warn("THREE.ObjectLoader: Undefined material", r),
                  e.push(n[r]);
              }
              return e;
            }
            return (
              void 0 === n[t] &&
                console.warn("THREE.ObjectLoader: Undefined material", t),
              n[t]
            );
          }
        }
        switch (t.type) {
          case "Scene":
            (i = new Y()),
              void 0 !== t.background &&
                Number.isInteger(t.background) &&
                (i.background = new zt(t.background)),
              void 0 !== t.fog &&
                ("Fog" === t.fog.type
                  ? (i.fog = new lr(t.fog.color, t.fog.near, t.fog.far))
                  : "FogExp2" === t.fog.type &&
                    (i.fog = new cr(t.fog.color, t.fog.density)));
            break;
          case "PerspectiveCamera":
            (i = new We(t.fov, t.aspect, t.near, t.far)),
              void 0 !== t.focus && (i.focus = t.focus),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
              void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "OrthographicCamera":
            (i = new Ha(t.left, t.right, t.top, t.bottom, t.near, t.far)),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "AmbientLight":
            i = new Va(t.color, t.intensity);
            break;
          case "DirectionalLight":
            i = new ja(t.color, t.intensity);
            break;
          case "PointLight":
            i = new Fa(t.color, t.intensity, t.distance, t.decay);
            break;
          case "RectAreaLight":
            i = new Wa(t.color, t.intensity, t.width, t.height);
            break;
          case "SpotLight":
            i = new za(
              t.color,
              t.intensity,
              t.distance,
              t.angle,
              t.penumbra,
              t.decay
            );
            break;
          case "HemisphereLight":
            i = new Na(t.color, t.groundColor, t.intensity);
            break;
          case "LightProbe":
            i = new Xa().fromJSON(t);
            break;
          case "SkinnedMesh":
            console.warn(
              "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
            );
          case "Mesh":
            (r = s(t.geometry)), (o = a(t.material)), (i = new Ce(r, o));
            break;
          case "InstancedMesh":
            (r = s(t.geometry)), (o = a(t.material));
            const e = t.count,
              n = t.instanceMatrix;
            (i = new Hr(r, o, e)),
              (i.instanceMatrix = new Yt(new Float32Array(n.array), 16));
            break;
          case "LOD":
            i = new Cr();
            break;
          case "Line":
            i = new Yr(s(t.geometry), a(t.material), t.mode);
            break;
          case "LineLoop":
            i = new $r(s(t.geometry), a(t.material));
            break;
          case "LineSegments":
            i = new Kr(s(t.geometry), a(t.material));
            break;
          case "PointCloud":
          case "Points":
            i = new ro(s(t.geometry), a(t.material));
            break;
          case "Sprite":
            i = new Ar(a(t.material));
            break;
          case "Group":
            i = new nr();
            break;
          default:
            i = new X();
        }
        if (
          ((i.uuid = t.uuid),
          void 0 !== t.name && (i.name = t.name),
          void 0 !== t.matrix
            ? (i.matrix.fromArray(t.matrix),
              void 0 !== t.matrixAutoUpdate &&
                (i.matrixAutoUpdate = t.matrixAutoUpdate),
              i.matrixAutoUpdate &&
                i.matrix.decompose(i.position, i.quaternion, i.scale))
            : (void 0 !== t.position && i.position.fromArray(t.position),
              void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
              void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
              void 0 !== t.scale && i.scale.fromArray(t.scale)),
          void 0 !== t.castShadow && (i.castShadow = t.castShadow),
          void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
          t.shadow &&
            (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.normalBias &&
              (i.shadow.normalBias = t.shadow.normalBias),
            void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize &&
              i.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera &&
              (i.shadow.camera = this.parseObject(t.shadow.camera))),
          void 0 !== t.visible && (i.visible = t.visible),
          void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
          void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
          void 0 !== t.userData && (i.userData = t.userData),
          void 0 !== t.layers && (i.layers.mask = t.layers),
          void 0 !== t.children)
        ) {
          const r = t.children;
          for (let t = 0; t < r.length; t++)
            i.add(this.parseObject(r[t], e, n));
        }
        if ("LOD" === t.type) {
          void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
          const e = t.levels;
          for (let t = 0; t < e.length; t++) {
            const n = e[t],
              r = i.getObjectByProperty("uuid", n.object);
            void 0 !== r && i.addLevel(r, n.distance);
          }
        }
        return i;
      },
    });
    const nc = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307,
      },
      ic = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002,
      },
      rc = {
        NearestFilter: 1003,
        NearestMipmapNearestFilter: 1004,
        NearestMipmapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipmapNearestFilter: 1007,
        LinearMipmapLinearFilter: 1008,
      };
    function oc(t) {
      "undefined" == typeof createImageBitmap &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        na.call(this, t),
        (this.options = { premultiplyAlpha: "none" });
    }
    function sc() {
      (this.type = "ShapePath"),
        (this.color = new zt()),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    function ac(t) {
      (this.type = "Font"), (this.data = t);
    }
    function cc(t, e, n, i, r) {
      const o = r.glyphs[t] || r.glyphs["?"];
      if (!o)
        return void console.error(
          'THREE.Font: character "' +
            t +
            '" does not exists in font family ' +
            r.familyName +
            "."
        );
      const s = new sc();
      let a, c, l, u, h, p, d, f;
      if (o.o) {
        const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
        for (let r = 0, o = t.length; r < o; ) {
          switch (t[r++]) {
            case "m":
              (a = t[r++] * e + n), (c = t[r++] * e + i), s.moveTo(a, c);
              break;
            case "l":
              (a = t[r++] * e + n), (c = t[r++] * e + i), s.lineTo(a, c);
              break;
            case "q":
              (l = t[r++] * e + n),
                (u = t[r++] * e + i),
                (h = t[r++] * e + n),
                (p = t[r++] * e + i),
                s.quadraticCurveTo(h, p, l, u);
              break;
            case "b":
              (l = t[r++] * e + n),
                (u = t[r++] * e + i),
                (h = t[r++] * e + n),
                (p = t[r++] * e + i),
                (d = t[r++] * e + n),
                (f = t[r++] * e + i),
                s.bezierCurveTo(h, p, d, f, l, u);
          }
        }
      }
      return { offsetX: o.ha * e, path: s };
    }
    function lc(t) {
      na.call(this, t);
    }
    let uc;
    (oc.prototype = Object.assign(Object.create(na.prototype), {
      constructor: oc,
      isImageBitmapLoader: !0,
      setOptions: function (t) {
        return (this.options = t), this;
      },
      load: function (t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        const r = this,
          o = Qs.get(t);
        if (void 0 !== o)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), r.manager.itemEnd(t);
            }, 0),
            o
          );
        fetch(t)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return createImageBitmap(t, r.options);
          })
          .then(function (n) {
            Qs.add(t, n), e && e(n), r.manager.itemEnd(t);
          })
          .catch(function (e) {
            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }),
          r.manager.itemStart(t);
      },
    })),
      Object.assign(sc.prototype, {
        moveTo: function (t, e) {
          return (
            (this.currentPath = new Oa()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
          );
        },
        lineTo: function (t, e) {
          return this.currentPath.lineTo(t, e), this;
        },
        quadraticCurveTo: function (t, e, n, i) {
          return this.currentPath.quadraticCurveTo(t, e, n, i), this;
        },
        bezierCurveTo: function (t, e, n, i, r, o) {
          return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
        },
        splineThru: function (t) {
          return this.currentPath.splineThru(t), this;
        },
        toShapes: function (t, e) {
          function n(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n],
                r = new Ia();
              (r.curves = i.curves), e.push(r);
            }
            return e;
          }
          function i(t, e) {
            const n = e.length;
            let i = !1;
            for (let r = n - 1, o = 0; o < n; r = o++) {
              let n = e[r],
                s = e[o],
                a = s.x - n.x,
                c = s.y - n.y;
              if (Math.abs(c) > Number.EPSILON) {
                if (
                  (c < 0 && ((n = e[o]), (a = -a), (s = e[r]), (c = -c)),
                  t.y < n.y || t.y > s.y)
                )
                  continue;
                if (t.y === n.y) {
                  if (t.x === n.x) return !0;
                } else {
                  const e = c * (t.x - n.x) - a * (t.y - n.y);
                  if (0 === e) return !0;
                  if (e < 0) continue;
                  i = !i;
                }
              } else {
                if (t.y !== n.y) continue;
                if ((s.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= s.x))
                  return !0;
              }
            }
            return i;
          }
          const r = es.isClockWise,
            o = this.subPaths;
          if (0 === o.length) return [];
          if (!0 === e) return n(o);
          let s,
            a,
            c,
            l = [];
          if (1 === o.length)
            return (
              (a = o[0]), (c = new Ia()), (c.curves = a.curves), l.push(c), l
            );
          let u = !r(o[0].getPoints());
          u = t ? !u : u;
          const h = [],
            p = [];
          let d,
            f,
            m = [],
            g = 0;
          (p[g] = void 0), (m[g] = []);
          for (let e = 0, n = o.length; e < n; e++)
            (a = o[e]),
              (d = a.getPoints()),
              (s = r(d)),
              (s = t ? !s : s),
              s
                ? (!u && p[g] && g++,
                  (p[g] = { s: new Ia(), p: d }),
                  (p[g].s.curves = a.curves),
                  u && g++,
                  (m[g] = []))
                : m[g].push({ h: a, p: d[0] });
          if (!p[0]) return n(o);
          if (p.length > 1) {
            let t = !1;
            const e = [];
            for (let t = 0, e = p.length; t < e; t++) h[t] = [];
            for (let n = 0, r = p.length; n < r; n++) {
              const r = m[n];
              for (let o = 0; o < r.length; o++) {
                const s = r[o];
                let a = !0;
                for (let r = 0; r < p.length; r++)
                  i(s.p, p[r].p) &&
                    (n !== r && e.push({ froms: n, tos: r, hole: o }),
                    a ? ((a = !1), h[r].push(s)) : (t = !0));
                a && h[n].push(s);
              }
            }
            e.length > 0 && (t || (m = h));
          }
          for (let t = 0, e = p.length; t < e; t++) {
            (c = p[t].s), l.push(c), (f = m[t]);
            for (let t = 0, e = f.length; t < e; t++) c.holes.push(f[t].h);
          }
          return l;
        },
      }),
      Object.assign(ac.prototype, {
        isFont: !0,
        generateShapes: function (t, e) {
          void 0 === e && (e = 100);
          const n = [],
            i = (function (t, e, n) {
              const i = Array.from ? Array.from(t) : String(t).split(""),
                r = e / n.resolution,
                o =
                  (n.boundingBox.yMax -
                    n.boundingBox.yMin +
                    n.underlineThickness) *
                  r,
                s = [];
              let a = 0,
                c = 0;
              for (let t = 0; t < i.length; t++) {
                const e = i[t];
                if ("\n" === e) (a = 0), (c -= o);
                else {
                  const t = cc(e, r, a, c, n);
                  (a += t.offsetX), s.push(t.path);
                }
              }
              return s;
            })(t, e, this.data);
          for (let t = 0, e = i.length; t < e; t++)
            Array.prototype.push.apply(n, i[t].toShapes());
          return n;
        },
      }),
      (lc.prototype = Object.assign(Object.create(na.prototype), {
        constructor: lc,
        load: function (t, e, n, i) {
          const r = this,
            o = new ra(this.manager);
          o.setPath(this.path),
            o.load(
              t,
              function (t) {
                let n;
                try {
                  n = JSON.parse(t);
                } catch (e) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)));
                }
                const i = r.parse(n);
                e && e(i);
              },
              n,
              i
            );
        },
        parse: function (t) {
          return new ac(t);
        },
      }));
    const hc = function () {
      return (
        void 0 === uc &&
          (uc = new (window.AudioContext || window.webkitAudioContext)()),
        uc
      );
    };
    function pc(t) {
      na.call(this, t);
    }
    function dc(t, e, n) {
      Xa.call(this, void 0, n);
      const i = new zt().set(t),
        r = new zt().set(e),
        o = new w(i.r, i.g, i.b),
        s = new w(r.r, r.g, r.b),
        a = Math.sqrt(Math.PI),
        c = a * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
        this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
    }
    function fc(t, e) {
      Xa.call(this, void 0, e);
      const n = new zt().set(t);
      this.sh.coefficients[0]
        .set(n.r, n.g, n.b)
        .multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    (pc.prototype = Object.assign(Object.create(na.prototype), {
      constructor: pc,
      load: function (t, e, n, i) {
        const r = this,
          o = new ra(r.manager);
        o.setResponseType("arraybuffer"),
          o.setPath(r.path),
          o.load(
            t,
            function (n) {
              try {
                const t = n.slice(0);
                hc().decodeAudioData(t, function (t) {
                  e(t);
                });
              } catch (e) {
                i ? i(e) : console.error(e), r.manager.itemError(t);
              }
            },
            n,
            i
          );
      },
    })),
      (dc.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: dc,
        isHemisphereLightProbe: !0,
        copy: function (t) {
          return Xa.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return Xa.prototype.toJSON.call(this, t);
        },
      })),
      (fc.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: fc,
        isAmbientLightProbe: !0,
        copy: function (t) {
          return Xa.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return Xa.prototype.toJSON.call(this, t);
        },
      }));
    const mc = new R(),
      gc = new R();
    function vc(t) {
      (this.autoStart = void 0 === t || t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    Object.assign(
      function () {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new We()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new We()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1),
          (this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null,
          });
      }.prototype,
      {
        update: function (t) {
          const e = this._cache;
          if (
            e.focus !== t.focus ||
            e.fov !== t.fov ||
            e.aspect !== t.aspect * this.aspect ||
            e.near !== t.near ||
            e.far !== t.far ||
            e.zoom !== t.zoom ||
            e.eyeSep !== this.eyeSep
          ) {
            (e.focus = t.focus),
              (e.fov = t.fov),
              (e.aspect = t.aspect * this.aspect),
              (e.near = t.near),
              (e.far = t.far),
              (e.zoom = t.zoom),
              (e.eyeSep = this.eyeSep);
            const n = t.projectionMatrix.clone(),
              i = e.eyeSep / 2,
              r = (i * e.near) / e.focus,
              o = (e.near * Math.tan(c.DEG2RAD * e.fov * 0.5)) / e.zoom;
            let s, a;
            (gc.elements[12] = -i),
              (mc.elements[12] = i),
              (s = -o * e.aspect + r),
              (a = o * e.aspect + r),
              (n.elements[0] = (2 * e.near) / (a - s)),
              (n.elements[8] = (a + s) / (a - s)),
              this.cameraL.projectionMatrix.copy(n),
              (s = -o * e.aspect - r),
              (a = o * e.aspect - r),
              (n.elements[0] = (2 * e.near) / (a - s)),
              (n.elements[8] = (a + s) / (a - s)),
              this.cameraR.projectionMatrix.copy(n);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(gc),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(mc);
        },
      }
    ),
      Object.assign(vc.prototype, {
        start: function () {
          (this.startTime = (
            "undefined" == typeof performance ? Date : performance
          ).now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        },
        stop: function () {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        },
        getElapsedTime: function () {
          return this.getDelta(), this.elapsedTime;
        },
        getDelta: function () {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e = (
              "undefined" == typeof performance ? Date : performance
            ).now();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        },
      });
    const yc = new w(),
      xc = new y(),
      bc = new w(),
      wc = new w();
    function _c() {
      X.call(this),
        (this.type = "AudioListener"),
        (this.context = hc()),
        (this.gain = this.context.createGain()),
        this.gain.connect(this.context.destination),
        (this.filter = null),
        (this.timeDelta = 0),
        (this._clock = new vc());
    }
    function Mc(t) {
      X.call(this),
        (this.type = "Audio"),
        (this.listener = t),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.detune = 0),
        (this.loop = !1),
        (this.loopStart = 0),
        (this.loopEnd = 0),
        (this.offset = 0),
        (this.duration = void 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.sourceType = "empty"),
        (this._startedAt = 0),
        (this._progress = 0),
        (this.filters = []);
    }
    (_c.prototype = Object.assign(Object.create(X.prototype), {
      constructor: _c,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (t) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      },
      updateMatrixWorld: function (t) {
        X.prototype.updateMatrixWorld.call(this, t);
        const e = this.context.listener,
          n = this.up;
        if (
          ((this.timeDelta = this._clock.getDelta()),
          this.matrixWorld.decompose(yc, xc, bc),
          wc.set(0, 0, -1).applyQuaternion(xc),
          e.positionX)
        ) {
          const t = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(yc.x, t),
            e.positionY.linearRampToValueAtTime(yc.y, t),
            e.positionZ.linearRampToValueAtTime(yc.z, t),
            e.forwardX.linearRampToValueAtTime(wc.x, t),
            e.forwardY.linearRampToValueAtTime(wc.y, t),
            e.forwardZ.linearRampToValueAtTime(wc.z, t),
            e.upX.linearRampToValueAtTime(n.x, t),
            e.upY.linearRampToValueAtTime(n.y, t),
            e.upZ.linearRampToValueAtTime(n.z, t);
        } else
          e.setPosition(yc.x, yc.y, yc.z),
            e.setOrientation(wc.x, wc.y, wc.z, n.x, n.y, n.z);
      },
    })),
      (Mc.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Mc,
        getOutput: function () {
          return this.gain;
        },
        setNodeSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        },
        setMediaElementSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        },
        setMediaStreamSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        },
        setBuffer: function (t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        },
        play: function (t) {
          if ((void 0 === t && (t = 0), !0 === this.isPlaying))
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + t;
          const e = this.context.createBufferSource();
          return (
            (e.buffer = this.buffer),
            (e.loop = this.loop),
            (e.loopStart = this.loopStart),
            (e.loopEnd = this.loopEnd),
            (e.onended = this.onEnded.bind(this)),
            e.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = e),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        },
        pause: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        stop: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        connect: function () {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this;
        },
        disconnect: function () {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this;
        },
        getFilters: function () {
          return this.filters;
        },
        setFilters: function (t) {
          return (
            t || (t = []),
            !0 === this.isPlaying
              ? (this.disconnect(), (this.filters = t), this.connect())
              : (this.filters = t),
            this
          );
        },
        setDetune: function (t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        },
        getDetune: function () {
          return this.detune;
        },
        getFilter: function () {
          return this.getFilters()[0];
        },
        setFilter: function (t) {
          return this.setFilters(t ? [t] : []);
        },
        setPlaybackRate: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getPlaybackRate: function () {
          return this.playbackRate;
        },
        onEnded: function () {
          this.isPlaying = !1;
        },
        getLoop: function () {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        },
        setLoop: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        setLoopStart: function (t) {
          return (this.loopStart = t), this;
        },
        setLoopEnd: function (t) {
          return (this.loopEnd = t), this;
        },
        getVolume: function () {
          return this.gain.gain.value;
        },
        setVolume: function (t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        },
      }));
    const Sc = new w(),
      Tc = new y(),
      Ec = new w(),
      Ac = new w();
    function Lc(t) {
      Mc.call(this, t),
        (this.panner = this.context.createPanner()),
        (this.panner.panningModel = "HRTF"),
        this.panner.connect(this.gain);
    }
    function Rc(t, e) {
      (this.analyser = t.context.createAnalyser()),
        (this.analyser.fftSize = void 0 !== e ? e : 2048),
        (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
        t.getOutput().connect(this.analyser);
    }
    function Pc(t, e, n) {
      let i, r, o;
      switch (((this.binding = t), (this.valueSize = n), e)) {
        case "quaternion":
          (i = this._slerp),
            (r = this._slerpAdditive),
            (o = this._setAdditiveIdentityQuaternion),
            (this.buffer = new Float64Array(6 * n)),
            (this._workIndex = 5);
          break;
        case "string":
        case "bool":
          (i = this._select),
            (r = this._select),
            (o = this._setAdditiveIdentityOther),
            (this.buffer = new Array(5 * n));
          break;
        default:
          (i = this._lerp),
            (r = this._lerpAdditive),
            (o = this._setAdditiveIdentityNumeric),
            (this.buffer = new Float64Array(5 * n));
      }
      (this._mixBufferRegion = i),
        (this._mixBufferRegionAdditive = r),
        (this._setIdentity = o),
        (this._origIndex = 3),
        (this._addIndex = 4),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    (Lc.prototype = Object.assign(Object.create(Mc.prototype), {
      constructor: Lc,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (t) {
        return (this.panner.refDistance = t), this;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (t) {
        return (this.panner.rolloffFactor = t), this;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (t) {
        return (this.panner.distanceModel = t), this;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (t) {
        return (this.panner.maxDistance = t), this;
      },
      setDirectionalCone: function (t, e, n) {
        return (
          (this.panner.coneInnerAngle = t),
          (this.panner.coneOuterAngle = e),
          (this.panner.coneOuterGain = n),
          this
        );
      },
      updateMatrixWorld: function (t) {
        if (
          (X.prototype.updateMatrixWorld.call(this, t),
          !0 === this.hasPlaybackControl && !1 === this.isPlaying)
        )
          return;
        this.matrixWorld.decompose(Sc, Tc, Ec),
          Ac.set(0, 0, 1).applyQuaternion(Tc);
        const e = this.panner;
        if (e.positionX) {
          const t = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(Sc.x, t),
            e.positionY.linearRampToValueAtTime(Sc.y, t),
            e.positionZ.linearRampToValueAtTime(Sc.z, t),
            e.orientationX.linearRampToValueAtTime(Ac.x, t),
            e.orientationY.linearRampToValueAtTime(Ac.y, t),
            e.orientationZ.linearRampToValueAtTime(Ac.z, t);
        } else
          e.setPosition(Sc.x, Sc.y, Sc.z), e.setOrientation(Ac.x, Ac.y, Ac.z);
      },
    })),
      Object.assign(Rc.prototype, {
        getFrequencyData: function () {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function () {
          let t = 0;
          const e = this.getFrequencyData();
          for (let n = 0; n < e.length; n++) t += e[n];
          return t / e.length;
        },
      }),
      Object.assign(Pc.prototype, {
        accumulate: function (t, e) {
          const n = this.buffer,
            i = this.valueSize,
            r = t * i + i;
          let o = this.cumulativeWeight;
          if (0 === o) {
            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
            o = e;
          } else {
            o += e;
            const t = e / o;
            this._mixBufferRegion(n, r, 0, t, i);
          }
          this.cumulativeWeight = o;
        },
        accumulateAdditive: function (t) {
          const e = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            (this.cumulativeWeightAdditive += t);
        },
        apply: function (t) {
          const e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            s = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const t = e * this._origIndex;
            this._mixBufferRegion(n, i, t, 1 - r, e);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
          for (let t = e, r = e + e; t !== r; ++t)
            if (n[t] !== n[t + e]) {
              s.setValue(n, i);
              break;
            }
        },
        saveOriginalState: function () {
          const t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          t.getValue(e, i);
          for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        },
        restoreOriginalState: function () {
          const t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        },
        _setAdditiveIdentityNumeric: function () {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
          for (let n = t; n < e; n++) this.buffer[n] = 0;
        },
        _setAdditiveIdentityQuaternion: function () {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[4 * this._addIndex + 3] = 1);
        },
        _setAdditiveIdentityOther: function () {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[e + n] = this.buffer[t + n];
        },
        _select: function (t, e, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
        },
        _slerp: function (t, e, n, i) {
          y.slerpFlat(t, e, t, e, t, n, i);
        },
        _slerpAdditive: function (t, e, n, i, r) {
          const o = this._workIndex * r;
          y.multiplyQuaternionsFlat(t, o, t, e, t, n),
            y.slerpFlat(t, e, t, e, t, o, i);
        },
        _lerp: function (t, e, n, i, r) {
          const o = 1 - i;
          for (let s = 0; s !== r; ++s) {
            const r = e + s;
            t[r] = t[r] * o + t[n + s] * i;
          }
        },
        _lerpAdditive: function (t, e, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const r = e + o;
            t[r] = t[r] + t[n + o] * i;
          }
        },
      });
    const Cc = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Oc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      Ic = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Dc = /(WCOD+)?/.source.replace("WCOD", Oc),
      Nc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      kc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Uc = new RegExp("^" + Ic + Dc + Nc + kc + "$"),
      zc = ["material", "materials", "bones"];
    function Bc(t, e, n) {
      const i = n || Fc.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    function Fc(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || Fc.parseTrackName(e)),
        (this.node = Fc.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t);
    }
    function Hc(t, e, n, i) {
      (this._mixer = t),
        (this._clip = e),
        (this._localRoot = n || null),
        (this.blendMode = i || e.blendMode);
      const r = e.tracks,
        o = r.length,
        s = new Array(o),
        a = { endingStart: 2400, endingEnd: 2400 };
      for (let t = 0; t !== o; ++t) {
        const e = r[t].createInterpolant(null);
        (s[t] = e), (e.settings = a);
      }
      (this._interpolantSettings = a),
        (this._interpolants = s),
        (this._propertyBindings = new Array(o)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = 2201),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    function Gc(t) {
      (this._root = t),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    function jc(t) {
      "string" == typeof t &&
        (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        (t = arguments[1])),
        (this.value = t);
    }
    function Vc(t, e, n) {
      ur.call(this, t, e), (this.meshPerAttribute = n || 1);
    }
    function Wc(t, e, n, i) {
      (this.ray = new xt(t, e)),
        (this.near = n || 0),
        (this.far = i || 1 / 0),
        (this.camera = null),
        (this.layers = new I()),
        (this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        }),
        Object.defineProperties(this.params, {
          PointCloud: {
            get: function () {
              return (
                console.warn(
                  "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                ),
                this.Points
              );
            },
          },
        });
    }
    function qc(t, e) {
      return t.distance - e.distance;
    }
    function Xc(t, e, n, i) {
      if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
        const i = t.children;
        for (let t = 0, r = i.length; t < r; t++) Xc(i[t], e, n, !0);
      }
    }
    Object.assign(Bc.prototype, {
      getValue: function (t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(t, e);
      },
      setValue: function (t, e) {
        const n = this._bindings;
        for (
          let i = this._targetGroup.nCachedObjects_, r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(t, e);
      },
      bind: function () {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].bind();
      },
      unbind: function () {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].unbind();
      },
    }),
      Object.assign(Fc, {
        Composite: Bc,
        create: function (t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new Fc.Composite(t, e, n)
            : new Fc(t, e, n);
        },
        sanitizeNodeName: function (t) {
          return t.replace(/\s/g, "_").replace(Cc, "");
        },
        parseTrackName: function (t) {
          const e = Uc.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1);
            -1 !== zc.indexOf(t) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        },
        findNode: function (t, e) {
          if (
            !e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            const n = function (t) {
                for (let i = 0; i < t.length; i++) {
                  const r = t[i];
                  if (r.name === e || r.uuid === e) return r;
                  const o = n(r.children);
                  if (o) return o;
                }
                return null;
              },
              i = n(t.children);
            if (i) return i;
          }
          return null;
        },
      }),
      Object.assign(Fc.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [
          function (t, e) {
            t[e] = this.node[this.propertyName];
          },
          function (t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
          },
          function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          },
          function (t, e) {
            this.resolvedProperty.toArray(t, e);
          },
        ],
        SetterByBindingTypeAndVersioning: [
          [
            function (t, e) {
              this.targetObject[this.propertyName] = t[e];
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              const n = this.resolvedProperty;
              for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            },
            function (t, e) {
              const n = this.resolvedProperty;
              for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
              this.targetObject.needsUpdate = !0;
            },
            function (t, e) {
              const n = this.resolvedProperty;
              for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty[this.propertyIndex] = t[e];
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty.fromArray(t, e);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
        ],
        getValue: function (t, e) {
          this.bind(), this.getValue(t, e);
        },
        setValue: function (t, e) {
          this.bind(), this.setValue(t, e);
        },
        bind: function () {
          let t = this.node,
            e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName,
            r = e.propertyIndex;
          if (
            (t ||
              ((t = Fc.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
          if (n) {
            let i = e.objectIndex;
            switch (n) {
              case "materials":
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === i) {
                    i = e;
                    break;
                  }
                break;
              default:
                if (void 0 === t[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                t = t[n];
            }
            if (void 0 !== i) {
              if (void 0 === t[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
              t = t[i];
            }
          }
          const o = t[i];
          if (void 0 === o) {
            const n = e.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              t
            );
          }
          let s = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (s = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (s = this.Versioning.MatrixWorldNeedsUpdate);
          let a = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!t.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!t.geometry.isBufferGeometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
              if (!t.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r]);
            }
            (a = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            void 0 !== o.fromArray && void 0 !== o.toArray
              ? ((a = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((a = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[a]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
        },
        unbind: function () {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        },
      }),
      Object.assign(Fc.prototype, {
        _getValue_unbound: Fc.prototype.getValue,
        _setValue_unbound: Fc.prototype.setValue,
      }),
      Object.assign(
        function () {
          (this.uuid = c.generateUUID()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const t = {};
          this._indicesByUUID = t;
          for (let e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const e = this;
          this.stats = {
            objects: {
              get total() {
                return e._objects.length;
              },
              get inUse() {
                return this.total - e.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return e._bindings.length;
            },
          };
        }.prototype,
        {
          isAnimationObjectGroup: !0,
          add: function () {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._paths,
              i = this._parsedPaths,
              r = this._bindings,
              o = r.length;
            let s = void 0,
              a = t.length,
              c = this.nCachedObjects_;
            for (let l = 0, u = arguments.length; l !== u; ++l) {
              const u = arguments[l],
                h = u.uuid;
              let p = e[h];
              if (void 0 === p) {
                (p = a++), (e[h] = p), t.push(u);
                for (let t = 0, e = o; t !== e; ++t)
                  r[t].push(new Fc(u, n[t], i[t]));
              } else if (p < c) {
                s = t[p];
                const a = --c,
                  l = t[a];
                (e[l.uuid] = p), (t[p] = l), (e[h] = a), (t[a] = u);
                for (let t = 0, e = o; t !== e; ++t) {
                  const e = r[t],
                    o = e[a];
                  let s = e[p];
                  (e[p] = o),
                    void 0 === s && (s = new Fc(u, n[t], i[t])),
                    (e[a] = s);
                }
              } else
                t[p] !== s &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = c;
          },
          remove: function () {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_;
            for (let o = 0, s = arguments.length; o !== s; ++o) {
              const s = arguments[o],
                a = s.uuid,
                c = e[a];
              if (void 0 !== c && c >= r) {
                const o = r++,
                  l = t[o];
                (e[l.uuid] = c), (t[c] = l), (e[a] = o), (t[o] = s);
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[o],
                    r = e[c];
                  (e[c] = i), (e[o] = r);
                }
              }
            }
            this.nCachedObjects_ = r;
          },
          uncache: function () {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_,
              o = t.length;
            for (let s = 0, a = arguments.length; s !== a; ++s) {
              const a = arguments[s].uuid,
                c = e[a];
              if (void 0 !== c)
                if ((delete e[a], c < r)) {
                  const s = --r,
                    a = t[s],
                    l = --o,
                    u = t[l];
                  (e[a.uuid] = c),
                    (t[c] = a),
                    (e[u.uuid] = s),
                    (t[s] = u),
                    t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[s],
                      r = e[l];
                    (e[c] = i), (e[s] = r), e.pop();
                  }
                } else {
                  const r = --o,
                    s = t[r];
                  (e[s.uuid] = c), (t[c] = s), t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t];
                    (e[c] = e[r]), e.pop();
                  }
                }
            }
            this.nCachedObjects_ = r;
          },
          subscribe_: function (t, e) {
            let n = this._bindingsIndicesByPath,
              i = n[t],
              r = this._bindings;
            if (void 0 !== i) return r[i];
            const o = this._paths,
              s = this._parsedPaths,
              a = this._objects,
              c = a.length,
              l = this.nCachedObjects_,
              u = new Array(c);
            (i = r.length), (n[t] = i), o.push(t), s.push(e), r.push(u);
            for (let n = l, i = a.length; n !== i; ++n) {
              const i = a[n];
              u[n] = new Fc(i, t, e);
            }
            return u;
          },
          unsubscribe_: function (t) {
            const e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              const i = this._paths,
                r = this._parsedPaths,
                o = this._bindings,
                s = o.length - 1,
                a = o[s];
              (e[t[s]] = n),
                (o[n] = a),
                o.pop(),
                (r[n] = r[s]),
                r.pop(),
                (i[n] = i[s]),
                i.pop();
            }
          },
        }
      ),
      Object.assign(Hc.prototype, {
        play: function () {
          return this._mixer._activateAction(this), this;
        },
        stop: function () {
          return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function () {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        },
        isRunning: function () {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        },
        isScheduled: function () {
          return this._mixer._isActiveAction(this);
        },
        startAt: function (t) {
          return (this._startTime = t), this;
        },
        setLoop: function (t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        },
        setEffectiveWeight: function (t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        },
        getEffectiveWeight: function () {
          return this._effectiveWeight;
        },
        fadeIn: function (t) {
          return this._scheduleFading(t, 0, 1);
        },
        fadeOut: function (t) {
          return this._scheduleFading(t, 1, 0);
        },
        crossFadeFrom: function (t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            const n = this._clip.duration,
              i = t._clip.duration,
              r = i / n,
              o = n / i;
            t.warp(1, r, e), this.warp(o, 1, e);
          }
          return this;
        },
        crossFadeTo: function (t, e, n) {
          return t.crossFadeFrom(this, e, n);
        },
        stopFading: function () {
          let t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        setEffectiveTimeScale: function (t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        },
        getEffectiveTimeScale: function () {
          return this._effectiveTimeScale;
        },
        setDuration: function (t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        },
        syncWith: function (t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        },
        halt: function (t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        },
        warp: function (t, e, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let s = this._timeScaleInterpolant;
          null === s &&
            ((s = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = s));
          const a = s.parameterPositions,
            c = s.sampleValues;
          return (
            (a[0] = r), (a[1] = r + n), (c[0] = t / o), (c[1] = e / o), this
          );
        },
        stopWarping: function () {
          let t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        getMixer: function () {
          return this._mixer;
        },
        getClip: function () {
          return this._clip;
        },
        getRoot: function () {
          return this._localRoot || this._mixer._root;
        },
        _update: function (t, e, n, i) {
          if (!this.enabled) return void this._updateWeight(t);
          const r = this._startTime;
          if (null !== r) {
            const i = (t - r) * n;
            if (i < 0 || 0 === n) return;
            (this._startTime = null), (e = n * i);
          }
          e *= this._updateTimeScale(t);
          const o = this._updateTime(e),
            s = this._updateWeight(t);
          if (s > 0) {
            const t = this._interpolants,
              e = this._propertyBindings;
            switch (this.blendMode) {
              case 2501:
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(o), e[n].accumulateAdditive(s);
                break;
              case 2500:
              default:
                for (let n = 0, r = t.length; n !== r; ++n)
                  t[n].evaluate(o), e[n].accumulate(i, s);
            }
          }
        },
        _updateWeight: function (t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        },
        _updateTimeScale: function (t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (null !== n) {
              (e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e));
            }
          }
          return (this._effectiveTimeScale = e), e;
        },
        _updateTime: function (t) {
          const e = this._clip.duration,
            n = this.loop;
          let i = this.time + t,
            r = this._loopCount;
          const o = 2202 === n;
          if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
          if (2200 === n) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (i >= e) i = e;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break t;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
                  : this._setEndings(0 === this.repetitions, !0, o)),
              i >= e || i < 0)
            ) {
              const n = Math.floor(i / e);
              (i -= e * n), (r += Math.abs(n));
              const s = this.repetitions - r;
              if (s <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = t > 0 ? e : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === s) {
                  const e = t < 0;
                  this._setEndings(e, !e, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (o && 1 == (1 & r)) return e - i;
          }
          return i;
        },
        _setEndings: function (t, e, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = 2401), (i.endingEnd = 2401))
            : ((i.endingStart = t
                ? this.zeroSlopeAtStart
                  ? 2401
                  : 2400
                : 2402),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
        },
        _scheduleFading: function (t, e, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          null === o &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const s = o.parameterPositions,
            a = o.sampleValues;
          return (s[0] = r), (a[0] = e), (s[1] = r + t), (a[1] = n), this;
        },
      }),
      (Gc.prototype = Object.assign(Object.create(s.prototype), {
        constructor: Gc,
        _bindAction: function (t, e) {
          const n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            o = t._propertyBindings,
            s = t._interpolants,
            a = n.uuid,
            c = this._bindingsByRootAndName;
          let l = c[a];
          void 0 === l && ((l = {}), (c[a] = l));
          for (let t = 0; t !== r; ++t) {
            const r = i[t],
              c = r.name;
            let u = l[c];
            if (void 0 !== u) o[t] = u;
            else {
              if (((u = o[t]), void 0 !== u)) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, a, c));
                continue;
              }
              const i = e && e._propertyBindings[t].binding.parsedPath;
              (u = new Pc(
                Fc.create(n, c, i),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, a, c),
                (o[t] = u);
            }
            s[t].resultBuffer = u.buffer;
          }
        },
        _activateAction: function (t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(t);
          }
        },
        _deactivateAction: function (t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(t);
          }
        },
        _initMemoryManager: function () {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        },
        _isActiveAction: function (t) {
          const e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        },
        _addInactiveAction: function (t, e, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[e];
          if (void 0 === o)
            (o = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = o);
          else {
            const e = o.knownActions;
            (t._byClipCacheIndex = e.length), e.push(t);
          }
          (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
        },
        _removeInactiveAction: function (t) {
          const e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
          (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
          const r = t._clip.uuid,
            o = this._actionsByClip,
            s = o[r],
            a = s.knownActions,
            c = a[a.length - 1],
            l = t._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (a[l] = c),
            a.pop(),
            (t._byClipCacheIndex = null);
          delete s.actionByRoot[(t._localRoot || this._root).uuid],
            0 === a.length && delete o[r],
            this._removeInactiveBindingsForAction(t);
        },
        _removeInactiveBindingsForAction: function (t) {
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == --n.referenceCount && this._removeInactiveBinding(n);
          }
        },
        _lendAction: function (t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackAction: function (t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _addInactiveBinding: function (t, e, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[e];
          void 0 === o && ((o = {}), (i[e] = o)),
            (o[n] = t),
            (t._cacheIndex = r.length),
            r.push(t);
        },
        _removeInactiveBinding: function (t) {
          const e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            s = o[i],
            a = e[e.length - 1],
            c = t._cacheIndex;
          (a._cacheIndex = c),
            (e[c] = a),
            e.pop(),
            delete s[r],
            0 === Object.keys(s).length && delete o[i];
        },
        _lendBinding: function (t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackBinding: function (t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _lendControlInterpolant: function () {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++;
          let n = t[e];
          return (
            void 0 === n &&
              ((n = new Hs(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = e),
              (t[e] = n)),
            n
          );
        },
        _takeBackControlInterpolant: function (t) {
          const e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
          (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (t, e, n) {
          const i = e || this._root,
            r = i.uuid;
          let o = "string" == typeof t ? Ks.findByName(i, t) : t;
          const s = null !== o ? o.uuid : t;
          let a = this._actionsByClip[s],
            c = null;
          if (
            (void 0 === n && (n = null !== o ? o.blendMode : 2500),
            void 0 !== a)
          ) {
            const t = a.actionByRoot[r];
            if (void 0 !== t && t.blendMode === n) return t;
            (c = a.knownActions[0]), null === o && (o = c._clip);
          }
          if (null === o) return null;
          const l = new Hc(this, o, e, n);
          return this._bindAction(l, c), this._addInactiveAction(l, s, r), l;
        },
        existingAction: function (t, e) {
          const n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? Ks.findByName(n, t) : t,
            o = r ? r.uuid : t,
            s = this._actionsByClip[o];
          return (void 0 !== s && s.actionByRoot[i]) || null;
        },
        stopAllAction: function () {
          const t = this._actions;
          for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
          return this;
        },
        update: function (t) {
          t *= this.timeScale;
          const e = this._actions,
            n = this._nActiveActions,
            i = (this.time += t),
            r = Math.sign(t),
            o = (this._accuIndex ^= 1);
          for (let s = 0; s !== n; ++s) {
            e[s]._update(i, t, r, o);
          }
          const s = this._bindings,
            a = this._nActiveBindings;
          for (let t = 0; t !== a; ++t) s[t].apply(o);
          return this;
        },
        setTime: function (t) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(t);
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (t) {
          const e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const t = r.knownActions;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const i = t[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                o = e[e.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (o._cacheIndex = r),
                (e[r] = o),
                e.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        },
        uncacheRoot: function (t) {
          const e = t.uuid,
            n = this._actionsByClip;
          for (const t in n) {
            const i = n[t].actionByRoot[e];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName[e];
          if (void 0 !== i)
            for (const t in i) {
              const e = i[t];
              e.restoreOriginalState(), this._removeInactiveBinding(e);
            }
        },
        uncacheAction: function (t, e) {
          const n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        },
      })),
      (jc.prototype.clone = function () {
        return new jc(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }),
      (Vc.prototype = Object.assign(Object.create(ur.prototype), {
        constructor: Vc,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
          return (
            ur.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
        clone: function (t) {
          const e = ur.prototype.clone.call(this, t);
          return (e.meshPerAttribute = this.meshPerAttribute), e;
        },
        toJSON: function (t) {
          const e = ur.prototype.toJSON.call(this, t);
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          );
        },
      })),
      Object.assign(Wc.prototype, {
        set: function (t, e) {
          this.ray.set(t, e);
        },
        setFromCamera: function (t, e) {
          e && e.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
              this.ray.direction
                .set(t.x, t.y, 0.5)
                .unproject(e)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = e))
            : e && e.isOrthographicCamera
            ? (this.ray.origin
                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                .unproject(e),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(e.matrixWorld),
              (this.camera = e))
            : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function (t, e, n) {
          const i = n || [];
          return Xc(t, this, i, e), i.sort(qc), i;
        },
        intersectObjects: function (t, e, n) {
          const i = n || [];
          if (!1 === Array.isArray(t))
            return (
              console.warn(
                "THREE.Raycaster.intersectObjects: objects is not an Array."
              ),
              i
            );
          for (let n = 0, r = t.length; n < r; n++) Xc(t[n], this, i, e);
          return i.sort(qc), i;
        },
      }),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.phi = void 0 !== e ? e : 0),
            (this.theta = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          },
          makeSafe: function () {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(c.clamp(e / this.radius, -1, 1)))),
              this
            );
          },
        }
      ),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.theta = void 0 !== e ? e : 0),
            (this.y = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + n * n)),
              (this.theta = Math.atan2(t, n)),
              (this.y = e),
              this
            );
          },
        }
      );
    const Yc = new l();
    function Zc(t, e) {
      (this.min = void 0 !== t ? t : new l(1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new l(-1 / 0, -1 / 0));
    }
    Object.assign(Zc.prototype, {
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        const n = Yc.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getCenter() target is now required"),
            (t = new l())),
          this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getSize() target is now required"),
            (t = new l())),
          this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .getParameter() target is now required"),
            (e = new l())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .clampPoint() target is now required"),
            (e = new l())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return Yc.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      intersect: function (t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    });
    const Jc = new w(),
      Kc = new w();
    function $c(t, e) {
      (this.start = void 0 !== t ? t : new w()),
        (this.end = void 0 !== e ? e : new w());
    }
    function Qc(t) {
      X.call(this),
        (this.material = t),
        (this.render = function () {}),
        (this.hasPositions = !1),
        (this.hasNormals = !1),
        (this.hasColors = !1),
        (this.hasUvs = !1),
        (this.positionArray = null),
        (this.normalArray = null),
        (this.colorArray = null),
        (this.uvArray = null),
        (this.count = 0);
    }
    Object.assign($c.prototype, {
      set: function (t, e) {
        return this.start.copy(t), this.end.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.start.copy(t.start), this.end.copy(t.end), this;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .getCenter() target is now required"),
            (t = new w())),
          t.addVectors(this.start, this.end).multiplyScalar(0.5)
        );
      },
      delta: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .delta() target is now required"),
            (t = new w())),
          t.subVectors(this.end, this.start)
        );
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Line3: .at() target is now required"),
            (e = new w())),
          this.delta(e).multiplyScalar(t).add(this.start)
        );
      },
      closestPointToPointParameter: function (t, e) {
        Jc.subVectors(t, this.start), Kc.subVectors(this.end, this.start);
        const n = Kc.dot(Kc);
        let i = Kc.dot(Jc) / n;
        return e && (i = c.clamp(i, 0, 1)), i;
      },
      closestPointToPoint: function (t, e, n) {
        const i = this.closestPointToPointParameter(t, e);
        return (
          void 0 === n &&
            (console.warn(
              "THREE.Line3: .closestPointToPoint() target is now required"
            ),
            (n = new w())),
          this.delta(n).multiplyScalar(i).add(this.start)
        );
      },
      applyMatrix4: function (t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
      },
      equals: function (t) {
        return t.start.equals(this.start) && t.end.equals(this.end);
      },
    }),
      (Qc.prototype = Object.create(X.prototype)),
      (Qc.prototype.constructor = Qc),
      (Qc.prototype.isImmediateRenderObject = !0);
    const tl = new w();
    function el(t, e) {
      X.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = e);
      const n = new de(),
        i = [
          0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1,
          1, 0, 0, 0, 0, -1, 1,
        ];
      for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
        const r = (t / n) * Math.PI * 2,
          o = (e / n) * Math.PI * 2;
        i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1);
      }
      n.setAttribute("position", new ne(i, 3));
      const r = new Gr({ fog: !1, toneMapped: !1 });
      (this.cone = new Kr(n, r)), this.add(this.cone), this.update();
    }
    (el.prototype = Object.create(X.prototype)),
      (el.prototype.constructor = el),
      (el.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }),
      (el.prototype.update = function () {
        this.light.updateMatrixWorld();
        const t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          tl.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(tl),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      });
    const nl = new w(),
      il = new R(),
      rl = new R();
    function ol(t) {
      const e = (function t(e) {
          const n = [];
          e && e.isBone && n.push(e);
          for (let i = 0; i < e.children.length; i++)
            n.push.apply(n, t(e.children[i]));
          return n;
        })(t),
        n = new de(),
        i = [],
        r = [],
        o = new zt(0, 0, 1),
        s = new zt(0, 1, 0);
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        n.parent &&
          n.parent.isBone &&
          (i.push(0, 0, 0),
          i.push(0, 0, 0),
          r.push(o.r, o.g, o.b),
          r.push(s.r, s.g, s.b));
      }
      n.setAttribute("position", new ne(i, 3)),
        n.setAttribute("color", new ne(r, 3));
      const a = new Gr({
        vertexColors: !0,
        depthTest: !1,
        depthWrite: !1,
        toneMapped: !1,
        transparent: !0,
      });
      Kr.call(this, n, a),
        (this.type = "SkeletonHelper"),
        (this.root = t),
        (this.bones = e),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1);
    }
    function sl(t, e, n) {
      (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
      const i = new hs(e, 4, 2),
        r = new Wt({ wireframe: !0, fog: !1, toneMapped: !1 });
      Ce.call(this, i, r),
        (this.type = "PointLightHelper"),
        (this.matrix = this.light.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    (ol.prototype = Object.create(Kr.prototype)),
      (ol.prototype.constructor = ol),
      (ol.prototype.isSkeletonHelper = !0),
      (ol.prototype.updateMatrixWorld = function (t) {
        const e = this.bones,
          n = this.geometry,
          i = n.getAttribute("position");
        rl.getInverse(this.root.matrixWorld);
        for (let t = 0, n = 0; t < e.length; t++) {
          const r = e[t];
          r.parent &&
            r.parent.isBone &&
            (il.multiplyMatrices(rl, r.matrixWorld),
            nl.setFromMatrixPosition(il),
            i.setXYZ(n, nl.x, nl.y, nl.z),
            il.multiplyMatrices(rl, r.parent.matrixWorld),
            nl.setFromMatrixPosition(il),
            i.setXYZ(n + 1, nl.x, nl.y, nl.z),
            (n += 2));
        }
        (n.getAttribute("position").needsUpdate = !0),
          X.prototype.updateMatrixWorld.call(this, t);
      }),
      (sl.prototype = Object.create(Ce.prototype)),
      (sl.prototype.constructor = sl),
      (sl.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose();
      }),
      (sl.prototype.update = function () {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      });
    const al = new w(),
      cl = new zt(),
      ll = new zt();
    function ul(t, e, n) {
      X.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n);
      const i = new xo(e);
      i.rotateY(0.5 * Math.PI),
        (this.material = new Wt({ wireframe: !0, fog: !1, toneMapped: !1 })),
        void 0 === this.color && (this.material.vertexColors = !0);
      const r = i.getAttribute("position"),
        o = new Float32Array(3 * r.count);
      i.setAttribute("color", new Yt(o, 3)),
        this.add(new Ce(i, this.material)),
        this.update();
    }
    function hl(t, e, n, i) {
      (t = t || 10),
        (e = e || 10),
        (n = new zt(void 0 !== n ? n : 4473924)),
        (i = new zt(void 0 !== i ? i : 8947848));
      const r = e / 2,
        o = t / e,
        s = t / 2,
        a = [],
        c = [];
      for (let t = 0, l = 0, u = -s; t <= e; t++, u += o) {
        a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
        const e = t === r ? n : i;
        e.toArray(c, l),
          (l += 3),
          e.toArray(c, l),
          (l += 3),
          e.toArray(c, l),
          (l += 3),
          e.toArray(c, l),
          (l += 3);
      }
      const l = new de();
      l.setAttribute("position", new ne(a, 3)),
        l.setAttribute("color", new ne(c, 3));
      const u = new Gr({ vertexColors: !0, toneMapped: !1 });
      Kr.call(this, l, u), (this.type = "GridHelper");
    }
    function pl(t, e, n, i, r, o) {
      (t = t || 10),
        (e = e || 16),
        (n = n || 8),
        (i = i || 64),
        (r = new zt(void 0 !== r ? r : 4473924)),
        (o = new zt(void 0 !== o ? o : 8947848));
      const s = [],
        a = [];
      for (let n = 0; n <= e; n++) {
        const i = (n / e) * (2 * Math.PI),
          c = Math.sin(i) * t,
          l = Math.cos(i) * t;
        s.push(0, 0, 0), s.push(c, 0, l);
        const u = 1 & n ? r : o;
        a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b);
      }
      for (let e = 0; e <= n; e++) {
        const c = 1 & e ? r : o,
          l = t - (t / n) * e;
        for (let t = 0; t < i; t++) {
          let e = (t / i) * (2 * Math.PI),
            n = Math.sin(e) * l,
            r = Math.cos(e) * l;
          s.push(n, 0, r),
            a.push(c.r, c.g, c.b),
            (e = ((t + 1) / i) * (2 * Math.PI)),
            (n = Math.sin(e) * l),
            (r = Math.cos(e) * l),
            s.push(n, 0, r),
            a.push(c.r, c.g, c.b);
        }
      }
      const c = new de();
      c.setAttribute("position", new ne(s, 3)),
        c.setAttribute("color", new ne(a, 3));
      const l = new Gr({ vertexColors: !0, toneMapped: !1 });
      Kr.call(this, c, l), (this.type = "PolarGridHelper");
    }
    (ul.prototype = Object.create(X.prototype)),
      (ul.prototype.constructor = ul),
      (ul.prototype.dispose = function () {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }),
      (ul.prototype.update = function () {
        const t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          const e = t.geometry.getAttribute("color");
          cl.copy(this.light.color), ll.copy(this.light.groundColor);
          for (let t = 0, n = e.count; t < n; t++) {
            const i = t < n / 2 ? cl : ll;
            e.setXYZ(t, i.r, i.g, i.b);
          }
          e.needsUpdate = !0;
        }
        t.lookAt(al.setFromMatrixPosition(this.light.matrixWorld).negate());
      }),
      (hl.prototype = Object.assign(Object.create(Kr.prototype), {
        constructor: hl,
        copy: function (t) {
          return (
            Kr.prototype.copy.call(this, t),
            this.geometry.copy(t.geometry),
            this.material.copy(t.material),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (pl.prototype = Object.create(Kr.prototype)),
      (pl.prototype.constructor = pl);
    const dl = new w(),
      fl = new w(),
      ml = new w();
    function gl(t, e, n) {
      X.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n),
        void 0 === e && (e = 1);
      let i = new de();
      i.setAttribute(
        "position",
        new ne([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
      );
      const r = new Gr({ fog: !1, toneMapped: !1 });
      (this.lightPlane = new Yr(i, r)),
        this.add(this.lightPlane),
        (i = new de()),
        i.setAttribute("position", new ne([0, 0, 0, 0, 0, 1], 3)),
        (this.targetLine = new Yr(i, r)),
        this.add(this.targetLine),
        this.update();
    }
    (gl.prototype = Object.create(X.prototype)),
      (gl.prototype.constructor = gl),
      (gl.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }),
      (gl.prototype.update = function () {
        dl.setFromMatrixPosition(this.light.matrixWorld),
          fl.setFromMatrixPosition(this.light.target.matrixWorld),
          ml.subVectors(fl, dl),
          this.lightPlane.lookAt(fl),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(fl),
          (this.targetLine.scale.z = ml.length());
      });
    const vl = new w(),
      yl = new Ve();
    function xl(t) {
      const e = new de(),
        n = new Gr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
        i = [],
        r = [],
        o = {},
        s = new zt(16755200),
        a = new zt(16711680),
        c = new zt(43775),
        l = new zt(16777215),
        u = new zt(3355443);
      function h(t, e, n) {
        p(t, n), p(e, n);
      }
      function p(t, e) {
        i.push(0, 0, 0),
          r.push(e.r, e.g, e.b),
          void 0 === o[t] && (o[t] = []),
          o[t].push(i.length / 3 - 1);
      }
      h("n1", "n2", s),
        h("n2", "n4", s),
        h("n4", "n3", s),
        h("n3", "n1", s),
        h("f1", "f2", s),
        h("f2", "f4", s),
        h("f4", "f3", s),
        h("f3", "f1", s),
        h("n1", "f1", s),
        h("n2", "f2", s),
        h("n3", "f3", s),
        h("n4", "f4", s),
        h("p", "n1", a),
        h("p", "n2", a),
        h("p", "n3", a),
        h("p", "n4", a),
        h("u1", "u2", c),
        h("u2", "u3", c),
        h("u3", "u1", c),
        h("c", "t", l),
        h("p", "c", u),
        h("cn1", "cn2", u),
        h("cn3", "cn4", u),
        h("cf1", "cf2", u),
        h("cf3", "cf4", u),
        e.setAttribute("position", new ne(i, 3)),
        e.setAttribute("color", new ne(r, 3)),
        Kr.call(this, e, n),
        (this.type = "CameraHelper"),
        (this.camera = t),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = o),
        this.update();
    }
    function bl(t, e, n, i, r, o, s) {
      vl.set(r, o, s).unproject(i);
      const a = e[t];
      if (void 0 !== a) {
        const t = n.getAttribute("position");
        for (let e = 0, n = a.length; e < n; e++)
          t.setXYZ(a[e], vl.x, vl.y, vl.z);
      }
    }
    (xl.prototype = Object.create(Kr.prototype)),
      (xl.prototype.constructor = xl),
      (xl.prototype.update = function () {
        const t = this.geometry,
          e = this.pointMap;
        yl.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          bl("c", e, t, yl, 0, 0, -1),
          bl("t", e, t, yl, 0, 0, 1),
          bl("n1", e, t, yl, -1, -1, -1),
          bl("n2", e, t, yl, 1, -1, -1),
          bl("n3", e, t, yl, -1, 1, -1),
          bl("n4", e, t, yl, 1, 1, -1),
          bl("f1", e, t, yl, -1, -1, 1),
          bl("f2", e, t, yl, 1, -1, 1),
          bl("f3", e, t, yl, -1, 1, 1),
          bl("f4", e, t, yl, 1, 1, 1),
          bl("u1", e, t, yl, 0.7, 1.1, -1),
          bl("u2", e, t, yl, -0.7, 1.1, -1),
          bl("u3", e, t, yl, 0, 2, -1),
          bl("cf1", e, t, yl, -1, 0, 1),
          bl("cf2", e, t, yl, 1, 0, 1),
          bl("cf3", e, t, yl, 0, -1, 1),
          bl("cf4", e, t, yl, 0, 1, 1),
          bl("cn1", e, t, yl, -1, 0, -1),
          bl("cn2", e, t, yl, 1, 0, -1),
          bl("cn3", e, t, yl, 0, -1, -1),
          bl("cn4", e, t, yl, 0, 1, -1),
          (t.getAttribute("position").needsUpdate = !0);
      });
    const wl = new ct();
    function _l(t, e) {
      (this.object = t), void 0 === e && (e = 16776960);
      const n = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        i = new Float32Array(24),
        r = new de();
      r.setIndex(new Yt(n, 1)),
        r.setAttribute("position", new Yt(i, 3)),
        Kr.call(this, r, new Gr({ color: e, toneMapped: !1 })),
        (this.type = "BoxHelper"),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Ml(t, e) {
      (this.type = "Box3Helper"), (this.box = t), (e = e || 16776960);
      const n = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        i = new de();
      i.setIndex(new Yt(n, 1)),
        i.setAttribute(
          "position",
          new ne(
            [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
              -1, -1, 1, -1, -1,
            ],
            3
          )
        ),
        Kr.call(this, i, new Gr({ color: e, toneMapped: !1 })),
        (this.type = "Box3Helper"),
        this.geometry.computeBoundingSphere();
    }
    function Sl(t, e, n) {
      (this.plane = t), (this.size = void 0 === e ? 1 : e);
      const i = void 0 !== n ? n : 16776960,
        r = new de();
      r.setAttribute(
        "position",
        new ne(
          [
            1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
            1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
          ],
          3
        )
      ),
        r.computeBoundingSphere(),
        Yr.call(this, r, new Gr({ color: i, toneMapped: !1 })),
        (this.type = "PlaneHelper");
      const o = new de();
      o.setAttribute(
        "position",
        new ne([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
      ),
        o.computeBoundingSphere(),
        this.add(
          new Ce(
            o,
            new Wt({
              color: i,
              opacity: 0.2,
              transparent: !0,
              depthWrite: !1,
              toneMapped: !1,
            })
          )
        );
    }
    (_l.prototype = Object.create(Kr.prototype)),
      (_l.prototype.constructor = _l),
      (_l.prototype.update = function (t) {
        if (
          (void 0 !== t &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && wl.setFromObject(this.object),
          wl.isEmpty())
        )
          return;
        const e = wl.min,
          n = wl.max,
          i = this.geometry.attributes.position,
          r = i.array;
        (r[0] = n.x),
          (r[1] = n.y),
          (r[2] = n.z),
          (r[3] = e.x),
          (r[4] = n.y),
          (r[5] = n.z),
          (r[6] = e.x),
          (r[7] = e.y),
          (r[8] = n.z),
          (r[9] = n.x),
          (r[10] = e.y),
          (r[11] = n.z),
          (r[12] = n.x),
          (r[13] = n.y),
          (r[14] = e.z),
          (r[15] = e.x),
          (r[16] = n.y),
          (r[17] = e.z),
          (r[18] = e.x),
          (r[19] = e.y),
          (r[20] = e.z),
          (r[21] = n.x),
          (r[22] = e.y),
          (r[23] = e.z),
          (i.needsUpdate = !0),
          this.geometry.computeBoundingSphere();
      }),
      (_l.prototype.setFromObject = function (t) {
        return (this.object = t), this.update(), this;
      }),
      (_l.prototype.copy = function (t) {
        return Kr.prototype.copy.call(this, t), (this.object = t.object), this;
      }),
      (_l.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (Ml.prototype = Object.create(Kr.prototype)),
      (Ml.prototype.constructor = Ml),
      (Ml.prototype.updateMatrixWorld = function (t) {
        const e = this.box;
        e.isEmpty() ||
          (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          X.prototype.updateMatrixWorld.call(this, t));
      }),
      (Sl.prototype = Object.create(Yr.prototype)),
      (Sl.prototype.constructor = Sl),
      (Sl.prototype.updateMatrixWorld = function (t) {
        let e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, e),
          (this.children[0].material.side = e < 0 ? 1 : 0),
          this.lookAt(this.plane.normal),
          X.prototype.updateMatrixWorld.call(this, t);
      });
    const Tl = new w();
    let El, Al;
    function Ll(t, e, n, i, r, o) {
      X.call(this),
        (this.type = "ArrowHelper"),
        void 0 === t && (t = new w(0, 0, 1)),
        void 0 === e && (e = new w(0, 0, 0)),
        void 0 === n && (n = 1),
        void 0 === i && (i = 16776960),
        void 0 === r && (r = 0.2 * n),
        void 0 === o && (o = 0.2 * r),
        void 0 === El &&
          ((El = new de()),
          El.setAttribute("position", new ne([0, 0, 0, 0, 1, 0], 3)),
          (Al = new ws(0, 0.5, 1, 5, 1)),
          Al.translate(0, -0.5, 0)),
        this.position.copy(e),
        (this.line = new Yr(El, new Gr({ color: i, toneMapped: !1 }))),
        (this.line.matrixAutoUpdate = !1),
        this.add(this.line),
        (this.cone = new Ce(Al, new Wt({ color: i, toneMapped: !1 }))),
        (this.cone.matrixAutoUpdate = !1),
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, r, o);
    }
    function Rl(t) {
      const e = [
          0,
          0,
          0,
          (t = t || 1),
          0,
          0,
          0,
          0,
          0,
          0,
          t,
          0,
          0,
          0,
          0,
          0,
          0,
          t,
        ],
        n = new de();
      n.setAttribute("position", new ne(e, 3)),
        n.setAttribute(
          "color",
          new ne(
            [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            3
          )
        );
      const i = new Gr({ vertexColors: !0, toneMapped: !1 });
      Kr.call(this, n, i), (this.type = "AxesHelper");
    }
    (Ll.prototype = Object.create(X.prototype)),
      (Ll.prototype.constructor = Ll),
      (Ll.prototype.setDirection = function (t) {
        if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          Tl.set(t.z, 0, -t.x).normalize();
          const e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(Tl, e);
        }
      }),
      (Ll.prototype.setLength = function (t, e, n) {
        void 0 === e && (e = 0.2 * t),
          void 0 === n && (n = 0.2 * e),
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, e, n),
          (this.cone.position.y = t),
          this.cone.updateMatrix();
      }),
      (Ll.prototype.setColor = function (t) {
        this.line.material.color.set(t), this.cone.material.color.set(t);
      }),
      (Ll.prototype.copy = function (t) {
        return (
          X.prototype.copy.call(this, t, !1),
          this.line.copy(t.line),
          this.cone.copy(t.cone),
          this
        );
      }),
      (Ll.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (Rl.prototype = Object.create(Kr.prototype)),
      (Rl.prototype.constructor = Rl);
    const Pl = Math.pow(2, 8),
      Cl = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      Ol = 5 + Cl.length,
      Il = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
      Dl = new Ha(),
      {
        _lodPlanes: Nl,
        _sizeLods: kl,
        _sigmas: Ul,
      } = (function () {
        const t = [],
          e = [],
          n = [];
        let i = 8;
        for (let r = 0; r < Ol; r++) {
          const o = Math.pow(2, i);
          e.push(o);
          let s = 1 / o;
          r > 4 ? (s = Cl[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
          const a = 1 / (o - 1),
            c = -a / 2,
            l = 1 + a / 2,
            u = [c, c, l, c, l, l, c, c, l, l, c, l],
            h = 6,
            p = 6,
            d = 3,
            f = 2,
            m = 1,
            g = new Float32Array(d * p * h),
            v = new Float32Array(f * p * h),
            y = new Float32Array(m * p * h);
          for (let t = 0; t < h; t++) {
            const e = ((t % 3) * 2) / 3 - 1,
              n = t > 2 ? 0 : -1,
              i = [
                e,
                n,
                0,
                e + 2 / 3,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n + 1,
                0,
              ];
            g.set(i, d * p * t), v.set(u, f * p * t);
            const r = [t, t, t, t, t, t];
            y.set(r, m * p * t);
          }
          const x = new de();
          x.setAttribute("position", new Yt(g, d)),
            x.setAttribute("uv", new Yt(v, f)),
            x.setAttribute("faceIndex", new Yt(y, m)),
            t.push(x),
            i > 4 && i--;
        }
        return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
      })();
    let zl = null;
    const Bl = (1 + Math.sqrt(5)) / 2,
      Fl = 1 / Bl,
      Hl = [
        new w(1, 1, 1),
        new w(-1, 1, 1),
        new w(1, 1, -1),
        new w(-1, 1, -1),
        new w(0, Bl, Fl),
        new w(0, Bl, -Fl),
        new w(Fl, 0, Bl),
        new w(-Fl, 0, Bl),
        new w(Bl, Fl, 0),
        new w(-Bl, Fl, 0),
      ];
    function Gl(t) {
      (this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._blurMaterial = (function (t) {
          const e = new Float32Array(t),
            n = new w(0, 1, 0);
          return new Ls({
            name: "SphericalGaussianBlur",
            defines: { n: t },
            uniforms: {
              envMap: { value: null },
              samples: { value: 1 },
              weights: { value: e },
              latitudinal: { value: !1 },
              dTheta: { value: 0 },
              mipInt: { value: 0 },
              poleAxis: { value: n },
              inputEncoding: { value: Il[3e3] },
              outputEncoding: { value: Il[3e3] },
            },
            vertexShader: Yl(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${Zl()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        })(20)),
        (this._equirectShader = null),
        (this._cubemapShader = null),
        this._compileMaterial(this._blurMaterial);
    }
    function jl(t) {
      return (
        void 0 !== t &&
        1009 === t.type &&
        (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
      );
    }
    function Vl(t) {
      const e = new g(3 * Pl, 3 * Pl, t);
      return (
        (e.texture.mapping = 306),
        (e.texture.name = "PMREM.cubeUv"),
        (e.scissorTest = !0),
        e
      );
    }
    function Wl(t, e, n, i, r) {
      t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
    }
    function ql() {
      return new Ls({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: { value: null },
          texelSize: { value: new l(1, 1) },
          inputEncoding: { value: Il[3e3] },
          outputEncoding: { value: Il[3e3] },
        },
        vertexShader: Yl(),
        fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${Zl()}\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Xl() {
      return new Ls({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: { value: null },
          inputEncoding: { value: Il[3e3] },
          outputEncoding: { value: Il[3e3] },
        },
        vertexShader: Yl(),
        fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${Zl()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Yl() {
      return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";
    }
    function Zl() {
      return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";
    }
    Gl.prototype = {
      constructor: Gl,
      fromScene: function (t, e = 0, n = 0.1, i = 100) {
        zl = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return (
          this._sceneToCubeUV(t, n, i, r),
          e > 0 && this._blur(r, 0, 0, e),
          this._applyPMREM(r),
          this._cleanup(r),
          r
        );
      },
      fromEquirectangular: function (t) {
        return this._fromTexture(t);
      },
      fromCubemap: function (t) {
        return this._fromTexture(t);
      },
      compileCubemapShader: function () {
        null === this._cubemapShader &&
          ((this._cubemapShader = Xl()),
          this._compileMaterial(this._cubemapShader));
      },
      compileEquirectangularShader: function () {
        null === this._equirectShader &&
          ((this._equirectShader = ql()),
          this._compileMaterial(this._equirectShader));
      },
      dispose: function () {
        this._blurMaterial.dispose(),
          null !== this._cubemapShader && this._cubemapShader.dispose(),
          null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < Nl.length; t++) Nl[t].dispose();
      },
      _cleanup: function (t) {
        this._pingPongRenderTarget.dispose(),
          this._renderer.setRenderTarget(zl),
          (t.scissorTest = !1),
          Wl(t, 0, 0, t.width, t.height);
      },
      _fromTexture: function (t) {
        zl = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return (
          this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        );
      },
      _allocateTargets: function (t) {
        const e = {
            magFilter: 1003,
            minFilter: 1003,
            generateMipmaps: !1,
            type: 1009,
            format: 1023,
            encoding: jl(t) ? t.encoding : 3002,
            depthBuffer: !1,
            stencilBuffer: !1,
          },
          n = Vl(e);
        return (n.depthBuffer = !t), (this._pingPongRenderTarget = Vl(e)), n;
      },
      _compileMaterial: function (t) {
        const e = new Ce(Nl[0], t);
        this._renderer.compile(e, Dl);
      },
      _sceneToCubeUV: function (t, e, n, i) {
        const r = new We(90, 1, e, n),
          o = [1, -1, 1, 1, 1, 1],
          s = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          c = a.outputEncoding,
          l = a.toneMapping,
          u = a.getClearColor(),
          h = a.getClearAlpha();
        (a.toneMapping = 0), (a.outputEncoding = 3e3);
        let p = t.background;
        if (p && p.isColor) {
          p.convertSRGBToLinear();
          const e = Math.max(p.r, p.g, p.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
          p = p.multiplyScalar(Math.pow(2, -n));
          const i = (n + 128) / 255;
          a.setClearColor(p, i), (t.background = null);
        }
        for (let e = 0; e < 6; e++) {
          const n = e % 3;
          0 == n
            ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0))
            : 1 == n
            ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0))
            : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])),
            Wl(i, n * Pl, e > 2 ? Pl : 0, Pl, Pl),
            a.setRenderTarget(i),
            a.render(t, r);
        }
        (a.toneMapping = l), (a.outputEncoding = c), a.setClearColor(u, h);
      },
      _textureToCubeUV: function (t, e) {
        const n = this._renderer;
        t.isCubeTexture
          ? null == this._cubemapShader && (this._cubemapShader = Xl())
          : null == this._equirectShader && (this._equirectShader = ql());
        const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          r = new Ce(Nl[0], i),
          o = i.uniforms;
        (o.envMap.value = t),
          t.isCubeTexture ||
            o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
          (o.inputEncoding.value = Il[t.encoding]),
          (o.outputEncoding.value = Il[e.texture.encoding]),
          Wl(e, 0, 0, 3 * Pl, 2 * Pl),
          n.setRenderTarget(e),
          n.render(r, Dl);
      },
      _applyPMREM: function (t) {
        const e = this._renderer,
          n = e.autoClear;
        e.autoClear = !1;
        for (let e = 1; e < Ol; e++) {
          const n = Math.sqrt(Ul[e] * Ul[e] - Ul[e - 1] * Ul[e - 1]),
            i = Hl[(e - 1) % Hl.length];
          this._blur(t, e - 1, e, n, i);
        }
        e.autoClear = n;
      },
      _blur: function (t, e, n, i, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, n, i, "latitudinal", r),
          this._halfBlur(o, t, n, n, i, "longitudinal", r);
      },
      _halfBlur: function (t, e, n, i, r, o, s) {
        const a = this._renderer,
          c = this._blurMaterial;
        "latitudinal" !== o &&
          "longitudinal" !== o &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const l = new Ce(Nl[i], c),
          u = c.uniforms,
          h = kl[n] - 1,
          p = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
          d = r / p,
          f = isFinite(r) ? 1 + Math.floor(3 * d) : 20;
        f > 20 &&
          console.warn(
            `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
          );
        const m = [];
        let g = 0;
        for (let t = 0; t < 20; ++t) {
          const e = t / d,
            n = Math.exp((-e * e) / 2);
          m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
        }
        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
        (u.envMap.value = t.texture),
          (u.samples.value = f),
          (u.weights.value = m),
          (u.latitudinal.value = "latitudinal" === o),
          s && (u.poleAxis.value = s),
          (u.dTheta.value = p),
          (u.mipInt.value = 8 - n),
          (u.inputEncoding.value = Il[t.texture.encoding]),
          (u.outputEncoding.value = Il[t.texture.encoding]);
        const v = kl[i];
        Wl(
          e,
          3 * Math.max(0, Pl - 2 * v),
          (0 === i ? 0 : 2 * Pl) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
          3 * v,
          2 * v
        ),
          a.setRenderTarget(e),
          a.render(l, Dl);
      },
    };
    function Jl(t) {
      console.warn(
        "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
      ),
        xa.call(this, t),
        (this.type = "catmullrom");
    }
    (ha.create = function (t, e) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (t.prototype = Object.create(ha.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.getPoint = e),
        t
      );
    }),
      Object.assign(Ca.prototype, {
        createPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          const e = this.getPoints(t);
          return this.createGeometry(e);
        },
        createSpacedPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          const e = this.getSpacedPoints(t);
          return this.createGeometry(e);
        },
        createGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          const e = new ze();
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.vertices.push(new w(i.x, i.y, i.z || 0));
          }
          return e;
        },
      }),
      Object.assign(Oa.prototype, {
        fromPoints: function (t) {
          return (
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
            this.setFromPoints(t)
          );
        },
      }),
      Object.create(xa.prototype),
      Object.create(xa.prototype),
      (Jl.prototype = Object.create(xa.prototype)),
      Object.assign(Jl.prototype, {
        initFromArray: function () {
          console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function () {
          console.error(
            "THREE.Spline: .getControlPointsArray() has been removed."
          );
        },
        reparametrizeByArcLength: function () {
          console.error(
            "THREE.Spline: .reparametrizeByArcLength() has been removed."
          );
        },
      }),
      (hl.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (ol.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      Object.assign(na.prototype, {
        extractUrlBase: function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            Ja(t)
          );
        },
      }),
      (na.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      Object.assign(ec.prototype, {
        setTexturePath: function (t) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(t)
          );
        },
      }),
      Object.assign(Zc.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      Object.assign(ct.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      Object.assign(ht.prototype, {
        empty: function () {
          return (
            console.warn(
              "THREE.Sphere: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
      }),
      (Ke.prototype.setFromMatrix = function (t) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(t)
        );
      }),
      ($c.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      Object.assign(c, {
        random16: function () {
          return (
            console.warn(
              "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
            ),
            Math.random()
          );
        },
        nearestPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
            ),
            c.floorPowerOfTwo(t)
          );
        },
        nextPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
            ),
            c.ceilPowerOfTwo(t)
          );
        },
      }),
      Object.assign(u.prototype, {
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        },
        applyToBufferAttribute: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        },
      }),
      Object.assign(R.prototype, {
        extractPosition: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        },
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        getPosition: function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new w().setFromMatrixColumn(this, 3)
          );
        },
        setRotationFromQuaternion: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        },
        multiplyToArray: function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector4: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        },
        rotateAxis: function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        },
        crossVector: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        translate: function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBufferAttribute: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        },
        makeFrustum: function (t, e, n, i, r, o) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, i, n, r, o)
          );
        },
      }),
      (Mt.prototype.isIntersectionLine = function (t) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(t)
        );
      }),
      (y.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          t.applyQuaternion(this)
        );
      }),
      Object.assign(xt.prototype, {
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionPlane: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
      }),
      Object.assign(Dt.prototype, {
        area: function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        },
        barycoordFromPoint: function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        },
        midpoint: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        },
        normal: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        },
        plane: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        },
      }),
      Object.assign(Dt, {
        barycoordFromPoint: function (t, e, n, i, r) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            Dt.getBarycoord(t, e, n, i, r)
          );
        },
        normal: function (t, e, n, i) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            Dt.getNormal(t, e, n, i)
          );
        },
      }),
      Object.assign(Ia.prototype, {
        extractAllPoints: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        },
        extrude: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new rs(this, t)
          );
        },
        makeGeometry: function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new gs(this, t)
          );
        },
      }),
      Object.assign(l.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(w.prototype, {
        setEulerFromRotationMatrix: function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        },
        setEulerFromQuaternion: function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        },
        getPositionFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        },
        getScaleFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        },
        getColumnFromMatrix: function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        },
        applyProjection: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        },
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(m.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(ze.prototype, {
        computeTangents: function () {
          console.error("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function () {
          console.error(
            "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
          );
        },
        applyMatrix: function (t) {
          return (
            console.warn(
              "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        },
      }),
      Object.assign(X.prototype, {
        getChildByName: function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        },
        renderDepth: function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        },
        translate: function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        },
        getWorldRotation: function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        },
        applyMatrix: function (t) {
          return (
            console.warn(
              "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        },
      }),
      Object.defineProperties(X.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = t);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      Object.assign(Ce.prototype, {
        setDrawMode: function () {
          console.error(
            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        },
      }),
      Object.defineProperties(Ce.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              0
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      }),
      Object.defineProperties(Cr.prototype, {
        objects: {
          get: function () {
            return (
              console.warn("THREE.LOD: .objects has been renamed to .levels."),
              this.levels
            );
          },
        },
      }),
      Object.defineProperty(Nr.prototype, "useVertexTexture", {
        get: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
      }),
      (Or.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      Object.defineProperty(ha.prototype, "__arcLengthDivisions", {
        get: function () {
          return (
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
            this.arcLengthDivisions
          );
        },
        set: function (t) {
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
          ),
            (this.arcLengthDivisions = t);
        },
      }),
      (We.prototype.setLens = function (t, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== e && (this.filmGauge = e),
          this.setFocalLength(t);
      }),
      Object.defineProperties(Da.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = t);
          },
        },
        shadowCameraLeft: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = t);
          },
        },
        shadowCameraRight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = t);
          },
        },
        shadowCameraTop: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = t);
          },
        },
        shadowCameraBottom: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = t);
          },
        },
        shadowCameraNear: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = t);
          },
        },
        shadowCameraFar: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = t);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = t);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = t);
          },
        },
        shadowMapHeight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = t);
          },
        },
      }),
      Object.defineProperties(Yt.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              35048 === this.usage
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(35048);
          },
        },
      }),
      Object.assign(Yt.prototype, {
        setDynamic: function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
          );
        },
        copyIndicesArray: function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        },
        setArray: function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        },
      }),
      Object.assign(de.prototype, {
        addIndex: function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        },
        addAttribute: function (t, e) {
          return (
            console.warn(
              "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? "index" === t
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.setAttribute(t, new Yt(arguments[1], arguments[2])))
          );
        },
        addDrawCall: function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        },
        clearDrawCalls: function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        },
        computeTangents: function () {
          console.warn(
            "THREE.BufferGeometry: .computeTangents() has been removed."
          );
        },
        computeOffsets: function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        },
        removeAttribute: function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
            ),
            this.deleteAttribute(t)
          );
        },
        applyMatrix: function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        },
      }),
      Object.defineProperties(de.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      Object.defineProperties(Ka.prototype, {
        maxInstancedCount: {
          get: function () {
            return (
              console.warn(
                "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
              ),
              this.instanceCount
            );
          },
          set: function (t) {
            console.warn(
              "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
            ),
              (this.instanceCount = t);
          },
        },
      }),
      Object.defineProperties(Wc.prototype, {
        linePrecision: {
          get: function () {
            return (
              console.warn(
                "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
              ),
              this.params.Line.threshold
            );
          },
          set: function (t) {
            console.warn(
              "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
            ),
              (this.params.Line.threshold = t);
          },
        },
      }),
      Object.defineProperties(ur.prototype, {
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
              ),
              35048 === this.usage
            );
          },
          set: function (t) {
            console.warn(
              "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
            ),
              this.setUsage(t);
          },
        },
      }),
      Object.assign(ur.prototype, {
        setDynamic: function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
          );
        },
        setArray: function () {
          console.error(
            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        },
      }),
      Object.assign(os.prototype, {
        getArrays: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
          );
        },
        addShapeList: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
          );
        },
        addShape: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
          );
        },
      }),
      Object.defineProperties(jc.prototype, {
        dynamic: {
          set: function () {
            console.warn(
              "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
            );
          },
        },
        onUpdate: {
          value: function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          },
        },
      }),
      Object.defineProperties(Vt.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new zt()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === t);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = t);
          },
        },
      }),
      Object.defineProperties(Cs.prototype, {
        metal: {
          get: function () {
            return (
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
            );
          },
        },
      }),
      Object.defineProperties(je.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (t) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = t);
          },
        },
      }),
      Object.assign(sr.prototype, {
        clearTarget: function (t, e, n, i) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, n, i);
        },
        animate: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        },
        getCurrentRenderTarget: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        },
        getMaxAnisotropy: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        },
        getPrecision: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        },
        resetGLState: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        },
        supportsFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        },
        supportsHalfFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        },
        supportsStandardDerivatives: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        },
        supportsCompressedTextureS3TC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        },
        supportsCompressedTexturePVRTC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        },
        supportsBlendMinMax: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        },
        supportsVertexTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        },
        supportsInstancedArrays: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        },
        enableScissorTest: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        },
        initMaterial: function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        },
        addPrePlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        },
        addPostPlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        },
        updateShadowMap: function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        },
        setFaceCulling: function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        },
        allocTextureUnit: function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        },
        setTexture: function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        },
        setTexture2D: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        },
        setTextureCube: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        },
        getActiveMipMapLevel: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        },
      }),
      Object.defineProperties(sr.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = t);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = t);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === t ? 3001 : 3e3);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      }),
      Object.defineProperties(Ki.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties(g.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = t);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = t);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = t);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = t);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = t);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = t);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = t);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = t);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = t);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = t);
          },
        },
      }),
      Object.defineProperties(Mc.prototype, {
        load: {
          value: function (t) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            const e = this;
            return (
              new pc().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          },
        },
        startTime: {
          set: function () {
            console.warn("THREE.Audio: .startTime is now .play( delay ).");
          },
        },
      }),
      (Rc.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (qe.prototype.updateCubeMap = function (t, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(t, e)
        );
      });
    (p.crossOrigin = void 0),
      (p.loadTexture = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const r = new ua();
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o;
      }),
      (p.loadTextureCube = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const r = new la();
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o;
      }),
      (p.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (p.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: "118" } })
      );
    var Kl = function () {
      var t = {
        _allEvents: Object.create(null),
        use: function (e, n) {
          return e(t, n) || t;
        },
        on: function (e, n, i) {
          var r = t._allEvents[e] || (t._allEvents[e] = []);
          var o = i
            ? function i() {
                i.called ||
                  (t.off(e, i), n.apply(n, arguments), (i.called = !0));
              }
            : n;
          return (o.__sourceString = n.toString()), r.push(o), t;
        },
        once: function (e, n) {
          return t.on(e, n, !0), t;
        },
        off: function (e, n) {
          if (n && t._allEvents[e]) {
            var i = n.toString();
            t._allEvents[e] = t._allEvents[e].filter(function (t) {
              return t.__sourceString !== i;
            });
          } else
            e ? (t._allEvents[e] = []) : (t._allEvents = Object.create(null));
          return t;
        },
        emit: function (e) {
          if ("*" !== e) {
            var n = [].slice.call(arguments);
            (t._allEvents[e] || []).map(function (t) {
              t.apply(t, n.slice(1));
            }),
              (t._allEvents["*"] || []).map(function (t) {
                t.apply(t, n);
              });
          }
          return t;
        },
      };
      return t;
    };
    function $l(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var Ql = new ((function () {
        function t() {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            (this.resolvers = []),
            (this.manifest = []),
            (this.emitter = Kl());
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "warn",
              value: function () {
                for (
                  var t, e = arguments.length, n = new Array(e), i = 0;
                  i < e;
                  i++
                )
                  n[i] = arguments[i];
                (t = console).warn.apply(t, ["[Preloader]"].concat(n));
              },
            },
            {
              key: "init",
              value: function () {
                for (
                  var t = this, e = arguments.length, n = new Array(e), i = 0;
                  i < e;
                  i++
                )
                  n[i] = arguments[i];
                n.forEach(function (e) {
                  e.hasOwnProperty("type") ||
                    t.warn(
                      "init()",
                      "This resolver shoud have a `type` property",
                      e
                    ),
                    "function" != typeof e.resolve &&
                      t.warn(
                        "init()",
                        "This resolver should implement a `resolve` function",
                        e
                      ),
                    "function" != typeof e.get &&
                      t.warn(
                        "init()",
                        "This resolver should implement a `get` function",
                        e
                      ),
                    t.resolvers.push(e);
                });
              },
            },
            {
              key: "load",
              value: function (t) {
                var e = this,
                  n =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : "/",
                  i =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : null;
                Array.isArray(t) ||
                  this.warn("load()", "manifest should be an array", t),
                  (t = t.map(function (t) {
                    var e = t.url;
                    return (
                      t.dataUrl ||
                        ((e = t.cdn && i ? i + t.url : n + t.url),
                        (e += "?v=" + t.version)),
                      Object.assign({}, t, { url: e })
                    );
                  })),
                  (this.manifest = this.manifest.concat(t));
                for (var r = 0, o = t.length; r < o; r++) {
                  for (var s = t[r], a = !1, c = 0, l = t.length; c < l; c++)
                    if (r !== c && t[c].id === s.id) {
                      a = !0;
                      break;
                    }
                  if (a) {
                    this.warn(
                      "load()",
                      "This id is used twice in the manifest: `" + s.id + "`"
                    );
                    break;
                  }
                }
                var u = t.length,
                  h = 0,
                  p = t.map(function (t) {
                    var n = e.getResolverForType(t.type).resolve(t);
                    return (
                      "function" != typeof n.then &&
                        e.warn(
                          "resolver for type `" +
                            t.type +
                            "` does not return a promise in its resolve method, check its implementation"
                        ),
                      n.then(function (t) {
                        return h++, e.emitter.emit("progress", h / u), t;
                      })
                    );
                  });
                return Promise.all(p)
                  .catch(function (t) {
                    return console.error(t);
                  })
                  .then(function (t) {
                    return e.emitter.emit("complete", t), t;
                  });
              },
            },
            {
              key: "getResolverForType",
              value: function (t) {
                return this.resolvers.find(function (e) {
                  return e.type === t;
                });
              },
            },
            {
              key: "get",
              value: function (t) {
                var e = this.manifest.find(function (e) {
                  return e.id === t;
                });
                if (e) {
                  for (
                    var n = this.getResolverForType(e.type),
                      i = arguments.length,
                      r = new Array(i > 1 ? i - 1 : 0),
                      o = 1;
                    o < i;
                    o++
                  )
                    r[o - 1] = arguments[o];
                  return n.get(e, r);
                }
              },
            },
          ]) && $l(e.prototype, n),
          i && $l(e, i),
          t
        );
      })())(),
      tu = (function () {
        function t(t) {
          na.call(this, t),
            (this.dracoLoader = null),
            (this.ddsLoader = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new s(t);
            });
        }
        function e() {
          var t = {};
          return {
            get: function (e) {
              return t[e];
            },
            add: function (e, n) {
              t[e] = n;
            },
            remove: function (e) {
              delete t[e];
            },
            removeAll: function () {
              t = {};
            },
          };
        }
        t.prototype = Object.assign(Object.create(na.prototype), {
          constructor: t,
          load: function (t, e, n, i) {
            var r,
              o = this;
            (r =
              "" !== this.resourcePath
                ? this.resourcePath
                : "" !== this.path
                ? this.path
                : Ja(t)),
              o.manager.itemStart(t);
            var s = function (e) {
                i ? i(e) : console.error(e),
                  o.manager.itemError(t),
                  o.manager.itemEnd(t);
              },
              a = new ra(o.manager);
            a.setPath(this.path),
              a.setResponseType("arraybuffer"),
              a.setRequestHeader(this.requestHeader),
              "use-credentials" === o.crossOrigin && a.setWithCredentials(!0),
              a.load(
                t,
                function (n) {
                  try {
                    o.parse(
                      n,
                      r,
                      function (n) {
                        e(n), o.manager.itemEnd(t);
                      },
                      s
                    );
                  } catch (t) {
                    s(t);
                  }
                },
                n,
                s
              );
          },
          setDRACOLoader: function (t) {
            return (this.dracoLoader = t), this;
          },
          setDDSLoader: function (t) {
            return (this.ddsLoader = t), this;
          },
          register: function (t) {
            return (
              -1 === this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.push(t),
              this
            );
          },
          unregister: function (t) {
            return (
              -1 !== this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
              this
            );
          },
          parse: function (t, e, s, c) {
            var l,
              u = {},
              h = {};
            if ("string" == typeof t) l = t;
            else if (Za(new Uint8Array(t, 0, 4)) === a) {
              try {
                u[n.KHR_BINARY_GLTF] = new p(t);
              } catch (t) {
                return void (c && c(t));
              }
              l = u[n.KHR_BINARY_GLTF].content;
            } else l = Za(new Uint8Array(t));
            var m = JSON.parse(l);
            if (void 0 === m.asset || m.asset.version[0] < 2)
              c &&
                c(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                );
            else {
              var y = new V(m, {
                path: e || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                manager: this.manager,
              });
              y.fileLoader.setRequestHeader(this.requestHeader);
              for (var x = 0; x < this.pluginCallbacks.length; x++) {
                var b = this.pluginCallbacks[x](y);
                (h[b.name] = b), (u[b.name] = !0);
              }
              if (m.extensionsUsed)
                for (x = 0; x < m.extensionsUsed.length; ++x) {
                  var w = m.extensionsUsed[x],
                    _ = m.extensionsRequired || [];
                  switch (w) {
                    case n.KHR_LIGHTS_PUNCTUAL:
                      u[w] = new r(m);
                      break;
                    case n.KHR_MATERIALS_UNLIT:
                      u[w] = new o();
                      break;
                    case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                      u[w] = new g();
                      break;
                    case n.KHR_DRACO_MESH_COMPRESSION:
                      u[w] = new d(m, this.dracoLoader);
                      break;
                    case n.MSFT_TEXTURE_DDS:
                      u[w] = new i(this.ddsLoader);
                      break;
                    case n.KHR_TEXTURE_TRANSFORM:
                      u[w] = new f();
                      break;
                    case n.KHR_MESH_QUANTIZATION:
                      u[w] = new v();
                      break;
                    default:
                      _.indexOf(w) >= 0 &&
                        void 0 === h[w] &&
                        console.warn(
                          'THREE.GLTFLoader: Unknown extension "' + w + '".'
                        );
                  }
                }
              y.setExtensions(u), y.setPlugins(h), y.parse(s, c);
            }
          },
        });
        var n = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            "KHR_materials_pbrSpecularGlossiness",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          MSFT_TEXTURE_DDS: "MSFT_texture_dds",
        };
        function i(t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"
            );
          (this.name = n.MSFT_TEXTURE_DDS), (this.ddsLoader = t);
        }
        function r(t) {
          this.name = n.KHR_LIGHTS_PUNCTUAL;
          var e = (t.extensions && t.extensions[n.KHR_LIGHTS_PUNCTUAL]) || {};
          this.lightDefs = e.lights || [];
        }
        function o() {
          this.name = n.KHR_MATERIALS_UNLIT;
        }
        function s(t) {
          (this.parser = t), (this.name = n.KHR_MATERIALS_CLEARCOAT);
        }
        (r.prototype.loadLight = function (t) {
          var e,
            n = this.lightDefs[t],
            i = new zt(16777215);
          void 0 !== n.color && i.fromArray(n.color);
          var r = void 0 !== n.range ? n.range : 0;
          switch (n.type) {
            case "directional":
              (e = new ja(i)).target.position.set(0, 0, -1), e.add(e.target);
              break;
            case "point":
              (e = new Fa(i)).distance = r;
              break;
            case "spot":
              ((e = new za(i)).distance = r),
                (n.spot = n.spot || {}),
                (n.spot.innerConeAngle =
                  void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0),
                (n.spot.outerConeAngle =
                  void 0 !== n.spot.outerConeAngle
                    ? n.spot.outerConeAngle
                    : Math.PI / 4),
                (e.angle = n.spot.outerConeAngle),
                (e.penumbra =
                  1 - n.spot.innerConeAngle / n.spot.outerConeAngle),
                e.target.position.set(0, 0, -1),
                e.add(e.target);
              break;
            default:
              throw new Error(
                'THREE.GLTFLoader: Unexpected light type, "' + n.type + '".'
              );
          }
          return (
            e.position.set(0, 0, 0),
            (e.decay = 2),
            void 0 !== n.intensity && (e.intensity = n.intensity),
            (e.name = n.name || "light_" + t),
            Promise.resolve(e)
          );
        }),
          (o.prototype.getMaterialType = function () {
            return Wt;
          }),
          (o.prototype.extendParams = function (t, e, n) {
            var i = [];
            (t.color = new zt(1, 1, 1)), (t.opacity = 1);
            var r = e.pbrMetallicRoughness;
            if (r) {
              if (Array.isArray(r.baseColorFactor)) {
                var o = r.baseColorFactor;
                t.color.fromArray(o), (t.opacity = o[3]);
              }
              void 0 !== r.baseColorTexture &&
                i.push(n.assignTexture(t, "map", r.baseColorTexture));
            }
            return Promise.all(i);
          }),
          (s.prototype.getMaterialType = function () {
            return Ps;
          }),
          (s.prototype.extendMaterialParams = function (t, e) {
            var n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            var r = [],
              o = i.extensions[this.name];
            if (
              (void 0 !== o.clearcoatFactor &&
                (e.clearcoat = o.clearcoatFactor),
              void 0 !== o.clearcoatTexture &&
                r.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)),
              void 0 !== o.clearcoatRoughnessFactor &&
                (e.clearcoatRoughness = o.clearcoatRoughnessFactor),
              void 0 !== o.clearcoatRoughnessTexture &&
                r.push(
                  n.assignTexture(
                    e,
                    "clearcoatRoughnessMap",
                    o.clearcoatRoughnessTexture
                  )
                ),
              void 0 !== o.clearcoatNormalTexture &&
                (r.push(
                  n.assignTexture(
                    e,
                    "clearcoatNormalMap",
                    o.clearcoatNormalTexture
                  )
                ),
                void 0 !== o.clearcoatNormalTexture.scale))
            ) {
              var s = o.clearcoatNormalTexture.scale;
              e.clearcoatNormalScale = new l(s, s);
            }
            return Promise.all(r);
          });
        var a = "glTF",
          u = 1313821514,
          h = 5130562;
        function p(t) {
          (this.name = n.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          var e = new DataView(t, 0, 12);
          if (
            ((this.header = {
              magic: Za(new Uint8Array(t.slice(0, 4))),
              version: e.getUint32(4, !0),
              length: e.getUint32(8, !0),
            }),
            this.header.magic !== a)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          for (var i = new DataView(t, 12), r = 0; r < i.byteLength; ) {
            var o = i.getUint32(r, !0);
            r += 4;
            var s = i.getUint32(r, !0);
            if (((r += 4), s === u)) {
              var c = new Uint8Array(t, 12 + r, o);
              this.content = Za(c);
            } else if (s === h) {
              var l = 12 + r;
              this.body = t.slice(l, l + o);
            }
            r += o;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
        function d(t, e) {
          if (!e)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = n.KHR_DRACO_MESH_COMPRESSION),
            (this.json = t),
            (this.dracoLoader = e),
            this.dracoLoader.preload();
        }
        function f() {
          this.name = n.KHR_TEXTURE_TRANSFORM;
        }
        function m(t) {
          Rs.call(this), (this.isGLTFSpecularGlossinessMaterial = !0);
          var e = [
              "#ifdef USE_SPECULARMAP",
              "\tuniform sampler2D specularMap;",
              "#endif",
            ].join("\n"),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "\tuniform sampler2D glossinessMap;",
              "#endif",
            ].join("\n"),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
              "\ttexelSpecular = sRGBToLinear( texelSpecular );",
              "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tspecularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join("\n"),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tglossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join("\n"),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb;",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor.rgb;",
            ].join("\n"),
            s = {
              specular: { value: new zt().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = s),
            (this.onBeforeCompile = function (t) {
              for (var a in s) t.uniforms[a] = s[a];
              (t.fragmentShader = t.fragmentShader.replace(
                "uniform float roughness;",
                "uniform vec3 specular;"
              )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "#include <roughnessmap_pars_fragment>",
                  e
                )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "#include <metalnessmap_pars_fragment>",
                  n
                )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "#include <roughnessmap_fragment>",
                  i
                )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "#include <metalnessmap_fragment>",
                  r
                )),
                (t.fragmentShader = t.fragmentShader.replace(
                  "#include <lights_physical_fragment>",
                  o
                ));
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return s.specular.value;
                },
                set: function (t) {
                  s.specular.value = t;
                },
              },
              specularMap: {
                get: function () {
                  return s.specularMap.value;
                },
                set: function (t) {
                  s.specularMap.value = t;
                },
              },
              glossiness: {
                get: function () {
                  return s.glossiness.value;
                },
                set: function (t) {
                  s.glossiness.value = t;
                },
              },
              glossinessMap: {
                get: function () {
                  return s.glossinessMap.value;
                },
                set: function (t) {
                  (s.glossinessMap.value = t),
                    t
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_ROUGHNESSMAP = ""))
                      : (delete this.defines.USE_ROUGHNESSMAP,
                        delete this.defines.USE_GLOSSINESSMAP);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(t);
        }
        function g() {
          return {
            name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
            specularGlossinessParams: [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ],
            getMaterialType: function () {
              return m;
            },
            extendParams: function (t, e, n) {
              var i = e.extensions[this.name];
              (t.color = new zt(1, 1, 1)), (t.opacity = 1);
              var r = [];
              if (Array.isArray(i.diffuseFactor)) {
                var o = i.diffuseFactor;
                t.color.fromArray(o), (t.opacity = o[3]);
              }
              if (
                (void 0 !== i.diffuseTexture &&
                  r.push(n.assignTexture(t, "map", i.diffuseTexture)),
                (t.emissive = new zt(0, 0, 0)),
                (t.glossiness =
                  void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
                (t.specular = new zt(1, 1, 1)),
                Array.isArray(i.specularFactor) &&
                  t.specular.fromArray(i.specularFactor),
                void 0 !== i.specularGlossinessTexture)
              ) {
                var s = i.specularGlossinessTexture;
                r.push(n.assignTexture(t, "glossinessMap", s)),
                  r.push(n.assignTexture(t, "specularMap", s));
              }
              return Promise.all(r);
            },
            createMaterial: function (t) {
              var e = new m(t);
              return (
                (e.fog = !0),
                (e.color = t.color),
                (e.map = void 0 === t.map ? null : t.map),
                (e.lightMap = null),
                (e.lightMapIntensity = 1),
                (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
                (e.aoMapIntensity = 1),
                (e.emissive = t.emissive),
                (e.emissiveIntensity = 1),
                (e.emissiveMap =
                  void 0 === t.emissiveMap ? null : t.emissiveMap),
                (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
                (e.bumpScale = 1),
                (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
                (e.normalMapType = 0),
                t.normalScale && (e.normalScale = t.normalScale),
                (e.displacementMap = null),
                (e.displacementScale = 1),
                (e.displacementBias = 0),
                (e.specularMap =
                  void 0 === t.specularMap ? null : t.specularMap),
                (e.specular = t.specular),
                (e.glossinessMap =
                  void 0 === t.glossinessMap ? null : t.glossinessMap),
                (e.glossiness = t.glossiness),
                (e.alphaMap = null),
                (e.envMap = void 0 === t.envMap ? null : t.envMap),
                (e.envMapIntensity = 1),
                (e.refractionRatio = 0.98),
                e
              );
            },
          };
        }
        function v() {
          this.name = n.KHR_MESH_QUANTIZATION;
        }
        function y(t, e, n, i) {
          Bs.call(this, t, e, n, i);
        }
        (d.prototype.decodePrimitive = function (t, e) {
          var n = this.json,
            i = this.dracoLoader,
            r = t.extensions[this.name].bufferView,
            o = t.extensions[this.name].attributes,
            s = {},
            a = {},
            c = {};
          for (var l in o) {
            var u = O[l] || l.toLowerCase();
            s[u] = o[l];
          }
          for (l in t.attributes) {
            u = O[l] || l.toLowerCase();
            if (void 0 !== o[l]) {
              var h = n.accessors[t.attributes[l]],
                p = A[h.componentType];
              (c[u] = p), (a[u] = !0 === h.normalized);
            }
          }
          return e.getDependency("bufferView", r).then(function (t) {
            return new Promise(function (e) {
              i.decodeDracoFile(
                t,
                function (t) {
                  for (var n in t.attributes) {
                    var i = t.attributes[n],
                      r = a[n];
                    void 0 !== r && (i.normalized = r);
                  }
                  e(t);
                },
                s,
                c
              );
            });
          });
        }),
          (f.prototype.extendTexture = function (t, e) {
            return (
              (t = t.clone()),
              void 0 !== e.offset && t.offset.fromArray(e.offset),
              void 0 !== e.rotation && (t.rotation = e.rotation),
              void 0 !== e.scale && t.repeat.fromArray(e.scale),
              void 0 !== e.texCoord &&
                console.warn(
                  'THREE.GLTFLoader: Custom UV sets in "' +
                    this.name +
                    '" extension not yet supported.'
                ),
              (t.needsUpdate = !0),
              t
            );
          }),
          (m.prototype = Object.create(Rs.prototype)),
          (m.prototype.constructor = m),
          (m.prototype.copy = function (t) {
            return (
              Rs.prototype.copy.call(this, t),
              (this.specularMap = t.specularMap),
              this.specular.copy(t.specular),
              (this.glossinessMap = t.glossinessMap),
              (this.glossiness = t.glossiness),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this
            );
          }),
          (y.prototype = Object.create(Bs.prototype)),
          (y.prototype.constructor = y),
          (y.prototype.copySampleValue_ = function (t) {
            for (
              var e = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = t * i * 3 + i,
                o = 0;
              o !== i;
              o++
            )
              e[o] = n[r + o];
            return e;
          }),
          (y.prototype.beforeStart_ = y.prototype.copySampleValue_),
          (y.prototype.afterEnd_ = y.prototype.copySampleValue_),
          (y.prototype.interpolate_ = function (t, e, n, i) {
            for (
              var r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = 2 * s,
                c = 3 * s,
                l = i - e,
                u = (n - e) / l,
                h = u * u,
                p = h * u,
                d = t * c,
                f = d - c,
                m = -2 * p + 3 * h,
                g = p - h,
                v = 1 - m,
                y = g - h + u,
                x = 0;
              x !== s;
              x++
            ) {
              var b = o[f + x + s],
                w = o[f + x + a] * l,
                _ = o[d + x + s],
                M = o[d + x] * l;
              r[x] = v * b + y * w + m * _ + g * M;
            }
            return r;
          });
        var x = 0,
          b = 1,
          _ = 2,
          M = 3,
          S = 4,
          T = 5,
          E = 6,
          A = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          L = {
            9728: 1003,
            9729: 1006,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008,
          },
          P = { 33071: 1001, 33648: 1002, 10497: 1e3 },
          C = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
          },
          O = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          I = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          D = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
          N = "OPAQUE",
          k = "MASK",
          U = "BLEND",
          z = { "image/png": 1023, "image/jpeg": 1022 };
        function B(t, e) {
          return "string" != typeof t || "" === t
            ? ""
            : (/^https?:\/\//i.test(e) &&
                /^\//.test(t) &&
                (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(t) ||
              /^data:.*,.*$/i.test(t) ||
              /^blob:.*$/i.test(t)
                ? t
                : e + t);
        }
        function F(t, e, n) {
          for (var i in n.extensions)
            void 0 === t[i] &&
              ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
              (e.userData.gltfExtensions[i] = n.extensions[i]));
        }
        function H(t, e) {
          void 0 !== e.extras &&
            ("object" == typeof e.extras
              ? Object.assign(t.userData, e.extras)
              : console.warn(
                  "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                    e.extras
                ));
        }
        function G(t, e) {
          if ((t.updateMorphTargets(), void 0 !== e.weights))
            for (var n = 0, i = e.weights.length; n < i; n++)
              t.morphTargetInfluences[n] = e.weights[n];
          if (e.extras && Array.isArray(e.extras.targetNames)) {
            var r = e.extras.targetNames;
            if (t.morphTargetInfluences.length === r.length) {
              t.morphTargetDictionary = {};
              for (n = 0, i = r.length; n < i; n++)
                t.morphTargetDictionary[r[n]] = n;
            } else
              console.warn(
                "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
              );
          }
        }
        function j(t) {
          for (
            var e = "", n = Object.keys(t).sort(), i = 0, r = n.length;
            i < r;
            i++
          )
            e += n[i] + ":" + t[n[i]] + ";";
          return e;
        }
        function V(t, n) {
          (this.json = t || {}),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = n || {}),
            (this.cache = new e()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            "undefined" != typeof createImageBitmap &&
            !1 === /Firefox/.test(navigator.userAgent)
              ? (this.textureLoader = new oc(this.options.manager))
              : (this.textureLoader = new ua(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            (this.fileLoader = new ra(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        function W(t, e, n) {
          var i = e.attributes,
            r = [];
          function o(e, i) {
            return n.getDependency("accessor", e).then(function (e) {
              t.setAttribute(i, e);
            });
          }
          for (var s in i) {
            var a = O[s] || s.toLowerCase();
            a in t.attributes || r.push(o(i[s], a));
          }
          if (void 0 !== e.indices && !t.index) {
            var c = n.getDependency("accessor", e.indices).then(function (e) {
              t.setIndex(e);
            });
            r.push(c);
          }
          return (
            H(t, e),
            (function (t, e, n) {
              var i = e.attributes,
                r = new ct();
              if (void 0 !== i.POSITION) {
                var o = (d = n.json.accessors[i.POSITION]).min,
                  s = d.max;
                if (void 0 !== o && void 0 !== s) {
                  r.set(new w(o[0], o[1], o[2]), new w(s[0], s[1], s[2]));
                  var a = e.targets;
                  if (void 0 !== a) {
                    for (
                      var c = new w(), l = new w(), u = 0, h = a.length;
                      u < h;
                      u++
                    ) {
                      var p = a[u];
                      if (void 0 !== p.POSITION) {
                        var d;
                        (o = (d = n.json.accessors[p.POSITION]).min),
                          (s = d.max);
                        void 0 !== o && void 0 !== s
                          ? (l.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                            l.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                            l.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                            c.max(l))
                          : console.warn(
                              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                            );
                      }
                    }
                    r.expandByVector(c);
                  }
                  t.boundingBox = r;
                  var f = new ht();
                  r.getCenter(f.center),
                    (f.radius = r.min.distanceTo(r.max) / 2),
                    (t.boundingSphere = f);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            })(t, e, n),
            Promise.all(r).then(function () {
              return void 0 !== e.targets
                ? (function (t, e, n) {
                    for (var i = !1, r = !1, o = 0, s = e.length; o < s; o++) {
                      if (
                        (void 0 !== (l = e[o]).POSITION && (i = !0),
                        void 0 !== l.NORMAL && (r = !0),
                        i && r)
                      )
                        break;
                    }
                    if (!i && !r) return Promise.resolve(t);
                    var a = [],
                      c = [];
                    for (o = 0, s = e.length; o < s; o++) {
                      var l = e[o];
                      if (i) {
                        var u =
                          void 0 !== l.POSITION
                            ? n.getDependency("accessor", l.POSITION)
                            : t.attributes.position;
                        a.push(u);
                      }
                      if (r) {
                        u =
                          void 0 !== l.NORMAL
                            ? n.getDependency("accessor", l.NORMAL)
                            : t.attributes.normal;
                        c.push(u);
                      }
                    }
                    return Promise.all([Promise.all(a), Promise.all(c)]).then(
                      function (e) {
                        var n = e[0],
                          o = e[1];
                        return (
                          i && (t.morphAttributes.position = n),
                          r && (t.morphAttributes.normal = o),
                          (t.morphTargetsRelative = !0),
                          t
                        );
                      }
                    );
                  })(t, e.targets, n)
                : t;
            })
          );
        }
        function q(t, e) {
          var n = t.getIndex();
          if (null === n) {
            var i = [],
              r = t.getAttribute("position");
            if (void 0 === r)
              return (
                console.error(
                  "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                t
              );
            for (var o = 0; o < r.count; o++) i.push(o);
            t.setIndex(i), (n = t.getIndex());
          }
          var s = n.count - 2,
            a = [];
          if (2 === e)
            for (o = 1; o <= s; o++)
              a.push(n.getX(0)), a.push(n.getX(o)), a.push(n.getX(o + 1));
          else
            for (o = 0; o < s; o++)
              o % 2 == 0
                ? (a.push(n.getX(o)),
                  a.push(n.getX(o + 1)),
                  a.push(n.getX(o + 2)))
                : (a.push(n.getX(o + 2)),
                  a.push(n.getX(o + 1)),
                  a.push(n.getX(o)));
          a.length / 3 !== s &&
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          var c = t.clone();
          return c.setIndex(a), c;
        }
        return (
          (V.prototype.setExtensions = function (t) {
            this.extensions = t;
          }),
          (V.prototype.setPlugins = function (t) {
            this.plugins = t;
          }),
          (V.prototype.parse = function (t, e) {
            var n = this,
              i = this.json,
              r = this.extensions;
            this.cache.removeAll(),
              this.markDefs(),
              Promise.all([
                this.getDependencies("scene"),
                this.getDependencies("animation"),
                this.getDependencies("camera"),
              ])
                .then(function (e) {
                  var o = {
                    scene: e[0][i.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: i.asset,
                    parser: n,
                    userData: {},
                  };
                  F(r, o, i), H(o, i), t(o);
                })
                .catch(e);
          }),
          (V.prototype.markDefs = function () {
            for (
              var t = this.json.nodes || [],
                e = this.json.skins || [],
                n = this.json.meshes || [],
                i = {},
                r = {},
                o = 0,
                s = e.length;
              o < s;
              o++
            )
              for (var a = e[o].joints, c = 0, l = a.length; c < l; c++)
                t[a[c]].isBone = !0;
            for (var u = 0, h = t.length; u < h; u++) {
              var p = t[u];
              void 0 !== p.mesh &&
                (void 0 === i[p.mesh] && (i[p.mesh] = r[p.mesh] = 0),
                i[p.mesh]++,
                void 0 !== p.skin && (n[p.mesh].isSkinnedMesh = !0));
            }
            (this.json.meshReferences = i), (this.json.meshUses = r);
          }),
          (V.prototype._invokeOne = function (t) {
            var e = Object.values(this.plugins);
            e.push(this);
            for (var n = 0; n < e.length; n++) {
              var i = t(e[n]);
              if (i) return i;
            }
          }),
          (V.prototype._invokeAll = function (t) {
            var e = Object.values(this.plugins);
            e.unshift(this);
            for (var n = [], i = 0; i < e.length; i++) n.push(t(e[i]));
            return Promise.all(n);
          }),
          (V.prototype.getDependency = function (t, e) {
            var i = t + ":" + e,
              r = this.cache.get(i);
            if (!r) {
              switch (t) {
                case "scene":
                  r = this.loadScene(e);
                  break;
                case "node":
                  r = this.loadNode(e);
                  break;
                case "mesh":
                  r = this._invokeOne(function (t) {
                    return t.loadMesh && t.loadMesh(e);
                  });
                  break;
                case "accessor":
                  r = this.loadAccessor(e);
                  break;
                case "bufferView":
                  r = this._invokeOne(function (t) {
                    return t.loadBufferView && t.loadBufferView(e);
                  });
                  break;
                case "buffer":
                  r = this.loadBuffer(e);
                  break;
                case "material":
                  r = this._invokeOne(function (t) {
                    return t.loadMaterial && t.loadMaterial(e);
                  });
                  break;
                case "texture":
                  r = this.loadTexture(e);
                  break;
                case "skin":
                  r = this.loadSkin(e);
                  break;
                case "animation":
                  r = this.loadAnimation(e);
                  break;
                case "camera":
                  r = this.loadCamera(e);
                  break;
                case "light":
                  r = this.extensions[n.KHR_LIGHTS_PUNCTUAL].loadLight(e);
                  break;
                default:
                  throw new Error("Unknown type: " + t);
              }
              this.cache.add(i, r);
            }
            return r;
          }),
          (V.prototype.getDependencies = function (t) {
            var e = this.cache.get(t);
            if (!e) {
              var n = this,
                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
              (e = Promise.all(
                i.map(function (e, i) {
                  return n.getDependency(t, i);
                })
              )),
                this.cache.add(t, e);
            }
            return e;
          }),
          (V.prototype.loadBuffer = function (t) {
            var e = this.json.buffers[t],
              i = this.fileLoader;
            if (e.type && "arraybuffer" !== e.type)
              throw new Error(
                "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
              );
            if (void 0 === e.uri && 0 === t)
              return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
            var r = this.options;
            return new Promise(function (t, n) {
              i.load(B(e.uri, r.path), t, void 0, function () {
                n(
                  new Error(
                    'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
                  )
                );
              });
            });
          }),
          (V.prototype.loadBufferView = function (t) {
            var e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then(function (t) {
              var n = e.byteLength || 0,
                i = e.byteOffset || 0;
              return t.slice(i, i + n);
            });
          }),
          (V.prototype.loadAccessor = function (t) {
            var e = this,
              n = this.json,
              i = this.json.accessors[t];
            if (void 0 === i.bufferView && void 0 === i.sparse)
              return Promise.resolve(null);
            var r = [];
            return (
              void 0 !== i.bufferView
                ? r.push(this.getDependency("bufferView", i.bufferView))
                : r.push(null),
              void 0 !== i.sparse &&
                (r.push(
                  this.getDependency("bufferView", i.sparse.indices.bufferView)
                ),
                r.push(
                  this.getDependency("bufferView", i.sparse.values.bufferView)
                )),
              Promise.all(r).then(function (t) {
                var r,
                  o = t[0],
                  s = C[i.type],
                  a = A[i.componentType],
                  c = a.BYTES_PER_ELEMENT,
                  l = c * s,
                  u = i.byteOffset || 0,
                  h =
                    void 0 !== i.bufferView
                      ? n.bufferViews[i.bufferView].byteStride
                      : void 0,
                  p = !0 === i.normalized;
                if (h && h !== l) {
                  var d = Math.floor(u / h),
                    f =
                      "InterleavedBuffer:" +
                      i.bufferView +
                      ":" +
                      i.componentType +
                      ":" +
                      d +
                      ":" +
                      i.count,
                    m = e.cache.get(f);
                  m ||
                    ((m = new ur(new a(o, d * h, (i.count * h) / c), h / c)),
                    e.cache.add(f, m)),
                    (r = new pr(m, s, (u % h) / c, p));
                } else r = new Yt(null === o ? new a(i.count * s) : new a(o, u, i.count * s), s, p);
                if (void 0 !== i.sparse) {
                  var g = C.SCALAR,
                    v = A[i.sparse.indices.componentType],
                    y = i.sparse.indices.byteOffset || 0,
                    x = i.sparse.values.byteOffset || 0,
                    b = new v(t[1], y, i.sparse.count * g),
                    w = new a(t[2], x, i.sparse.count * s);
                  null !== o &&
                    (r = new Yt(r.array.slice(), r.itemSize, r.normalized));
                  for (var _ = 0, M = b.length; _ < M; _++) {
                    var S = b[_];
                    if (
                      (r.setX(S, w[_ * s]),
                      s >= 2 && r.setY(S, w[_ * s + 1]),
                      s >= 3 && r.setZ(S, w[_ * s + 2]),
                      s >= 4 && r.setW(S, w[_ * s + 3]),
                      s >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return r;
              })
            );
          }),
          (V.prototype.loadTexture = function (t) {
            var e,
              i = this,
              r = this.json,
              o = this.options,
              s = this.textureLoader,
              a = self.URL || self.webkitURL,
              c = r.textures[t],
              l = c.extensions || {},
              u = (e = l[n.MSFT_TEXTURE_DDS]
                ? r.images[l[n.MSFT_TEXTURE_DDS].source]
                : r.images[c.source]).uri,
              h = !1;
            return (
              void 0 !== e.bufferView &&
                (u = i
                  .getDependency("bufferView", e.bufferView)
                  .then(function (t) {
                    h = !0;
                    var n = new Blob([t], { type: e.mimeType });
                    return (u = a.createObjectURL(n));
                  })),
              Promise.resolve(u)
                .then(function (t) {
                  var e = o.manager.getHandler(t);
                  return (
                    e ||
                      (e = l[n.MSFT_TEXTURE_DDS]
                        ? i.extensions[n.MSFT_TEXTURE_DDS].ddsLoader
                        : s),
                    new Promise(function (n, i) {
                      var r = n;
                      !0 === e.isImageBitmapLoader &&
                        (r = function (t) {
                          n(new co(t));
                        }),
                        e.load(B(t, o.path), r, void 0, i);
                    })
                  );
                })
                .then(function (n) {
                  !0 === h && a.revokeObjectURL(u),
                    (n.flipY = !1),
                    c.name && (n.name = c.name),
                    e.mimeType in z && (n.format = z[e.mimeType]);
                  var o = (r.samplers || {})[c.sampler] || {};
                  return (
                    (n.magFilter = L[o.magFilter] || 1006),
                    (n.minFilter = L[o.minFilter] || 1008),
                    (n.wrapS = P[o.wrapS] || 1e3),
                    (n.wrapT = P[o.wrapT] || 1e3),
                    i.associations.set(n, { type: "textures", index: t }),
                    n
                  );
                })
            );
          }),
          (V.prototype.assignTexture = function (t, e, i) {
            var r = this;
            return this.getDependency("texture", i.index).then(function (o) {
              if (!o.isCompressedTexture)
                switch (e) {
                  case "aoMap":
                  case "emissiveMap":
                  case "metalnessMap":
                  case "normalMap":
                  case "roughnessMap":
                    o.format = 1022;
                }
              if (
                (void 0 === i.texCoord ||
                  0 == i.texCoord ||
                  ("aoMap" === e && 1 == i.texCoord) ||
                  console.warn(
                    "THREE.GLTFLoader: Custom UV set " +
                      i.texCoord +
                      " for texture " +
                      e +
                      " not yet supported."
                  ),
                r.extensions[n.KHR_TEXTURE_TRANSFORM])
              ) {
                var s =
                  void 0 !== i.extensions
                    ? i.extensions[n.KHR_TEXTURE_TRANSFORM]
                    : void 0;
                if (s) {
                  var a = r.associations.get(o);
                  (o = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(
                    o,
                    s
                  )),
                    r.associations.set(o, a);
                }
              }
              t[e] = o;
            });
          }),
          (V.prototype.assignFinalMaterial = function (t) {
            var e = t.geometry,
              n = t.material,
              i = void 0 !== e.attributes.tangent,
              r = void 0 !== e.attributes.color,
              o = void 0 === e.attributes.normal,
              s = !0 === t.isSkinnedMesh,
              a = Object.keys(e.morphAttributes).length > 0,
              c = a && void 0 !== e.morphAttributes.normal;
            if (t.isPoints) {
              var l = "PointsMaterial:" + n.uuid,
                u = this.cache.get(l);
              u ||
                ((u = new Qr()),
                Vt.prototype.copy.call(u, n),
                u.color.copy(n.color),
                (u.map = n.map),
                (u.sizeAttenuation = !1),
                this.cache.add(l, u)),
                (n = u);
            } else if (t.isLine) {
              l = "LineBasicMaterial:" + n.uuid;
              var h = this.cache.get(l);
              h ||
                ((h = new Gr()),
                Vt.prototype.copy.call(h, n),
                h.color.copy(n.color),
                this.cache.add(l, h)),
                (n = h);
            }
            if (i || r || o || s || a) {
              l = "ClonedMaterial:" + n.uuid + ":";
              n.isGLTFSpecularGlossinessMaterial &&
                (l += "specular-glossiness:"),
                s && (l += "skinning:"),
                i && (l += "vertex-tangents:"),
                r && (l += "vertex-colors:"),
                o && (l += "flat-shading:"),
                a && (l += "morph-targets:"),
                c && (l += "morph-normals:");
              var p = this.cache.get(l);
              p ||
                ((p = n.clone()),
                s && (p.skinning = !0),
                i && (p.vertexTangents = !0),
                r && (p.vertexColors = !0),
                o && (p.flatShading = !0),
                a && (p.morphTargets = !0),
                c && (p.morphNormals = !0),
                this.cache.add(l, p),
                this.associations.set(p, this.associations.get(n))),
                (n = p);
            }
            n.aoMap &&
              void 0 === e.attributes.uv2 &&
              void 0 !== e.attributes.uv &&
              e.setAttribute("uv2", e.attributes.uv),
              n.normalScale && !i && (n.normalScale.y = -n.normalScale.y),
              n.clearcoatNormalScale &&
                !i &&
                (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y),
              (t.material = n);
          }),
          (V.prototype.getMaterialType = function () {
            return Rs;
          }),
          (V.prototype.loadMaterial = function (t) {
            var e,
              i = this,
              r = this.json,
              o = this.extensions,
              s = r.materials[t],
              a = {},
              c = s.extensions || {},
              u = [];
            if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              var h = o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              (e = h.getMaterialType()), u.push(h.extendParams(a, s, i));
            } else if (c[n.KHR_MATERIALS_UNLIT]) {
              var p = o[n.KHR_MATERIALS_UNLIT];
              (e = p.getMaterialType()), u.push(p.extendParams(a, s, i));
            } else {
              var d = s.pbrMetallicRoughness || {};
              if (
                ((a.color = new zt(1, 1, 1)),
                (a.opacity = 1),
                Array.isArray(d.baseColorFactor))
              ) {
                var f = d.baseColorFactor;
                a.color.fromArray(f), (a.opacity = f[3]);
              }
              void 0 !== d.baseColorTexture &&
                u.push(i.assignTexture(a, "map", d.baseColorTexture)),
                (a.metalness =
                  void 0 !== d.metallicFactor ? d.metallicFactor : 1),
                (a.roughness =
                  void 0 !== d.roughnessFactor ? d.roughnessFactor : 1),
                void 0 !== d.metallicRoughnessTexture &&
                  (u.push(
                    i.assignTexture(
                      a,
                      "metalnessMap",
                      d.metallicRoughnessTexture
                    )
                  ),
                  u.push(
                    i.assignTexture(
                      a,
                      "roughnessMap",
                      d.metallicRoughnessTexture
                    )
                  )),
                (e = this._invokeOne(function (e) {
                  return e.getMaterialType && e.getMaterialType(t);
                })),
                u.push(
                  this._invokeAll(function (e) {
                    return (
                      e.extendMaterialParams && e.extendMaterialParams(t, a)
                    );
                  })
                );
            }
            !0 === s.doubleSided && (a.side = 2);
            var g = s.alphaMode || N;
            return (
              g === U
                ? ((a.transparent = !0), (a.depthWrite = !1))
                : ((a.transparent = !1),
                  g === k &&
                    (a.alphaTest =
                      void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
              void 0 !== s.normalTexture &&
                e !== Wt &&
                (u.push(i.assignTexture(a, "normalMap", s.normalTexture)),
                (a.normalScale = new l(1, 1)),
                void 0 !== s.normalTexture.scale &&
                  a.normalScale.set(
                    s.normalTexture.scale,
                    s.normalTexture.scale
                  )),
              void 0 !== s.occlusionTexture &&
                e !== Wt &&
                (u.push(i.assignTexture(a, "aoMap", s.occlusionTexture)),
                void 0 !== s.occlusionTexture.strength &&
                  (a.aoMapIntensity = s.occlusionTexture.strength)),
              void 0 !== s.emissiveFactor &&
                e !== Wt &&
                (a.emissive = new zt().fromArray(s.emissiveFactor)),
              void 0 !== s.emissiveTexture &&
                e !== Wt &&
                u.push(i.assignTexture(a, "emissiveMap", s.emissiveTexture)),
              Promise.all(u).then(function () {
                var r;
                return (
                  (r =
                    e === m
                      ? o[
                          n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                        ].createMaterial(a)
                      : new e(a)),
                  s.name && (r.name = s.name),
                  r.map && (r.map.encoding = 3001),
                  r.emissiveMap && (r.emissiveMap.encoding = 3001),
                  H(r, s),
                  i.associations.set(r, { type: "materials", index: t }),
                  s.extensions && F(o, r, s),
                  r
                );
              })
            );
          }),
          (V.prototype.loadGeometries = function (t) {
            var e = this,
              i = this.extensions,
              r = this.primitiveCache;
            function o(t) {
              return i[n.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(t, e)
                .then(function (n) {
                  return W(n, t, e);
                });
            }
            for (var s, a, c = [], l = 0, u = t.length; l < u; l++) {
              var h,
                p = t[l],
                d =
                  ((a = void 0),
                  (a =
                    (s = p).extensions &&
                    s.extensions[n.KHR_DRACO_MESH_COMPRESSION])
                    ? "draco:" +
                      a.bufferView +
                      ":" +
                      a.indices +
                      ":" +
                      j(a.attributes)
                    : s.indices + ":" + j(s.attributes) + ":" + s.mode),
                f = r[d];
              if (f) c.push(f.promise);
              else
                (h =
                  p.extensions && p.extensions[n.KHR_DRACO_MESH_COMPRESSION]
                    ? o(p)
                    : W(new de(), p, e)),
                  (r[d] = { primitive: p, promise: h }),
                  c.push(h);
            }
            return Promise.all(c);
          }),
          (V.prototype.loadMesh = function (t) {
            for (
              var e,
                n = this,
                i = this.json.meshes[t],
                r = i.primitives,
                o = [],
                s = 0,
                a = r.length;
              s < a;
              s++
            ) {
              var c =
                void 0 === r[s].material
                  ? (void 0 === (e = this.cache).DefaultMaterial &&
                      (e.DefaultMaterial = new Rs({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0,
                      })),
                    e.DefaultMaterial)
                  : this.getDependency("material", r[s].material);
              o.push(c);
            }
            return (
              o.push(n.loadGeometries(r)),
              Promise.all(o).then(function (e) {
                for (
                  var o = e.slice(0, e.length - 1),
                    s = e[e.length - 1],
                    a = [],
                    c = 0,
                    l = s.length;
                  c < l;
                  c++
                ) {
                  var u,
                    h = s[c],
                    p = r[c],
                    d = o[c];
                  if (
                    p.mode === S ||
                    p.mode === T ||
                    p.mode === E ||
                    void 0 === p.mode
                  )
                    !0 !==
                      (u = !0 === i.isSkinnedMesh ? new Or(h, d) : new Ce(h, d))
                        .isSkinnedMesh ||
                      u.geometry.attributes.skinWeight.normalized ||
                      u.normalizeSkinWeights(),
                      p.mode === T
                        ? (u.geometry = q(u.geometry, 1))
                        : p.mode === E && (u.geometry = q(u.geometry, 2));
                  else if (p.mode === b) u = new Kr(h, d);
                  else if (p.mode === M) u = new Yr(h, d);
                  else if (p.mode === _) u = new $r(h, d);
                  else {
                    if (p.mode !== x)
                      throw new Error(
                        "THREE.GLTFLoader: Primitive mode unsupported: " +
                          p.mode
                      );
                    u = new ro(h, d);
                  }
                  Object.keys(u.geometry.morphAttributes).length > 0 && G(u, i),
                    (u.name = i.name || "mesh_" + t),
                    s.length > 1 && (u.name += "_" + c),
                    H(u, i),
                    n.assignFinalMaterial(u),
                    a.push(u);
                }
                if (1 === a.length) return a[0];
                var f = new nr();
                for (c = 0, l = a.length; c < l; c++) f.add(a[c]);
                return f;
              })
            );
          }),
          (V.prototype.loadCamera = function (t) {
            var e,
              n = this.json.cameras[t],
              i = n[n.type];
            if (i)
              return (
                "perspective" === n.type
                  ? (e = new We(
                      c.radToDeg(i.yfov),
                      i.aspectRatio || 1,
                      i.znear || 1,
                      i.zfar || 2e6
                    ))
                  : "orthographic" === n.type &&
                    (e = new Ha(
                      -i.xmag,
                      i.xmag,
                      i.ymag,
                      -i.ymag,
                      i.znear,
                      i.zfar
                    )),
                n.name && (e.name = n.name),
                H(e, n),
                Promise.resolve(e)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }),
          (V.prototype.loadSkin = function (t) {
            var e = this.json.skins[t],
              n = { joints: e.joints };
            return void 0 === e.inverseBindMatrices
              ? Promise.resolve(n)
              : this.getDependency("accessor", e.inverseBindMatrices).then(
                  function (t) {
                    return (n.inverseBindMatrices = t), n;
                  }
                );
          }),
          (V.prototype.loadAnimation = function (t) {
            for (
              var e = this.json.animations[t],
                n = [],
                i = [],
                r = [],
                o = [],
                s = [],
                a = 0,
                c = e.channels.length;
              a < c;
              a++
            ) {
              var l = e.channels[a],
                u = e.samplers[l.sampler],
                h = l.target,
                p = void 0 !== h.node ? h.node : h.id,
                d = void 0 !== e.parameters ? e.parameters[u.input] : u.input,
                f = void 0 !== e.parameters ? e.parameters[u.output] : u.output;
              n.push(this.getDependency("node", p)),
                i.push(this.getDependency("accessor", d)),
                r.push(this.getDependency("accessor", f)),
                o.push(u),
                s.push(h);
            }
            return Promise.all([
              Promise.all(n),
              Promise.all(i),
              Promise.all(r),
              Promise.all(o),
              Promise.all(s),
            ]).then(function (n) {
              for (
                var i = n[0],
                  r = n[1],
                  o = n[2],
                  s = n[3],
                  a = n[4],
                  c = [],
                  l = 0,
                  u = i.length;
                l < u;
                l++
              ) {
                var h = i[l],
                  p = r[l],
                  d = o[l],
                  f = s[l],
                  m = a[l];
                if (void 0 !== h) {
                  var g;
                  switch (
                    (h.updateMatrix(), (h.matrixAutoUpdate = !0), I[m.path])
                  ) {
                    case I.weights:
                      g = qs;
                      break;
                    case I.rotation:
                      g = Ys;
                      break;
                    case I.position:
                    case I.scale:
                    default:
                      g = Js;
                  }
                  var v = h.name ? h.name : h.uuid,
                    x = void 0 !== f.interpolation ? D[f.interpolation] : 2301,
                    b = [];
                  I[m.path] === I.weights
                    ? h.traverse(function (t) {
                        !0 === t.isMesh &&
                          t.morphTargetInfluences &&
                          b.push(t.name ? t.name : t.uuid);
                      })
                    : b.push(v);
                  var w = d.array;
                  if (d.normalized) {
                    var _;
                    if (w.constructor === Int8Array) _ = 1 / 127;
                    else if (w.constructor === Uint8Array) _ = 1 / 255;
                    else if (w.constructor == Int16Array) _ = 1 / 32767;
                    else {
                      if (w.constructor !== Uint16Array)
                        throw new Error(
                          "THREE.GLTFLoader: Unsupported output accessor component type."
                        );
                      _ = 1 / 65535;
                    }
                    for (
                      var M = new Float32Array(w.length), S = 0, T = w.length;
                      S < T;
                      S++
                    )
                      M[S] = w[S] * _;
                    w = M;
                  }
                  for (S = 0, T = b.length; S < T; S++) {
                    var E = new g(b[S] + "." + I[m.path], p.array, w, x);
                    "CUBICSPLINE" === f.interpolation &&
                      ((E.createInterpolant = function (t) {
                        return new y(
                          this.times,
                          this.values,
                          this.getValueSize() / 3,
                          t
                        );
                      }),
                      (E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                        !0)),
                      c.push(E);
                  }
                }
              }
              return new Ks(e.name ? e.name : "animation_" + t, void 0, c);
            });
          }),
          (V.prototype.loadNode = function (t) {
            var e,
              i = this.json,
              r = this.extensions,
              o = this,
              s = i.meshReferences,
              a = i.meshUses,
              c = i.nodes[t];
            return ((e = []),
            void 0 !== c.mesh &&
              e.push(
                o.getDependency("mesh", c.mesh).then(function (t) {
                  var e;
                  if (s[c.mesh] > 1) {
                    var n = a[c.mesh]++;
                    (e = t.clone()).name += "_instance_" + n;
                  } else e = t;
                  return (
                    void 0 !== c.weights &&
                      e.traverse(function (t) {
                        if (t.isMesh)
                          for (var e = 0, n = c.weights.length; e < n; e++)
                            t.morphTargetInfluences[e] = c.weights[e];
                      }),
                    e
                  );
                })
              ),
            void 0 !== c.camera && e.push(o.getDependency("camera", c.camera)),
            c.extensions &&
              c.extensions[n.KHR_LIGHTS_PUNCTUAL] &&
              void 0 !== c.extensions[n.KHR_LIGHTS_PUNCTUAL].light &&
              e.push(
                o.getDependency(
                  "light",
                  c.extensions[n.KHR_LIGHTS_PUNCTUAL].light
                )
              ),
            Promise.all(e)).then(function (e) {
              var n;
              if (
                (n =
                  !0 === c.isBone
                    ? new kr()
                    : e.length > 1
                    ? new nr()
                    : 1 === e.length
                    ? e[0]
                    : new X()) !== e[0]
              )
                for (var i = 0, s = e.length; i < s; i++) n.add(e[i]);
              if (
                (c.name &&
                  ((n.userData.name = c.name),
                  (n.name = Fc.sanitizeNodeName(c.name))),
                H(n, c),
                c.extensions && F(r, n, c),
                void 0 !== c.matrix)
              ) {
                var a = new R();
                a.fromArray(c.matrix), n.applyMatrix4(a);
              } else void 0 !== c.translation && n.position.fromArray(c.translation), void 0 !== c.rotation && n.quaternion.fromArray(c.rotation), void 0 !== c.scale && n.scale.fromArray(c.scale);
              return o.associations.set(n, { type: "nodes", index: t }), n;
            });
          }),
          (V.prototype.loadScene = (function () {
            function t(e, n, i, r) {
              var o = i.nodes[e];
              return r
                .getDependency("node", e)
                .then(function (t) {
                  return void 0 === o.skin
                    ? t
                    : r
                        .getDependency("skin", o.skin)
                        .then(function (t) {
                          for (
                            var n = [], i = 0, o = (e = t).joints.length;
                            i < o;
                            i++
                          )
                            n.push(r.getDependency("node", e.joints[i]));
                          return Promise.all(n);
                        })
                        .then(function (n) {
                          return (
                            t.traverse(function (t) {
                              if (t.isMesh) {
                                for (
                                  var i = [], r = [], o = 0, s = n.length;
                                  o < s;
                                  o++
                                ) {
                                  var a = n[o];
                                  if (a) {
                                    i.push(a);
                                    var c = new R();
                                    void 0 !== e.inverseBindMatrices &&
                                      c.fromArray(
                                        e.inverseBindMatrices.array,
                                        16 * o
                                      ),
                                      r.push(c);
                                  } else
                                    console.warn(
                                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                                      e.joints[o]
                                    );
                                }
                                t.bind(new Nr(i, r), t.matrixWorld);
                              }
                            }),
                            t
                          );
                        });
                  var e;
                })
                .then(function (e) {
                  n.add(e);
                  var s = [];
                  if (o.children)
                    for (var a = o.children, c = 0, l = a.length; c < l; c++) {
                      var u = a[c];
                      s.push(t(u, e, i, r));
                    }
                  return Promise.all(s);
                });
            }
            return function (e) {
              var n = this.json,
                i = this.extensions,
                r = this.json.scenes[e],
                o = new nr();
              r.name && (o.name = r.name), H(o, r), r.extensions && F(i, o, r);
              for (
                var s = r.nodes || [], a = [], c = 0, l = s.length;
                c < l;
                c++
              )
                a.push(t(s[c], o, n, this));
              return Promise.all(a).then(function () {
                return o;
              });
            };
          })()),
          t
        );
      })();
    function eu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var nu = (function () {
      function t() {
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, t),
          (this.type = "gltf"),
          (this.loader = new tu());
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "resolve",
            value: function (t) {
              var e = this;
              return new Promise(function (n) {
                e.loader.load(t.url, function (e) {
                  n(Object.assign(t, { gltf: e }));
                });
              });
            },
          },
          {
            key: "get",
            value: function (t) {
              return t.gltf;
            },
          },
        ]) && eu(e.prototype, n),
        i && eu(e, i),
        t
      );
    })();
    function iu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var ru = (function () {
        function t(e) {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            (this.type = "texture"),
            (this.renderer = e),
            (this.loader = new ua());
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "resolve",
              value: function (t) {
                var e = this;
                return new Promise(function (n, i) {
                  e.loader.load(
                    t.url,
                    function (i) {
                      e.renderer &&
                        (t.linear && (i.minFilter = i.magFilter = 1006),
                        t.flipY && (i.flipY = !1),
                        e.renderer.initTexture(i)),
                        n(Object.assign(t, { texture: i }));
                    },
                    function () {},
                    function (t) {
                      return i(t);
                    }
                  );
                });
              },
            },
            {
              key: "get",
              value: function (t) {
                return t.texture;
              },
            },
          ]) && iu(e.prototype, n),
          i && iu(e, i),
          t
        );
      })(),
      ou = function (t) {
        aa.call(this, t), (this.type = 1009);
      };
    ou.prototype = Object.assign(Object.create(aa.prototype), {
      constructor: ou,
      parse: function (t) {
        var e = function (t, e) {
            switch (t) {
              case 1:
                console.error("RGBELoader Read Error: " + (e || ""));
                break;
              case 2:
                console.error("RGBELoader Write Error: " + (e || ""));
                break;
              case 3:
                console.error("RGBELoader Bad File Format: " + (e || ""));
                break;
              default:
              case 4:
                console.error("RGBELoader: Error: " + (e || ""));
            }
            return -1;
          },
          n = function (t, e, n) {
            e = e || 1024;
            for (
              var i = t.pos,
                r = -1,
                o = 0,
                s = "",
                a = String.fromCharCode.apply(
                  null,
                  new Uint16Array(t.subarray(i, i + 128))
                );
              0 > (r = a.indexOf("\n")) && o < e && i < t.byteLength;

            )
              (s += a),
                (o += a.length),
                (i += 128),
                (a += String.fromCharCode.apply(
                  null,
                  new Uint16Array(t.subarray(i, i + 128))
                ));
            return (
              -1 < r && (!1 !== n && (t.pos += o + r + 1), s + a.slice(0, r))
            );
          },
          i = (function () {
            var t = new Float32Array(1),
              e = new Int32Array(t.buffer);
            function n(n) {
              t[0] = n;
              var i = e[0],
                r = (i >> 16) & 32768,
                o = (i >> 12) & 2047,
                s = (i >> 23) & 255;
              return s < 103
                ? r
                : s > 142
                ? ((r |= 31744), (r |= (255 == s ? 0 : 1) && 8388607 & i))
                : s < 113
                ? (r |= ((o |= 2048) >> (114 - s)) + ((o >> (113 - s)) & 1))
                : ((r |= ((s - 112) << 10) | (o >> 1)), (r += 1 & o));
            }
            return function (t, e, i, r) {
              var o = t[e + 3],
                s = Math.pow(2, o - 128) / 255;
              (i[r + 0] = n(t[e + 0] * s)),
                (i[r + 1] = n(t[e + 1] * s)),
                (i[r + 2] = n(t[e + 2] * s));
            };
          })(),
          r = new Uint8Array(t);
        r.pos = 0;
        var o,
          s,
          a,
          c,
          l,
          u,
          h = (function (t) {
            var i,
              r,
              o = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
              s = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
              a = /^\s*FORMAT=(\S+)\s*$/,
              c = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
              l = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0,
              };
            if (t.pos >= t.byteLength || !(i = n(t)))
              return e(1, "no header found");
            if (!(r = i.match(/^#\?(\S+)$/))) return e(3, "bad initial token");
            for (
              l.valid |= 1, l.programtype = r[1], l.string += i + "\n";
              !1 !== (i = n(t));

            )
              if (((l.string += i + "\n"), "#" !== i.charAt(0))) {
                if (
                  ((r = i.match(o)) && (l.gamma = parseFloat(r[1], 10)),
                  (r = i.match(s)) && (l.exposure = parseFloat(r[1], 10)),
                  (r = i.match(a)) && ((l.valid |= 2), (l.format = r[1])),
                  (r = i.match(c)) &&
                    ((l.valid |= 4),
                    (l.height = parseInt(r[1], 10)),
                    (l.width = parseInt(r[2], 10))),
                  2 & l.valid && 4 & l.valid)
                )
                  break;
              } else l.comments += i + "\n";
            return 2 & l.valid
              ? 4 & l.valid
                ? l
                : e(3, "missing image size specifier")
              : e(3, "missing format specifier");
          })(r);
        if (-1 !== h) {
          var p = h.width,
            d = h.height,
            f = (function (t, n, i) {
              var r,
                o,
                s,
                a,
                c,
                l,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                v = n,
                y = i;
              if (v < 8 || v > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2])
                return new Uint8Array(t);
              if (v !== ((t[2] << 8) | t[3]))
                return e(3, "wrong scanline width");
              if (!(r = new Uint8Array(4 * n * i)).length)
                return e(4, "unable to allocate buffer space");
              for (
                o = 0,
                  s = 0,
                  h = 4 * v,
                  g = new Uint8Array(4),
                  l = new Uint8Array(h);
                y > 0 && s < t.byteLength;

              ) {
                if (s + 4 > t.byteLength) return e(1);
                if (
                  ((g[0] = t[s++]),
                  (g[1] = t[s++]),
                  (g[2] = t[s++]),
                  (g[3] = t[s++]),
                  2 != g[0] || 2 != g[1] || ((g[2] << 8) | g[3]) != v)
                )
                  return e(3, "bad rgbe scanline format");
                for (u = 0; u < h && s < t.byteLength; ) {
                  if (
                    ((m = (a = t[s++]) > 128) && (a -= 128),
                    0 === a || u + a > h)
                  )
                    return e(3, "bad scanline data");
                  if (m) for (c = t[s++], p = 0; p < a; p++) l[u++] = c;
                  else l.set(t.subarray(s, s + a), u), (u += a), (s += a);
                }
                for (d = v, p = 0; p < d; p++)
                  (f = 0),
                    (r[o] = l[p + f]),
                    (f += v),
                    (r[o + 1] = l[p + f]),
                    (f += v),
                    (r[o + 2] = l[p + f]),
                    (f += v),
                    (r[o + 3] = l[p + f]),
                    (o += 4);
                y--;
              }
              return r;
            })(r.subarray(r.pos), p, d);
          if (-1 !== f) {
            switch (this.type) {
              case 1009:
                var m = f,
                  g = 1023,
                  v = 1009;
                break;
              case 1015:
                for (
                  var y = (f.length / 4) * 3, x = new Float32Array(y), b = 0;
                  b < y;
                  b++
                )
                  (a = x),
                    (c = 3 * b),
                    (l = void 0),
                    (u = void 0),
                    (l = (o = f)[(s = 4 * b) + 3]),
                    (u = Math.pow(2, l - 128) / 255),
                    (a[c + 0] = o[s + 0] * u),
                    (a[c + 1] = o[s + 1] * u),
                    (a[c + 2] = o[s + 2] * u);
                (m = x), (g = 1022), (v = 1015);
                break;
              case 1016:
                y = (f.length / 4) * 3;
                var w = new Uint16Array(y);
                for (b = 0; b < y; b++) i(f, 4 * b, w, 3 * b);
                (m = w), (g = 1022), (v = 1016);
                break;
              default:
                console.error(
                  "THREE.RGBELoader: unsupported type: ",
                  this.type
                );
            }
            return {
              width: p,
              height: d,
              data: m,
              header: h.string,
              gamma: h.gamma,
              exposure: h.exposure,
              format: g,
              type: v,
            };
          }
        }
        return null;
      },
      setDataType: function (t) {
        return (this.type = t), this;
      },
      load: function (t, e, n, i) {
        return aa.prototype.load.call(
          this,
          t,
          function (t, n) {
            switch (t.type) {
              case 1009:
                (t.encoding = 3002),
                  (t.minFilter = 1003),
                  (t.magFilter = 1003),
                  (t.generateMipmaps = !1),
                  (t.flipY = !0);
                break;
              case 1015:
              case 1016:
                (t.encoding = 3e3),
                  (t.minFilter = 1006),
                  (t.magFilter = 1006),
                  (t.generateMipmaps = !1),
                  (t.flipY = !0);
            }
            e && e(t, n);
          },
          n,
          i
        );
      },
    });
    if ("maxTouchPoints" in navigator) navigator.maxTouchPoints > 0;
    else if ("msMaxTouchPoints" in navigator) navigator.msMaxTouchPoints > 0;
    else {
      var su = window.matchMedia && matchMedia("(pointer:coarse)");
      if (su && "(pointer:coarse)" === su.media) !!su.matches;
      else if ("orientation" in window) !0;
      else {
        var au = navigator.userAgent;
        /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(au) ||
          /\b(Android|Windows Phone|iPad|iPod)\b/i.test(au);
      }
    }
    var cu = window.innerWidth < 768,
      lu = cu,
      uu = {};
    function hu() {
      return uu;
    }
    function pu(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function du(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (t, e, n) {
      (uu[e] = n), (uu.debug = !0);
    });
    var fu = (function () {
        function t(e) {
          var n =
            !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          pu(this, t),
            (this.type = "rgbe"),
            (this.renderer = e),
            (this.loader = new ou()),
            (this.dataType = n ? (lu ? 1009 : 1015) : 1009),
            this.loader.setDataType(this.dataType);
          var i = hu().type;
          if (i) {
            var r = "";
            switch (i) {
              case "0":
                (this.dataType = 1009), (r = "UnsignedByteType");
                break;
              case "1":
                (this.dataType = 1016), (r = "HalfFloatType");
                break;
              case "2":
                (this.dataType = 1015), (r = "FloatType");
            }
            this.loader.setDataType(this.dataType),
              console.log("force HDR type to", r);
          }
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "resolve",
              value: function (t) {
                var e = this;
                return new Promise(function (n, i) {
                  e.loader.load(
                    t.url,
                    function (i) {
                      (i.minFilter = i.magFilter = 1006),
                        e.renderer &&
                          (t.flipY && (i.flipY = !1),
                          e.renderer.initTexture(i)),
                        n(Object.assign(t, { texture: i }));
                    },
                    function () {},
                    function (t) {
                      return i(t);
                    }
                  );
                });
              },
            },
            {
              key: "get",
              value: function (t) {
                return t.texture;
              },
            },
          ]) && du(e.prototype, n),
          i && du(e, i),
          t
        );
      })(),
      mu = !!hu().png,
      gu = mu ? "png/" : "rgbe/",
      vu = mu ? ".png" : ".hdr",
      yu = mu ? "texture" : "rgbe";
    hu().debug && console.log("Texture Type", yu, vu);
    var xu = [
        { id: "room", url: "scene.glb", type: "gltf", version: 0 },
        {
          id: "RoomTexture",
          url: gu + "Room_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "DeskTableTexture",
          url: gu + "Desk.Table_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "DeskDrawersTexture",
          url: gu + "Desk.Drawers_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "DeskHandlesTexture",
          url: gu + "Desk.Handles_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "ChairPiedTexture",
          url: gu + "Chair.Pied_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "ChairTexture",
          url: gu + "Chair_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "KeyboardTexture",
          url: gu + "Keyboard_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "MoleskineTexture",
          url: gu + "Moleskine_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "MouseTexture",
          url: gu + "Mouse_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "ScreenTexture",
          url: gu + "Screen_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "ScreenFrameTexture",
          url: gu + "Screen.Frame_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
        {
          id: "LampTexture",
          url: gu + "Lamp_baked" + vu,
          flipY: !0,
          type: yu,
          version: 0,
        },
      ],
      bu = Kl();
    function wu(t) {
      return (wu =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function _u(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Mu(t, e) {
      return (Mu =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Su(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Eu(t);
        if (e) {
          var r = Eu(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Tu(this, n);
      };
    }
    function Tu(t, e) {
      return !e || ("object" !== wu(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function Eu(t) {
      return (Eu = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Au = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Mu(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = Su(o);
      function o(t) {
        var e;
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, o),
          t.geometry.computeBoundingBox();
        t.geometry.boundingBox.getSize(new w());
        return (
          ((e = r.call(
            this,
            new Be(0.2, 0.1, 0.2),
            new Wt({
              color: 16711680,
              wireframe: !0,
              transparent: !0,
              opacity: 0,
            })
          )).originalLamp = t.material),
          e.position
            .copy(t.position)
            .add(new w(-0.05, -0.14, -0.1))
            .add(new w(1.09, 1.108, 0.45)),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "mouseOver",
            value: function () {
              (document.body.style.cursor = "pointer"),
                this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this.originalLamp, {
                  duration: 0.5,
                  lightMapIntensity: 2,
                });
            },
          },
          {
            key: "mouseOut",
            value: function () {
              (document.body.style.cursor = "default"),
                this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this.originalLamp, {
                  duration: 0.5,
                  lightMapIntensity: 1,
                });
            },
          },
          {
            key: "click",
            value: function () {
              bu.emit("lamp");
            },
          },
        ]) && _u(e.prototype, n),
        i && _u(e, i),
        o
      );
    })(Ce);
    function Lu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var Ru = (function () {
      function t() {
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, t),
          (this.x = 30),
          (this.y = 0),
          (this.w = 20),
          (this.h = 20),
          (this.isJumping = !1);
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "crouch",
            value: function () {
              this.isJumping ||
                (this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this, { h: 15, w: 25, x: 27.5, duration: 0.2 }, 0),
                this.tl.timeScale(1.5));
            },
          },
          {
            key: "jump",
            value: function (t) {
              if (!this.isJumping) {
                this.tl && this.tl.kill();
                var e = Math.min(t, 800) / 800,
                  n = 0.6 + 0.5 * e,
                  i = 0.5 + 0.5 * e;
                (this.tl = gsap.timeline()),
                  this.tl.set(this, { isJumping: !0 }, 0),
                  this.tl.to(this, { h: 25, w: 15, x: 32.5, duration: 0.4 }, 0),
                  this.tl.to(
                    this,
                    { y: -50 - 150 * e, duration: n, ease: "cubic.out" },
                    0
                  ),
                  this.tl.to(this, { y: 0, duration: i, ease: "cubic.in" }, n),
                  this.tl.set(this, { isJumping: !1 }, n + i),
                  this.tl.to(
                    this,
                    { h: 15, w: 25, x: 27.5, duration: 0.2 },
                    n + i
                  ),
                  this.tl.to(
                    this,
                    { h: 20, w: 20, x: 30, duration: 0.2 },
                    n + i + 0.2
                  ),
                  this.tl.timeScale(1.5);
              }
            },
          },
          {
            key: "reset",
            value: function () {
              this.tl && this.tl.kill(),
                (this.x = 30),
                (this.y = 0),
                (this.w = 20),
                (this.h = 20),
                (this.isJumping = !1);
            },
          },
          {
            key: "draw",
            value: function (t, e) {
              (t.fillStyle = "#ffffff"),
                t.fillRect(this.x, e - this.h + this.y, this.w, this.h),
                (t.fillStyle = "#000000"),
                t.fillRect(this.x, e - this.h + this.y + 4, this.w, 3);
            },
          },
        ]) && Lu(e.prototype, n),
        i && Lu(e, i),
        t
      );
    })();
    function Pu(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function Cu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var Ou = (function () {
      function t() {
        var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 100;
        Pu(this, t),
          (this.spawn = this.spawn.bind(this)),
          (this.startSpawnTimeout = this.startSpawnTimeout.bind(this)),
          (this.start = e),
          (this.collideMin = 0.5 * e),
          (this.x = e),
          (this.y = 0),
          (this.w = 0),
          (this.h = 30),
          (this.alive = !1),
          (this.speed = 0),
          (this.difficulty = 0.1),
          this.startSpawnTimeout();
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "draw",
            value: function (t, e, n) {
              this.alive &&
                ((this.x -= this.speed * n * 0.02),
                (t.fillStyle = "#121212"),
                t.fillRect(this.x, e - this.h + this.y, this.w, this.h));
            },
          },
          {
            key: "die",
            value: function () {
              (this.alive = !1), this.startSpawnTimeout();
            },
          },
          {
            key: "setDifficulty",
            value: function (t) {
              this.difficulty = Math.min(t, 1);
            },
          },
          {
            key: "reset",
            value: function () {
              this.timeout && clearTimeout(this.timeout),
                (this.x = this.start),
                (this.y = 0),
                (this.w = 20),
                (this.h = 30),
                (this.alive = !1),
                (this.speed = 0),
                (this.difficulty = 0.1),
                this.startSpawnTimeout();
            },
          },
          {
            key: "collide",
            value: function (t) {
              return !(
                !this.alive ||
                this.x > this.collideMin ||
                t.x > this.x + this.w ||
                t.x + t.w < this.x ||
                t.y > this.y + this.h ||
                t.y + t.h < this.y
              );
            },
          },
          {
            key: "startSpawnTimeout",
            value: function () {
              var t =
                6e3 * Math.random() * (1 - this.difficulty) +
                1e3 * (1 - this.difficulty);
              this.timeout = setTimeout(this.spawn, t);
            },
          },
          {
            key: "testDie",
            value: function () {
              return !!(this.alive && this.x + this.w < 0) && (this.die(), !0);
            },
          },
          {
            key: "spawn",
            value: function () {
              (this.w = 20),
                (this.h = 20 * Math.random() + 20),
                (this.x = this.start),
                (this.alive = !0),
                (this.speed = 8 * Math.random() * this.difficulty + 4);
            },
          },
        ]) && Cu(e.prototype, n),
        i && Cu(e, i),
        t
      );
    })();
    function Iu(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function Du(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var Nu = ["#334955", "#294251"],
      ku = (function () {
        function t() {
          var e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : 100;
          Iu(this, t),
            (this.spawn = this.spawn.bind(this)),
            (this.start = e),
            (this.x = e),
            (this.y = 0),
            (this.w = 100 * Math.random() + 50),
            (this.h = 200 * Math.random() + 50),
            (this.color = Nu[Math.floor(Math.random() * Nu.length)]),
            (this.alive = !1),
            (this.speed = 2 * Math.random() + 1),
            setTimeout(this.spawn, 1e3 * Math.random() + 200);
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "draw",
              value: function (t, e, n) {
                this.alive &&
                  ((this.x -= this.speed * n * 0.02),
                  (t.fillStyle = this.color),
                  t.fillRect(this.x, e - this.h + this.y, this.w, this.h),
                  this.x + this.w < 0 && this.die());
              },
            },
            {
              key: "die",
              value: function () {
                (this.alive = !1),
                  setTimeout(this.spawn, 1e3 * Math.random() + 200);
              },
            },
            {
              key: "spawn",
              value: function () {
                (this.x = this.start),
                  (this.alive = !0),
                  (this.speed = 2 * Math.random() + 1);
              },
            },
          ]) && Du(e.prototype, n),
          i && Du(e, i),
          t
        );
      })();
    function Uu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var zu = (function () {
      function t(e) {
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, t),
          (this.texture = e),
          (this.start = this.start.bind(this)),
          (this.update = this.update.bind(this)),
          (this.mouseDown = this.mouseDown.bind(this)),
          (this.mouseUp = this.mouseUp.bind(this)),
          (this.readyToRestart = this.readyToRestart.bind(this)),
          (this.canvas = e.image),
          (this.ctx = this.canvas.getContext("2d")),
          (this.hero = new Ru()),
          (this.isPlaying = !0),
          (this.score = 0),
          (this.difficulty = 0.1),
          (this.obstacles = []);
        for (var n = 0; n < 3; n++) {
          var i = new Ou(this.canvas.width);
          this.obstacles.push(i);
        }
        this.buildings = [];
        for (var r = 0; r < 3; r++) {
          var o = new ku(this.canvas.width);
          this.buildings.push(o);
        }
        bu.once("minigame", this.start);
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "start",
            value: function () {
              (this.thenTime = performance.now()),
                (this.startTime = this.thenTime),
                gsap.ticker.add(this.update),
                bu.on("mouse:down", this.mouseDown),
                bu.on("mouse:up", this.mouseUp);
            },
          },
          {
            key: "clear",
            value: function () {
              var t = this.ctx,
                e = this.canvas.width,
                n = this.canvas.height;
              t.clearRect(0, 0, e, n),
                (t.fillStyle = "#22333D"),
                t.fillRect(0, 0, e, n);
            },
          },
          {
            key: "drawGround",
            value: function () {
              var t = this.ctx,
                e = this.canvas.width,
                n = this.canvas.height;
              (t.fillStyle = "#232323"), t.fillRect(0, n - 30, e, 30);
            },
          },
          {
            key: "mouseDown",
            value: function () {
              this.isPlaying
                ? ((this.startTime = performance.now()), this.hero.crouch())
                : this.allowRestart && this.reset();
            },
          },
          {
            key: "mouseUp",
            value: function () {
              this.isPlaying &&
                this.hero.jump(performance.now() - this.startTime);
            },
          },
          {
            key: "reset",
            value: function () {
              this.loseTimer && clearTimeout(this.loseTimer), (this.score = 0);
              for (var t = 0, e = this.obstacles.length; t < e; t++)
                this.obstacles[t].reset();
              this.hero.reset(), (this.isPlaying = !0);
            },
          },
          {
            key: "lose",
            value: function () {
              (this.isPlaying = !1),
                (this.allowRestart = !1),
                this.loseTimer && clearTimeout(this.loseTimer);
              var t = this.ctx,
                e = this.canvas.width,
                n = this.canvas.height;
              (t.fillStyle = "#000000"),
                (t.globalAlpha = 0.5),
                t.fillRect(0, 0, e, n),
                (t.globalAlpha = 1),
                (t.font = '20px "Lucida Console", Monaco, monospace'),
                (t.textAlign = "center"),
                (t.fillStyle = "#ffffff"),
                t.fillText(
                  this.score.toString().padStart(4, "0"),
                  0.5 * e,
                  0.55 * n
                ),
                (this.loseTimer = setTimeout(this.readyToRestart, 500));
            },
          },
          {
            key: "readyToRestart",
            value: function () {
              this.allowRestart = !0;
            },
          },
          {
            key: "incrementScore",
            value: function () {
              this.score++, (this.difficulty += 0.1);
              for (var t = 0, e = this.obstacles.length; t < e; t++)
                this.obstacles[t].setDifficulty(this.difficulty);
            },
          },
          {
            key: "update",
            value: function () {
              var t = performance.now(),
                e = t - this.thenTime;
              e > 1e3 / 30 &&
                ((this.thenTime = t - (e % (1e3 / 30))), this.animate(e));
            },
          },
          {
            key: "animate",
            value: function (t) {
              if (this.isPlaying) {
                this.clear(), this.drawGround();
                for (
                  var e = !1,
                    n = this.canvas.height - 30,
                    i = 0,
                    r = this.buildings.length;
                  i < r;
                  i++
                )
                  this.buildings[i].draw(this.ctx, n, t);
                for (var o = 0, s = this.obstacles.length; o < s; o++) {
                  var a = this.obstacles[o];
                  a.draw(this.ctx, n, t),
                    a.collide(this.hero) && (e = !0),
                    a.testDie() && this.incrementScore();
                }
                this.hero.draw(this.ctx, n),
                  e && this.lose(),
                  (this.texture.needsUpdate = !0);
              }
            },
          },
        ]) && Uu(e.prototype, n),
        i && Uu(e, i),
        t
      );
    })();
    function Bu(t) {
      return (Bu =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Fu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Hu(t, e) {
      return (Hu =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Gu(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Wu(t);
        if (e) {
          var r = Wu(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return ju(this, n);
      };
    }
    function ju(t, e) {
      return !e || ("object" !== Bu(e) && "function" != typeof e) ? Vu(t) : e;
    }
    function Vu(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Wu(t) {
      return (Wu = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var qu = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Hu(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = Gu(o);
      function o(t) {
        var e;
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, o),
          ((e = r.call(this)).showScreen = e.showScreen.bind(Vu(e))),
          (e.hideScreen = e.hideScreen.bind(Vu(e))),
          (e.startMiniGame = e.startMiniGame.bind(Vu(e))),
          (e.screenColor = new zt(1384229));
        return (
          (e.projectCanvas = document.createElement("canvas")),
          (e.ctx = e.projectCanvas.getContext("2d")),
          (e.projectTexture = new co(e.projectCanvas)),
          (e.projectTexture.minFilter = 1006),
          (e.projectTexture.magFilter = 1006),
          (e.projectTexture.wrapS = e.projectTexture.wrapT = 1e3),
          (e.projectScreen = t.clone()),
          e.add(e.projectScreen),
          e.projectScreen.geometry.attributes.uv.set([0, 1, 0, 0, 1, 0, 1, 1]),
          (e.projectScreen.material = new Wt({
            map: e.projectTexture,
            color: 16777215,
            transparent: !0,
            opacity: 0,
            lightMap: t.material.lightMap,
          })),
          bu.on("workitem:over", e.showScreen),
          bu.on("workitem:out", e.hideScreen),
          bu.once("mouse", e.startMiniGame),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "startMiniGame",
            value: function () {
              (this.gameCanvas = document.createElement("canvas")),
                (this.gameCanvas.width = 400),
                (this.gameCanvas.height = 270),
                (this.gameTexture = new co(this.gameCanvas)),
                (this.miniGame = new zu(this.gameTexture)),
                (this.gameScreen = this.projectScreen.clone()),
                this.add(this.gameScreen),
                (this.gameScreen.material = new Wt({
                  map: this.gameTexture,
                  color: 16777215,
                  lightMap: this.projectScreen.material.lightMap,
                  transparent: !0,
                  opacity: 1,
                })),
                (this.gameScreen.position.z += 0.001),
                bu.emit("minigame");
            },
          },
          {
            key: "showScreen",
            value: function (t, e) {
              this.projectCanvas.width = t.width;
              this.projectCanvas.height = t.height;
              var r = this.ctx;
              (r.fillStyle = "#" + this.screenColor.getHexString()),
                r.fillRect(100, 100, t.width, t.height),
                r.drawImage(t, 0, 0, t.width, t.height),
                (this.projectTexture.needsUpdate = !0),
                (this.projectScreen.material.opacity = 1),
                this.projectScreen.material.color.setStyle(e);
            },
          },
          {
            key: "hideScreen",
            value: function () {
              this.projectScreen.material.opacity = 0;
            },
          },
          {
            key: "update",
            value: function (t) {
              var e, n;
              this.gameScreen &&
                (this.gameScreen.material.opacity = this.projectScreen.material
                  .opacity
                  ? 0
                  : (n = 0) + ((1 - n) * (t - (e = 0.3))) / (0.5 - e));
            },
          },
        ]) && Fu(e.prototype, n),
        i && Fu(e, i),
        o
      );
    })(X);
    function Xu(t) {
      return (Xu =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Yu(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Zu(t, e) {
      return (Zu =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Ju(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Qu(t);
        if (e) {
          var r = Qu(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Ku(this, n);
      };
    }
    function Ku(t, e) {
      return !e || ("object" !== Xu(e) && "function" != typeof e) ? $u(t) : e;
    }
    function $u(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Qu(t) {
      return (Qu = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var th = (function (t) {
        !(function (t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
            e && Zu(t, e);
        })(o, t);
        var e,
          n,
          i,
          r = Ju(o);
        function o(t) {
          var e;
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
            t.geometry.computeBoundingBox();
          var n = t.geometry.boundingBox.getSize(new w());
          return (
            ((e = r.call(
              this,
              new Be(n.x, n.y, n.z),
              new Wt({
                color: 16711680,
                wireframe: !0,
                transparent: !0,
                opacity: 0,
              })
            )).originalMouse = t.material),
            (e.mouseUp = e.mouseUp.bind($u(e))),
            e.position.copy(t.position).add(new w(0.385, 0.965, 0.38)),
            e.rotation.set(0, 0.5, 0),
            lu && e.scale.setScalar(2),
            e
          );
        }
        return (
          (e = o),
          (n = [
            {
              key: "mouseOver",
              value: function () {
                (document.body.style.cursor = "pointer"),
                  gsap.to(this.originalMouse, {
                    duration: 0.5,
                    lightMapIntensity: 2,
                  });
              },
            },
            {
              key: "mouseOut",
              value: function () {
                (document.body.style.cursor = "default"),
                  gsap.to(this.originalMouse, {
                    duration: 0.5,
                    lightMapIntensity: 1,
                  });
              },
            },
            {
              key: "mouseDown",
              value: function () {
                bu.emit("mouse:down"),
                  lu
                    ? window.addEventListener("touchend", this.mouseUp, {
                        passive: !0,
                      })
                    : window.addEventListener("mouseup", this.mouseUp);
              },
            },
            {
              key: "mouseUp",
              value: function () {
                lu
                  ? window.removeEventListener("touchend", this.mouseUp, {
                      passive: !0,
                    })
                  : window.removeEventListener("mouseup", this.mouseUp),
                  bu.emit("mouse:up");
              },
            },
            {
              key: "click",
              value: function () {
                bu.emit("mouse");
              },
            },
          ]) && Yu(e.prototype, n),
          i && Yu(e, i),
          o
        );
      })(Ce),
      eh = n(1),
      nh = n.n(eh);
    function ih(t) {
      return (ih =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function rh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function oh(t, e) {
      return (oh =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function sh(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = ch(t);
        if (e) {
          var r = ch(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return ah(this, n);
      };
    }
    function ah(t, e) {
      return !e || ("object" !== ih(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function ch(t) {
      return (ch = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var lh = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && oh(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = sh(o);
      function o(t) {
        var e;
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, o),
          t.geometry.computeBoundingBox();
        t.geometry.boundingBox.getSize(new w());
        return (
          ((e = r.call(
            this,
            new Be(0.2, 0.1, 0.2),
            new Wt({
              color: 16711680,
              wireframe: !0,
              transparent: !0,
              opacity: 0,
            })
          )).originalBook = t.material),
          e.position.copy(t.position).add(new w(-0.68, 0.968, 0.33)),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "mouseOver",
            value: function () {
              (document.body.style.cursor = "pointer"),
                this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this.originalBook, {
                  duration: 0.5,
                  lightMapIntensity: 2,
                });
            },
          },
          {
            key: "mouseOut",
            value: function () {
              (document.body.style.cursor = "default"),
                this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this.originalBook, {
                  duration: 0.5,
                  lightMapIntensity: 1,
                });
            },
          },
          {
            key: "click",
            value: function () {
              bu.emit("book");
            },
          },
        ]) && rh(e.prototype, n),
        i && rh(e, i),
        o
      );
    })(Ce);
    function uh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var hh = (function () {
      function t(e) {
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, t),
          (this.onKeyUp = this.onKeyUp.bind(this)),
          (this.restart = this.restart.bind(this)),
          (this.answer = ["O", "U", "T"]),
          (this.sequence = this.answer.slice()),
          (this.keyboard = e.material),
          window.addEventListener("keyup", this.onKeyUp),
          bu.on("backin", this.restart);
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "restart",
            value: function () {
              this.reset(),
                window.removeEventListener("keyup", this.onKeyUp),
                window.addEventListener("keyup", this.onKeyUp);
            },
          },
          {
            key: "onKeyUp",
            value: function (t) {
              String.fromCharCode(t.keyCode) === this.sequence[0]
                ? (this.highlight(),
                  this.sequence.shift(),
                  this.sequence.length ||
                    (window.removeEventListener("keyup", this.onKeyUp),
                    this.complete()))
                : this.reset();
            },
          },
          {
            key: "reset",
            value: function () {
              this.sequence = this.answer.slice();
            },
          },
          {
            key: "complete",
            value: function () {
              bu.emit("out");
            },
          },
          {
            key: "highlight",
            value: function () {
              this.tl && this.tl.kill(),
                (this.tl = gsap.timeline()),
                this.tl.to(this.keyboard, {
                  duration: 0.5,
                  lightMapIntensity: 2,
                }),
                this.tl.to(this.keyboard, {
                  duration: 0.5,
                  lightMapIntensity: 1,
                });
            },
          },
        ]) && uh(e.prototype, n),
        i && uh(e, i),
        t
      );
    })();
    function ph(t) {
      return (ph =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function dh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function fh(t, e) {
      return (fh =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function mh(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = yh(t);
        if (e) {
          var r = yh(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return gh(this, n);
      };
    }
    function gh(t, e) {
      return !e || ("object" !== ph(e) && "function" != typeof e) ? vh(t) : e;
    }
    function vh(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function yh(t) {
      return (yh = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var xh = !hu().basic,
      bh = new Wc(),
      wh = new l(1e3, 1e3),
      _h = new w(0, 1, 0),
      Mh = new w(0, 0, 0),
      Sh = (function (t) {
        !(function (t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
            e && fh(t, e);
        })(o, t);
        var e,
          n,
          i,
          r = mh(o);
        function o(t, e) {
          var n;
          return (
            (function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, o),
            ((n = r.call(this)).onMouseMove = n.onMouseMove.bind(vh(n))),
            (n.onClick = n.onClick.bind(vh(n))),
            (n.updateColor = n.updateColor.bind(vh(n))),
            (n.onTransitionColorComplete = n.onTransitionColorComplete.bind(
              vh(n)
            )),
            (n.onTransitionColorUpdate = n.onTransitionColorUpdate.bind(vh(n))),
            (n.updateDestColor = n.updateDestColor.bind(vh(n))),
            (n.onMouseDown = n.onMouseDown.bind(vh(n))),
            (n.onTouchStart = n.onTouchStart.bind(vh(n))),
            (n.onTouchEnd = n.onTouchEnd.bind(vh(n))),
            (n.onTouchMove = n.onTouchMove.bind(vh(n))),
            (n.onKonami = n.onKonami.bind(vh(n))),
            (n.camera = t),
            (n.renderer = e),
            (n.color = new zt(2241341)),
            (n.colorDest = new zt(2241341)),
            (n.lightMapIntensity = 1),
            (n.center = new w(1.04, 0.968, 0.35)),
            (n.object = Ql.get("room").scene),
            n.add(n.object),
            (n.shaders = []),
            (n.progress = -1),
            n.object.traverse(function (t) {
              if (t.isMesh) {
                var e = t.geometry;
                e.setAttribute("uv2", e.getAttribute("uv").clone());
                var i = xh ? Ds : Wt,
                  r = Ql.get(t.name + "Texture");
                r &&
                  ((t.material = new i({
                    lightMap: r,
                    lightMapIntensity: n.lightMapIntensity,
                    dithering: !0,
                    color: n.color.getHex(),
                  })),
                  (t.material.onBeforeCompile = function (t) {
                    (t.uniforms.progress = { value: n.progress }),
                      (t.uniforms.colorDest = { value: n.colorDest }),
                      (t.uniforms.center = { value: n.center.clone() }),
                      (t.vertexShader =
                        "varying vec4 vMvPosition;\n" + t.vertexShader),
                      (t.vertexShader = t.vertexShader.replace(
                        "#include <project_vertex>",
                        [
                          "vec4 mvPosition = vec4( transformed, 1.0 );",
                          "mvPosition = modelViewMatrix * mvPosition;",
                          "vMvPosition = vec4( transformed, 1.0 ) * modelMatrix;",
                          "gl_Position = projectionMatrix * mvPosition;",
                        ].join("\n")
                      )),
                      (t.fragmentShader =
                        "uniform float progress;\nuniform vec3 colorDest;\nuniform vec3 center;\nvarying vec4 vMvPosition;\n" +
                        t.fragmentShader),
                      (t.fragmentShader = t.fragmentShader.replace(
                        "vec4 diffuseColor = vec4( diffuse, opacity );",
                        [
                          "float edge = 0.001;",
                          "float gradient = 0.01;",
                          "float d = distance(vMvPosition.xyz, center);",
                          "float t = progress * 5.674;",
                          "float frontiere = step(t, d);",
                          "float circle = 1.0 + smoothstep(t,t + gradient, d) - smoothstep(t - gradient, t, d);",
                          "vec4 diffuseColor = mix(vec4(vec3(4.0), 1.0), vec4( mix(colorDest, diffuse, frontiere), opacity ), circle);",
                        ].join("\n")
                      )),
                      n.shaders.push(t);
                  }),
                  (t.material.needsUpdate = !0));
              }
            }),
            (n.screen = new qu(n.object.getObjectByName("Screen"))),
            n.add(n.screen),
            lu
              ? (window.addEventListener("touchstart", n.onTouchStart, {
                  passive: !0,
                }),
                window.addEventListener("touchend", n.onTouchEnd, {
                  passive: !0,
                }),
                window.addEventListener("touchmove", n.onTouchMove, {
                  passive: !0,
                }))
              : (window.addEventListener("mousemove", n.onMouseMove),
                window.addEventListener("click", n.onClick),
                window.addEventListener("mousedown", n.onMouseDown)),
            (n.konami = new nh.a(n.onKonami)),
            (n.fakeLamp = new Au(n.object.getObjectByName("Lamp"))),
            n.add(n.fakeLamp),
            (n.fakeMouse = new th(n.object.getObjectByName("Mouse"))),
            n.add(n.fakeMouse),
            (n.fakeBook = new lh(n.object.getObjectByName("Moleskine"))),
            n.add(n.fakeBook),
            (n.fakeKeyboard = new hh(n.object.getObjectByName("Keyboard"))),
            (n.interactives = [n.fakeLamp, n.fakeMouse, n.fakeBook]),
            n
          );
        }
        return (
          (e = o),
          (n = [
            {
              key: "onMouseDown",
              value: function () {
                this.active && this.active.mouseDown && this.active.mouseDown();
              },
            },
            {
              key: "onKonami",
              value: function () {
                var t = new ua(),
                  e = "/assets/images/king.png",
                  n = t.load(e);
                (n.wrapS = n.wrapT = 1e3), n.repeat.set(10, 10);
                var i = t.load(e);
                (i.wrapS = i.wrapT = 1e3),
                  i.repeat.set(40, 40),
                  this.object.traverse(function (t) {
                    if (t.isMesh) {
                      var e = "Room" === t.name;
                      (t.material.map = e ? i : n),
                        t.material.color.setHex(16777215),
                        (t.material.needsUpdate = !0);
                    }
                  });
              },
            },
            {
              key: "updateColor",
              value: function () {
                var t = this;
                this.object.traverse(function (e) {
                  e.isMesh &&
                    !e.material.isMeshNormalMaterial &&
                    e.material.color.copy(t.color);
                });
              },
            },
            {
              key: "updateDestColor",
              value: function (t) {
                this.colorDest.setHex(t);
                for (var e = 0, n = this.shaders.length; e < n; e++)
                  this.shaders[e].uniforms.colorDest.value.copy(this.colorDest);
              },
            },
            {
              key: "transitionColor",
              value: function (t) {
                return (
                  this.tl &&
                    (this.tl.progress() > 0.5 &&
                      this.tl.progress() < 1 &&
                      this.onTransitionColorComplete(),
                    this.tl.kill()),
                  (this.tl = gsap.timeline({
                    onComplete: this.onTransitionColorComplete,
                    onUpdate: this.onTransitionColorUpdate,
                  })),
                  this.tl.call(this.updateDestColor, [t]),
                  this.tl.fromTo(
                    this,
                    { progress: 0 },
                    { progress: 1, duration: 2, ease: "expo.inOut" }
                  ),
                  this.tl
                );
              },
            },
            {
              key: "onTransitionColorUpdate",
              value: function () {
                Mh.copy(this.center).applyAxisAngle(_h, -this.rotation.y);
                for (var t = 0, e = this.shaders.length; t < e; t++) {
                  var n = this.shaders[t];
                  (n.uniforms.progress.value = this.progress),
                    n.uniforms.center.value.copy(Mh);
                }
              },
            },
            {
              key: "onTransitionColorComplete",
              value: function () {
                this.color.copy(this.colorDest),
                  (this.progress = -1),
                  this.onTransitionColorUpdate(),
                  this.updateColor();
              },
            },
            {
              key: "onClick",
              value: function (t) {
                this.active && this.active.click();
              },
            },
            {
              key: "onMouseMove",
              value: function (t) {
                (wh.x =
                  (t.clientX /
                    (this.renderer.domElement.width /
                      window.devicePixelRatio)) *
                    2 -
                  1),
                  (wh.y =
                    (-t.clientY /
                      (this.renderer.domElement.height /
                        window.devicePixelRatio)) *
                      2 +
                    1);
              },
            },
            {
              key: "onTouchStart",
              value: function (t) {
                (wh.x =
                  (t.touches[0].clientX /
                    (this.renderer.domElement.width /
                      window.devicePixelRatio)) *
                    2 -
                  1),
                  (wh.y =
                    (-t.touches[0].clientY /
                      (this.renderer.domElement.height /
                        window.devicePixelRatio)) *
                      2 +
                    1),
                  this.checkIntersections(),
                  this.active && t.preventDefault(),
                  this.onMouseDown();
              },
            },
            {
              key: "onTouchMove",
              value: function (t) {
                (wh.x =
                  (t.touches[0].clientX /
                    (this.renderer.domElement.width /
                      window.devicePixelRatio)) *
                    2 -
                  1),
                  (wh.y =
                    (-t.touches[0].clientY /
                      (this.renderer.domElement.height /
                        window.devicePixelRatio)) *
                      2 +
                    1);
              },
            },
            {
              key: "onTouchEnd",
              value: function (t) {
                this.checkIntersections(!0),
                  this.onClick(),
                  this.active && (this.active.mouseOut(), (this.active = null));
              },
            },
            {
              key: "checkIntersections",
              value: function () {
                var t =
                  arguments.length > 0 &&
                  void 0 !== arguments[0] &&
                  arguments[0];
                bh.setFromCamera(wh, this.camera);
                var e = bh.intersectObjects(this.interactives);
                if (e.length) {
                  var n = e[0].object;
                  this.active || t || n.mouseOver(), (this.active = n);
                } else
                  this.active && (this.active.mouseOut(), (this.active = null));
              },
            },
            {
              key: "update",
              value: function (t) {
                this.screen && this.screen.update(t),
                  lu || this.checkIntersections();
              },
            },
          ]) && dh(e.prototype, n),
          i && dh(e, i),
          o
        );
      })(X),
      Th = [
        {
          toneMappingExposure: 1,
          background: 3359822,
          frontLight: 16711680,
          backLight: 65280,
          room: 2241341,
          text: "#ffffff",
          voile: "#19252b",
        },
        {
          toneMappingExposure: 10,
          background: 16777215,
          frontLight: 16432492,
          backLight: 16730112,
          room: 10714748,
          text: "#4a4a4a",
          voile: "#D3C9C9",
        },
        {
          toneMappingExposure: 0.5,
          background: 16307314,
          frontLight: 16555641,
          backLight: 12165322,
          room: 16429909,
          text: "#ffffff",
          voile: "#3C2F19",
        },
        {
          toneMappingExposure: 1,
          background: 16777215,
          frontLight: 16777215,
          backLight: 16777215,
          room: 5066061,
          text: "#ffffff",
          voile: "#2E2F2F",
        },
        {
          toneMappingExposure: 1,
          background: 16384061,
          frontLight: 16711680,
          backLight: 0,
          room: 9701898,
          text: "#ffffff",
          voile: "#490707",
        },
        {
          toneMappingExposure: 20,
          background: 16777215,
          frontLight: 16777215,
          backLight: 16777215,
          room: 5066061,
          text: "#555555",
          voile: "#D0D1D1",
        },
        {
          toneMappingExposure: 1,
          background: 16440368,
          frontLight: 16759891,
          backLight: 16724992,
          room: 16771293,
          text: "#ffffff",
          voile: "#5F5B58",
        },
        {
          toneMappingExposure: 20,
          background: 16777215,
          frontLight: 16068142,
          backLight: 159743,
          room: 1099541,
          text: "#454545",
          voile: "#7DEC8F",
        },
      ],
      Eh = 0;
    function Ah() {
      return Th[Eh];
    }
    var Lh = function () {
      try {
        var t = document.createElement("canvas");
        return !(!window.WebGL2RenderingContext || !t.getContext("webgl2"));
      } catch (t) {
        return !1;
      }
    };
    function Rh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var Ph = (function () {
      function t(e) {
        !(function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        })(this, t),
          (this.resize = this.resize.bind(this)),
          (this.update = this.update.bind(this)),
          (this.onLoadComplete = this.onLoadComplete.bind(this)),
          (this.onMouseMove = this.onMouseMove.bind(this)),
          (this.changeColorScheme = this.changeColorScheme.bind(this)),
          (this.onDeviceOrientation = this.onDeviceOrientation.bind(this)),
          (this.onTouchStart = this.onTouchStart.bind(this)),
          (this.getOut = this.getOut.bind(this)),
          (this.onMotionPathUpdate = this.onMotionPathUpdate.bind(this));
        var n = hu(),
          i = Lh(),
          r = document.createElement("canvas"),
          o = r.getContext(
            i && !n.gl1 ? "webgl2" : "webgl",
            i ? { alpha: !0 } : null
          );
        n.debug && console.log("context", o),
          (this.renderer = new sr({ canvas: r, context: o, transparent: !0 })),
          this.renderer.setPixelRatio(window.devicePixelRatio),
          e.appendChild(this.renderer.domElement);
        var s = this.renderer.getContext();
        (this.renderer.toneMapping = 2),
          (this.renderer.toneMappingExposure = 1),
          (this.scene = new Y()),
          (this.scene.background = new zt(3359822)),
          (this.camera = new We(
            35,
            window.innerWidth / window.innerHeight,
            0.1,
            100
          )),
          (this.cameraContainer = new X()),
          this.scene.add(this.cameraContainer),
          this.camera.position.set(0, 2, 3.3131),
          this.camera.lookAt(0, 0.6, 0),
          this.cameraContainer.add(this.camera),
          (this.frontLight = new Fa(16711680, 0.5)),
          this.scene.add(this.frontLight),
          this.frontLight.position.set(4, 2, 0),
          (this.backLight = new Fa(65280, 0.5)),
          this.scene.add(this.backLight),
          this.backLight.position.set(-6, 2, 0),
          (this.mouse = { x: 0, y: 0 }),
          (this.orientation = 0),
          (this.stayInside = new Ce(
            new Be(3, 1, 0.1),
            new Wt({ color: 16777215 })
          )),
          this.scene.add(this.stayInside),
          (this.stayInside.rotation.y = 0.5 * -Math.PI),
          this.stayInside.position.set(20, 1.72, 2.15),
          (this.clock = new vc(!0)),
          Ql.init(
            new nu(),
            new ru(this.renderer),
            new fu(this.renderer, !!s.getExtension("EXT_color_buffer_float"))
          ),
          Ql.load(xu, "/assets/models/").then(this.onLoadComplete);
      }
      var e, n, i;
      return (
        (e = t),
        (n = [
          {
            key: "onLoadComplete",
            value: function () {
              (this.room = new Sh(this.camera, this.renderer)),
                this.scene.add(this.room),
                this.resize(),
                gsap.ticker.add(this.update),
                lu
                  ? (window.addEventListener(
                      "deviceorientation",
                      this.onDeviceOrientation,
                      !0
                    ),
                    window.addEventListener("touchstart", this.onTouchStart, {
                      passive: !0,
                    }))
                  : window.addEventListener("mousemove", this.onMouseMove),
                bu.on("lamp", this.changeColorScheme),
                bu.on("out", this.getOut),
                this.applyScheme(Ah());
              var t = document.querySelector(".Voile"),
                e = gsap.timeline();
              e.fromTo(
                t,
                { alpha: 1 },
                { alpha: 0, duration: 0.5, ease: "none" },
                0
              ),
                e.fromTo(
                  this.camera.position,
                  { x: -0.09715, y: 1.38336, z: 0.562871 },
                  {
                    x: cu ? 0.35 : -0.15,
                    y: cu ? 2.9 : 2,
                    z: cu ? 5.3131 : 3.3131,
                    duration: 4,
                    ease: "none",
                  },
                  0.5
                ),
                e.fromTo(
                  this.camera.quaternion,
                  { x: 0 },
                  { x: -0.2, duration: 4, ease: "none" },
                  0.5
                ),
                e.pause(0),
                (this.tl = e);
            },
          },
          {
            key: "changeColorScheme",
            value: function () {
              this.transitionScheme(
                ((Eh = Eh >= Th.length - 1 ? 0 : Eh + 1), Ah())
              );
            },
          },
          {
            key: "applyScheme",
            value: function (t) {
              (this.renderer.toneMappingExposure = t.toneMappingExposure),
                this.scene.background.setHex(t.background),
                this.frontLight.color.setHex(t.frontLight),
                this.backLight.color.setHex(t.backLight),
                this.room.color.setHex(t.room),
                (document.body.style.color = t.text),
                (document.querySelector(".Voile").style.background = t.voile),
                this.room.updateColor();
            },
          },
          {
            key: "transitionScheme",
            value: function (t) {
              this.tlColor && this.tlColor.kill(),
                (this.tlColor = gsap.timeline()),
                this.tlColor.add(this.room.transitionColor(t.room), 0),
                this.tlColor.to(
                  this.renderer,
                  {
                    toneMappingExposure: t.toneMappingExposure,
                    duration: 1,
                    ease: "expo.in",
                  },
                  0
                ),
                this.tlColor.add(
                  Ch(this.frontLight.color, new zt(t.frontLight)),
                  0
                ),
                this.tlColor.add(
                  Ch(this.backLight.color, new zt(t.backLight)),
                  0
                ),
                this.tlColor.add(
                  Ch(this.scene.background, new zt(t.background)),
                  0
                ),
                this.tlColor.to(
                  document.body,
                  { color: t.text, duration: 1, ease: "expo.in" },
                  0
                ),
                this.tlColor.to(
                  document.querySelector(".Voile"),
                  { background: t.voile, duration: 1, ease: "expo.in" },
                  0
                );
            },
          },
          {
            key: "getOut",
            value: function () {
              var t = this;
              (this.stayInside.material.map = new ua().load(
                "/assets/images/inside.png"
              )),
                (this.motionPath = {
                  x: this.camera.position.x,
                  y: this.camera.position.z,
                }),
                (this.isOut = !0),
                this.outTl && this.outTl.kill(),
                (this.outTl = gsap.timeline({
                  onUpdate: this.onMotionPathUpdate,
                  onComplete: function () {
                    t.getBackIn();
                  },
                })),
                this.outTl.to(
                  this.motionPath,
                  {
                    motionPath: [
                      { x: 0.5, y: 2.5 },
                      { x: 13, y: 2.15 },
                    ],
                    ease: "cubic.inOut",
                    duration: 7,
                  },
                  0
                ),
                this.outTl.to(
                  this.camera.position,
                  { y: 1.8, ease: "cubic.inOut", duration: 7 },
                  0
                ),
                this.outTl.to(
                  this.camera.quaternion,
                  { x: 0, y: -0.7, duration: 4, ease: "cubic.inOut" },
                  0
                ),
                this.outTl.to(
                  this.cameraContainer.rotation,
                  { y: 0, duration: 4, ease: "cubic.inOut" },
                  0
                ),
                this.outTl.to(
                  document.querySelectorAll(".Container, .Menu, .Footer"),
                  { alpha: 0, duration: 1 },
                  0
                );
            },
          },
          {
            key: "onMotionPathUpdate",
            value: function () {
              (this.camera.position.x = this.motionPath.x),
                (this.camera.position.z = this.motionPath.y);
            },
          },
          {
            key: "getBackIn",
            value: function () {
              var t = this;
              (this.motionPath = {
                x: this.camera.position.x,
                y: this.camera.position.z,
              }),
                this.outTl && this.outTl.kill(),
                (this.outTl = gsap.timeline({
                  onUpdate: this.onMotionPathUpdate,
                  onComplete: function () {
                    bu.emit("backin"), (t.isOut = !1);
                  },
                })),
                this.outTl.to(
                  this.motionPath,
                  {
                    motionPath: [
                      { x: 0.5, y: 2.5 },
                      { x: -0.15, y: 3.3131 },
                    ],
                    ease: "cubic.inOut",
                    duration: 7,
                  },
                  0
                ),
                this.outTl.to(
                  this.camera.position,
                  { y: 2, ease: "cubic.inOut", duration: 7 },
                  0
                ),
                this.outTl.to(
                  this.camera.quaternion,
                  { x: -0.2, y: 0, duration: 4, ease: "cubic.inOut" },
                  "-=4"
                ),
                this.outTl.to(window, { scrollTo: "max", duration: 2 }, "-=2"),
                this.outTl.to(
                  document.querySelectorAll(".Container, .Menu, .Footer"),
                  { alpha: 1, duration: 1 },
                  "-=1"
                );
            },
          },
          {
            key: "onMouseMove",
            value: function (t) {
              (this.mouse.x = (t.clientX / window.innerWidth) * 2 - 1),
                (this.mouse.y = (-t.clientY / window.innerHeight) * 2 + 1);
            },
          },
          {
            key: "onDeviceOrientation",
            value: function (t) {
              this.orientation = (-t.gamma / 90) * 1.5;
            },
          },
          {
            key: "onTouchStart",
            value: function (t) {
              (this.mouse.x =
                (t.touches[0].clientX / window.innerWidth) * 2 - 1),
                (this.mouse.y =
                  (-t.touches[0].clientY / window.innerHeight) * 2 + 1);
            },
          },
          {
            key: "resize",
            value: function () {
              var t = window.innerWidth,
                e = lu ? window.innerHeight + 100 : window.innerHeight;
              this.renderer.setSize(t, e),
                (this.camera.aspect = t / e),
                this.camera.updateProjectionMatrix(),
                (this.height = e),
                (this.width = t);
            },
          },
          {
            key: "update",
            value: function () {
              this.room && this.room.update(this.tl.progress()),
                this.isOut ||
                  (this.cameraContainer.rotation.y +=
                    0.1 *
                    (0.5 * (lu ? this.orientation : this.mouse.x) -
                      this.cameraContainer.rotation.y)),
                this.renderer.render(this.scene, this.camera);
            },
          },
        ]) && Rh(e.prototype, n),
        i && Rh(e, i),
        t
      );
    })();
    function Ch(t, e) {
      var n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
        i =
          arguments.length > 3 && void 0 !== arguments[3]
            ? arguments[3]
            : "expo.in",
        r = t.getHSL({}),
        o = e.getHSL({});
      return gsap.to(
        r,
        Object.assign(o, {
          duration: n,
          ease: i,
          onUpdate: function () {
            t.setHSL(r.h, r.s, r.l);
          },
        })
      );
    }
    function Oh(t) {
      return (Oh =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Ih(t, e) {
      return (Ih =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Dh(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = kh(t);
        if (e) {
          var r = kh(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Nh(this, n);
      };
    }
    function Nh(t, e) {
      return !e || ("object" !== Oh(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function kh(t) {
      return (kh = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Uh = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Ih(t, e);
      })(n, t);
      var e = Dh(n);
      function n(t) {
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, n),
          e.call(this, t)
        );
      }
      return n;
    })(o.a);
    function zh(t) {
      return (zh =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Bh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Fh(t, e) {
      return (Fh =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Hh(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = jh(t);
        if (e) {
          var r = jh(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Gh(this, n);
      };
    }
    function Gh(t, e) {
      return !e || ("object" !== zh(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function jh(t) {
      return (jh = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Vh = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Fh(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = Hh(o);
      function o(t) {
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          r.call(this, t)
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "transitionIn",
            value: function () {
              var t = gsap.timeline();
              return (
                t.fromTo(
                  this.$el,
                  { alpha: 0, scaleY: 0 },
                  { alpha: 1, duration: 1, scaleY: 1, ease: "expo.out" }
                ),
                t
              );
            },
          },
        ]) && Bh(e.prototype, n),
        i && Bh(e, i),
        o
      );
    })(o.a);
    function Wh(t) {
      return (Wh =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function qh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Xh(t, e) {
      return (Xh =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Yh(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Kh(t);
        if (e) {
          var r = Kh(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Zh(this, n);
      };
    }
    function Zh(t, e) {
      return !e || ("object" !== Wh(e) && "function" != typeof e) ? Jh(t) : e;
    }
    function Jh(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Kh(t) {
      return (Kh = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var $h = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Xh(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = Yh(o);
      function o(t) {
        var e;
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          (e = r.call(this, t)),
          lu ||
            ((e.onMouseOver = e.onMouseOver.bind(Jh(e))),
            (e.onMouseOut = e.onMouseOut.bind(Jh(e))),
            e.$el.addEventListener("mouseover", e.onMouseOver),
            e.$el.addEventListener("mouseout", e.onMouseOut),
            (e.src =
              "/assets/images/projects/" + e.$el.getAttribute("data-src")),
            (e.color = e.$el.getAttribute("data-color") || "#ffffff"),
            (e.image = new Image()),
            (e.image.src = e.src)),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "onMouseOver",
            value: function () {
              bu.emit("workitem:over", this.image, this.color);
            },
          },
          {
            key: "onMouseOut",
            value: function () {
              bu.emit("workitem:out");
            },
          },
        ]) && qh(e.prototype, n),
        i && qh(e, i),
        o
      );
    })(o.a);
    function Qh(t) {
      return (Qh =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function tp(t, e) {
      return (tp =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function ep(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = ip(t);
        if (e) {
          var r = ip(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return np(this, n);
      };
    }
    function np(t, e) {
      return !e || ("object" !== Qh(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function ip(t) {
      return (ip = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var rp = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && tp(t, e);
      })(n, t);
      var e = ep(n);
      function n(t) {
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, n),
          e.call(this, t)
        );
      }
      return n;
    })(o.a);
    function op(t) {
      return (op =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function sp(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function ap(t, e) {
      return (ap =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function cp(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = hp(t);
        if (e) {
          var r = hp(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return lp(this, n);
      };
    }
    function lp(t, e) {
      return !e || ("object" !== op(e) && "function" != typeof e) ? up(t) : e;
    }
    function up(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function hp(t) {
      return (hp = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var pp = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && ap(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = cp(o);
      function o(t) {
        var e;
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          ((e = r.call(this, t)).onLoaderComplete = e.onLoaderComplete.bind(
            up(e)
          )),
          (e.onPreloadProgress = e.onPreloadProgress.bind(up(e))),
          (e.onPreloadComplete = e.onPreloadComplete.bind(up(e))),
          (e.$bar = e.$one(".Loader-scaler")),
          (e._progress = 1),
          Ql.emitter.on("progress", e.onPreloadProgress),
          Ql.emitter.once("complete", e.onPreloadComplete),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "onPreloadProgress",
            value: function (t) {
              this.progress = 0.5 + 0.5 * (1 - t);
            },
          },
          {
            key: "onPreloadComplete",
            value: function () {
              gsap
                .timeline({ onComplete: this.onLoaderComplete })
                .to(this, { progress: 0.06, ease: "expo.out", duration: 1.8 });
            },
          },
          {
            key: "onLoaderComplete",
            value: function () {
              bu.emit("loader:complete"), this.dispose();
            },
          },
          {
            key: "progress",
            get: function () {
              return this._progress;
            },
            set: function (t) {
              (this._progress = t),
                (this.$bar.style.transform = "scaleX(" + t + ")");
            },
          },
        ]) && sp(e.prototype, n),
        i && sp(e, i),
        o
      );
    })(o.a);
    function dp(t) {
      return (dp =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function fp(t, e) {
      return (fp =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function mp(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = vp(t);
        if (e) {
          var r = vp(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return gp(this, n);
      };
    }
    function gp(t, e) {
      return !e || ("object" !== dp(e) && "function" != typeof e)
        ? (function (t) {
            if (void 0 === t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return t;
          })(t)
        : e;
    }
    function vp(t) {
      return (vp = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var yp = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && fp(t, e);
      })(n, t);
      var e = mp(n);
      function n(t) {
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, n),
          e.call(this, t)
        );
      }
      return n;
    })(o.a);
    function xp(t) {
      return (xp =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function bp(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function wp(t, e) {
      return (wp =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function _p(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Tp(t);
        if (e) {
          var r = Tp(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Mp(this, n);
      };
    }
    function Mp(t, e) {
      return !e || ("object" !== xp(e) && "function" != typeof e) ? Sp(t) : e;
    }
    function Sp(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Tp(t) {
      return (Tp = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Ep = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && wp(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = _p(o);
      function o(t) {
        var e;
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          ((e = r.call(this, t)).onLinkClick = e.onLinkClick.bind(Sp(e))),
          (e.onRoute = e.onRoute.bind(Sp(e))),
          (e.$links = e.$all("a")),
          e.$links.forEach(function (t) {
            t.addEventListener("click", e.onLinkClick);
          }),
          bu.on("route", e.onRoute),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "onRoute",
            value: function (t) {
              this.$links.forEach(function (t) {
                return t.setAttribute("class", null);
              });
              var e = 'a[data-route="' + ("" === t ? "home" : t) + '"]';
              this.$one(e).setAttribute("class", "selected");
            },
          },
          {
            key: "onLinkClick",
            value: function (t) {
              t.preventDefault(),
                bu.emit("nav", t.currentTarget.getAttribute("data-id"));
            },
          },
        ]) && bp(e.prototype, n),
        i && bp(e, i),
        o
      );
    })(o.a);
    function Ap(t) {
      return (Ap =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Lp(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Rp(t, e) {
      return (Rp =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function Pp(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Ip(t);
        if (e) {
          var r = Ip(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Cp(this, n);
      };
    }
    function Cp(t, e) {
      return !e || ("object" !== Ap(e) && "function" != typeof e) ? Op(t) : e;
    }
    function Op(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Ip(t) {
      return (Ip = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Dp = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Rp(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = Pp(o);
      function o(t) {
        var e;
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          ((e = r.call(this, t)).transitionIn = e.transitionIn.bind(Op(e))),
          bu.on("loader:complete", e.transitionIn),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "transitionIn",
            value: function () {
              var t = this;
              this.tl = gsap.timeline();
              var e = 0;
              this.$all(".gg").forEach(function (n) {
                var i = [].slice.call(n.querySelectorAll(".gg-symbol"));
                i &&
                  i.length &&
                  t.tl.fromTo(
                    i,
                    { x: 400, alpha: 0 },
                    {
                      x: 0,
                      alpha: 1,
                      duration: 1,
                      ease: "expo.out",
                      stagger: 0.1,
                    },
                    0 + e
                  ),
                  (e += 0.02);
              }),
                this.tl.fromTo(
                  this.$one(".Title"),
                  { x: 400, alpha: 0 },
                  { x: 0, alpha: 1, duration: 1, ease: "expo.out" },
                  0.2
                ),
                this.tl.add(this.refs.arrow.transitionIn(), 0.4);
            },
          },
        ]) && Lp(e.prototype, n),
        i && Lp(e, i),
        o
      );
    })(o.a);
    function Np(t) {
      return (Np =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function kp(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Up(t, e) {
      return (Up =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function zp(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Hp(t);
        if (e) {
          var r = Hp(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Bp(this, n);
      };
    }
    function Bp(t, e) {
      return !e || ("object" !== Np(e) && "function" != typeof e) ? Fp(t) : e;
    }
    function Fp(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Hp(t) {
      return (Hp = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Gp = (function (t) {
      !(function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && Up(t, e);
      })(o, t);
      var e,
        n,
        i,
        r = zp(o);
      function o(t) {
        var e;
        return (
          (function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, o),
          ((e = r.call(this, t)).onBookClick = e.onBookClick.bind(Fp(e))),
          (e.hasSplit = !1),
          (e.$p = e.$one(".About-content > p")),
          bu.on("book", e.onBookClick),
          e
        );
      }
      return (
        (e = o),
        (n = [
          {
            key: "split",
            value: function () {
              this.hasSplit = !0;
              var t = this.$p.innerHTML
                .replace("developer", "devel<span>o</span>per")
                .replace("I use", "I <span>u</span>se")
                .replace("technical", "<span>t</span>echnical");
              (this.$p.innerHTML = t),
                (this.$letters = [].slice.call(
                  this.$p.querySelectorAll("span")
                ));
            },
          },
          {
            key: "onBookClick",
            value: function (t) {
              var e = this;
              this.hasSplit || this.split(),
                (this.tl && this.tl.isActive()) ||
                  ((this.tl = gsap.timeline({
                    onComplete: function () {
                      (e.$p.style = null), (e.$letters.style = null);
                    },
                  })),
                  this.tl.to(this.$p, {
                    color: "rgba(255, 255, 255, 0.2)",
                    duration: 1,
                  }),
                  this.tl.to(this.$letters, {
                    color: "rgba(255, 255, 255, 1)",
                    duration: 1,
                    stagger: 1,
                  }),
                  this.tl.to(
                    this.$p,
                    { color: "rgba(255, 255, 255, 1)", duration: 1 },
                    "+=1"
                  ),
                  this.tl.set(this.$letters, { clearProps: "all" }),
                  this.tl.set(this.$p, { clearProps: "all" }));
            },
          },
        ]) && kp(e.prototype, n),
        i && kp(e, i),
        o
      );
    })(o.a);
    function jp(t) {
      return (jp =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    function Vp(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    function Wp(t, e) {
      return (Wp =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    function qp(t) {
      var e = (function () {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      })();
      return function () {
        var n,
          i = Zp(t);
        if (e) {
          var r = Zp(this).constructor;
          n = Reflect.construct(i, arguments, r);
        } else n = i.apply(this, arguments);
        return Xp(this, n);
      };
    }
    function Xp(t, e) {
      return !e || ("object" !== jp(e) && "function" != typeof e) ? Yp(t) : e;
    }
    function Yp(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function Zp(t) {
      return (Zp = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          })(t);
    }
    var Jp,
      Kp,
      $p = (function (t) {
        !(function (t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
            e && Wp(t, e);
        })(o, t);
        var e,
          n,
          i,
          r = qp(o);
        function o(t) {
          var e;
          return (
            (function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, o),
            ((e = r.call(this, t)).transitionIn = e.transitionIn.bind(Yp(e))),
            bu.on("loader:complete", e.transitionIn),
            e
          );
        }
        return (
          (e = o),
          (n = [
            {
              key: "transitionIn",
              value: function () {
                (this.tl = gsap.timeline()),
                  this.tl.fromTo(
                    this.$el,
                    { x: 400, alpha: 0 },
                    { x: 0, alpha: 1, duration: 1, ease: "expo.out" },
                    0.2
                  ),
                  this.tl.add(this.refs.arrow.transitionIn(), 0.8);
              },
            },
          ]) && Vp(e.prototype, n),
          i && Vp(e, i),
          o
        );
      })(o.a),
      Qp =
        (n(2),
        (Jp = document.body),
        (Kp = i),
        new o.a(Jp, function (t) {
          return Kp[t];
        })),
      td = new Ph(Qp.$one(".gl")),
      ed = Qp.$one(".FakeScroll"),
      nd = Qp.$one(".Container"),
      id = Qp.$one(".Content"),
      rd = Qp.$one(".Home"),
      od = Qp.$one(".Work"),
      sd = document.documentElement.scrollTop || document.body.scrollTop,
      ad = sd,
      cd = "",
      ld = 0,
      ud = !1,
      hd = !1,
      pd = [0, 0];
    function dd(t) {
      t !== cd &&
        ((cd = t), history.pushState(null, "", "/" + t), bu.emit("route", t));
    }
    function fd() {
      (ld = ed.offsetHeight - window.innerHeight),
        (ed.style.height = id.offsetHeight + "px"),
        (pd[0] = 0.5 * rd.offsetHeight),
        (pd[1] = od.offsetTop + od.offsetHeight - 0.5 * window.innerHeight),
        (ud = window.innerWidth < 768 || window.innerHeight < 600),
        (nd.style.position = ud ? "relative" : "fixed"),
        ud && (id.style.transform = 0),
        td.resize();
    }
    fd(),
      gsap.registerPlugin(ScrollToPlugin),
      gsap.registerPlugin(MotionPathPlugin),
      gsap.set(window, { scrollTo: 0 }),
      window.addEventListener(
        "scroll",
        function () {
          (sd = document.documentElement.scrollTop || document.body.scrollTop) <
          pd[0]
            ? dd("")
            : sd < pd[1]
            ? dd("work")
            : dd("about");
        },
        { passive: !0 }
      ),
      lu
        ? (window.addEventListener("orientationchange", function () {
            window.addEventListener("resize", function t() {
              fd(), window.removeEventListener("resize", t);
            });
          }),
          setTimeout(fd))
        : window.addEventListener("resize", fd),
      bu.on("nav", function (t) {
        gsap.to(window, { duration: 0.5, scrollTo: "." + t });
      }),
      bu.on("out", function () {
        hd = !0;
      }),
      bu.on("backin", function () {
        hd = !1;
      }),
      gsap.ticker.add(function () {
        lu && td.height !== window.innerHeight + 100 && fd();
        (ad += 0.1 * (sd - ad)),
          ud || (id.style.transform = "translateY(" + -ad + "px)");
        td.tl && !hd && (ld <= 0 && fd(), td.tl.progress(ad / ld));
      }),
      gsap.ticker.fps(60);
  },
]);
